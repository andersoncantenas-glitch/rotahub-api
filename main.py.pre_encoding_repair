# -*- coding: utf-8 -*-
# ==========================
# ===== INCIO DA PARTE 1 =====
# ==========================
import json
import logging
import os
import re
import sqlite3
import tkinter as tk
import urllib.error
import urllib.request
from tkinter import simpledialog, ttk, messagebox, filedialog
import shutil
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP
try:
    import pandas as pd
except Exception:
    pd = None
from datetime import datetime
try:
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
except Exception:
    canvas = None
    A4 = None
from contextlib import contextmanager
import random
import string
import base64
import hashlib
import hmac
import secrets

# =========================================================
# CONSTANTES E CONFIGURAÃƒâ€¡Ãƒâ€¢ES
# =========================================================
APP_W, APP_H = 1360, 780
DB_PATH = os.path.join(os.path.dirname(__file__), "rota_granja.db")
DB_NAME = "rota_granja"

API_BASE_URL = os.environ.get("ROTA_SERVER_URL", "http://127.0.0.1:8000").strip().rstrip("/")
if not API_BASE_URL:
    API_BASE_URL = "http://127.0.0.1:8000"
try:
    API_SYNC_TIMEOUT = float(os.environ.get("ROTA_SYNC_TIMEOUT", "15"))
except Exception:
    API_SYNC_TIMEOUT = 15.0

# Log global em DEBUG (pedido do usuario)
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

# =========================================================
# GERENCIADOR DE BANCO DE DADOS (CONTEXT MANAGER)
# =========================================================
def _configure_sqlite(conn: sqlite3.Connection) -> sqlite3.Connection:
    """Aplica pragmas de desempenho/concorrência."""
    try:
        conn.execute("PRAGMA foreign_keys = ON")
        conn.execute("PRAGMA journal_mode = WAL")
        conn.execute("PRAGMA synchronous = NORMAL")
        conn.execute("PRAGMA busy_timeout = 5000")
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)
    return conn

@contextmanager
def get_db():
    """Gerenciador de contexto para conexões com o banco"""
    conn = sqlite3.connect(DB_PATH)
    _configure_sqlite(conn)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()

def db_connect():
    """FunÃ§Ã£o compatÃ­vel para cÃ³digo existente"""
    conn = sqlite3.connect(DB_PATH)
    _configure_sqlite(conn)
    return conn

# =========================================================
# FUNÃƒÆ’Ã¢â‚¬Â¡ÃƒÆ’Ã¢â‚¬Â¢ES UTILITÃƒÆ’Ã‚ÂRIAS
# =========================================================
def upper(s):
    return str(s).strip().upper() if s is not None else ""

def format_equipe_nomes(ajudante1: str, ajudante2: str, fallback: str = "") -> str:
    a1 = upper(ajudante1)
    a2 = upper(ajudante2)
    nomes = " / ".join([n for n in [a1, a2] if n])
    if nomes:
        return nomes
    return upper(fallback)

def resolve_equipe_nomes(equipe_raw: str) -> str:
    codigo = upper(equipe_raw)
    if not codigo:
        return ""
    try:
        with get_db() as conn:
            cur = conn.cursor()

            # equipes (ajudante1/ajudante2)
            try:
                cur.execute(
                    "SELECT ajudante1, ajudante2 FROM equipes WHERE UPPER(codigo)=UPPER(?) LIMIT 1",
                    (codigo,),
                )
                r = cur.fetchone()
                if r:
                    nomes = format_equipe_nomes(r[0], r[1], codigo)
                    if nomes:
                        return nomes
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            # equipe_integrantes (quando existir)
            try:
                cur.execute(
                    "SELECT nome FROM equipe_integrantes WHERE equipe_codigo=? ORDER BY nome ASC",
                    (codigo,),
                )
                rows = cur.fetchall() or []
                nomes = [upper(r[0]) for r in rows if r and r[0]]
                if nomes:
                    return " / ".join(nomes)
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            # Fallbacks antigos
            for sql, params in [
                ("SELECT integrantes FROM equipes WHERE codigo=? LIMIT 1", (codigo,)),
                ("SELECT integrantes FROM equipes WHERE cod_equipe=? LIMIT 1", (codigo,)),
                ("SELECT nomes FROM equipes WHERE codigo=? LIMIT 1", (codigo,)),
                ("SELECT nomes FROM equipes WHERE cod_equipe=? LIMIT 1", (codigo,)),
                ("SELECT nome FROM equipes WHERE codigo=? LIMIT 1", (codigo,)),
                ("SELECT nome FROM equipes WHERE cod_equipe=? LIMIT 1", (codigo,)),
            ]:
                try:
                    cur.execute(sql, params)
                    r = cur.fetchone()
                    if r and r[0]:
                        return upper(r[0])
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)

    return codigo

def safe_float(v, default=0.0):
    try:
        if v is None:
            return default
        if isinstance(v, str):
            v = v.replace("R$", "").replace(".", "").replace(",", ".").strip()
        return float(v)
    except Exception:
        return default

def safe_money(v, default=0.0):
    """Converte valor monetário para float com 2 casas (Decimal)."""
    try:
        if v is None:
            return default
        s = str(v).replace("R$", "").strip()
        if not s:
            return default
        s = s.replace(".", "").replace(",", ".")
        d = Decimal(s).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
        return float(d)
    except (InvalidOperation, ValueError):
        return default

def normalize_date(s: str):
    """Normaliza para YYYY-MM-DD. Retorna '' se vazio, None se inválido."""
    s = (s or "").strip()
    if not s:
        return ""
    part = s.split()[0]
    if "-" in part and len(part) >= 10:
        try:
            y, m, d = part[:10].split("-")
            y, m, d = int(y), int(m), int(d)
            return f"{y:04d}-{m:02d}-{d:02d}"
        except Exception:
            return None
    if "/" in part and len(part) >= 10:
        try:
            d, m, y = part[:10].split("/")
            y, m, d = int(y), int(m), int(d)
            return f"{y:04d}-{m:02d}-{d:02d}"
        except Exception:
            return None
    return None

def normalize_time(s: str):
    """Normaliza para HH:MM. Retorna '' se vazio, None se inválido."""
    s = (s or "").strip()
    if not s:
        return ""
    part = s.split()[0]
    try:
        pieces = part.split(":")
        hh = int(pieces[0])
        mm = int(pieces[1]) if len(pieces) > 1 else 0
        if 0 <= hh <= 23 and 0 <= mm <= 59:
            return f"{hh:02d}:{mm:02d}"
    except Exception:
        return None


class SyncError(Exception):
    """Erro específico ao tentar sincronizar com a API mobile."""


def _build_api_url(path: str) -> str:
    path = (path or "").strip().lstrip("/")
    if path:
        return f"{API_BASE_URL}/{path}"
    return API_BASE_URL


def _call_api(method: str, path: str, payload=None, token: str = None):
    url = _build_api_url(path)
    headers = {"Accept": "application/json"}
    data = None
    if payload is not None:
        data = json.dumps(payload, ensure_ascii=False).encode("utf-8")
        headers["Content-Type"] = "application/json; charset=utf-8"
    if token:
        headers["Authorization"] = f"Bearer {token}"

    req = urllib.request.Request(url, data=data, headers=headers, method=method.upper())
    try:
        with urllib.request.urlopen(req, timeout=API_SYNC_TIMEOUT) as resp:
            body = resp.read()
            if not body:
                return {}
            text = body.decode("utf-8")
            return json.loads(text)
    except urllib.error.HTTPError as exc:
        body = exc.read()
        detail = ""
        if body:
            try:
                payload = json.loads(body.decode("utf-8"))
                if isinstance(payload, dict):
                    detail = payload.get("detail") or payload.get("message") or str(payload)
                else:
                    detail = str(payload)
            except Exception:
                detail = body.decode("utf-8", errors="ignore")
        raise SyncError(f"{exc.code} {exc.reason}: {detail or 'Sem detalhes'}")
    except urllib.error.URLError as exc:
        raise SyncError(f"Falha ao conectar-se a {url}: {exc.reason}")
    except Exception as exc:
        raise SyncError(f"Erro inesperado ao chamar a API de sincronização: {exc}")
    return None

def normalize_date_time_components(data: str, hora: str):
    """Normaliza data/hora e retorna tupla (data, hora) preservando valor original se inválido."""
    nd = normalize_date(data)
    nt = normalize_time(hora)
    out_data = nd if nd is not None else (data or "")
    out_hora = nt if nt is not None else (hora or "")
    return out_data, out_hora

def format_date_time(data: str, hora: str) -> str:
    d, h = normalize_date_time_components(data, hora)
    return f"{d} {h}".strip()

def normalize_datetime_column(series):
    """Normaliza colunas datetime/DATE em DataFrame para YYYY-MM-DD HH:MM."""
    try:
        import pandas as _pd
        ser = series.astype(str)
        dt = _pd.to_datetime(ser, errors="coerce", dayfirst=True)
        return dt.dt.strftime("%Y-%m-%d %H:%M").fillna("")
    except Exception:
        return series

def normalize_date_column(series):
    """Normaliza colunas de data em DataFrame para YYYY-MM-DD."""
    try:
        import pandas as _pd
        ser = series.astype(str)
        dt = _pd.to_datetime(ser, errors="coerce", dayfirst=True)
        return dt.dt.strftime("%Y-%m-%d").fillna("")
    except Exception:
        return series

def safe_int(v, default=0):
    try:
        if v is None:
            return default
        if isinstance(v, str):
            v = re.sub(r"[^\d\-]", "", v.strip())
        return int(float(v))
    except Exception:
        return default

def fmt_money(v):
    """Formata valor monetário"""
    return f"R$ {safe_float(v,0.0):,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

def require_pandas() -> bool:
    if pd is None:
        try:
            messagebox.showerror(
                "ERRO",
                "Esta funcionalidade requer o pacote 'pandas'.\n\n"
                "Instale com: pip install pandas"
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        return False
    return True

def require_openpyxl() -> bool:
    try:
        import openpyxl  # noqa: F401
        return True
    except Exception:
        try:
            messagebox.showerror(
                "ERRO",
                "ExportaÃƒÂ§ÃƒÂ£o Excel requer o pacote 'openpyxl'.\n\n"
                "Instale com: pip install openpyxl"
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        return False

def require_xlrd() -> bool:
    try:
        import xlrd  # noqa: F401
        return True
    except Exception:
        try:
            messagebox.showerror(
                "ERRO",
                "ImportaÃƒÂ§ÃƒÂ£o de .xls requer o pacote 'xlrd'.\n\n"
                "Instale com: pip install xlrd"
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        return False

def excel_engine_for(path: str):
    p = str(path or "").lower()
    if p.endswith(".xls") and not p.endswith(".xlsx"):
        return "xlrd"
    if p.endswith(".xlsx"):
        return "openpyxl"
    return None

def require_excel_support(path: str) -> bool:
    p = str(path or "").lower()
    if p.endswith(".xls") and not p.endswith(".xlsx"):
        return require_xlrd()
    if p.endswith(".xlsx"):
        return require_openpyxl()
    try:
        messagebox.showerror(
            "ERRO",
            "Formato de arquivo nÃ£o suportado.\n\n"
            "Use .xlsx ou .xls."
        )
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)
    return False

def require_reportlab() -> bool:
    if canvas is None or A4 is None:
        try:
            messagebox.showerror(
                "ERRO",
                "GeraÃƒÂ§ÃƒÂ£o de PDF requer o pacote 'reportlab'.\n\n"
                "Instale com: pip install reportlab"
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        return False
    return True

def now_str():
    """Retorna data/hora atual formatada"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def generate_program_code():
    """Gera um cÃ³digo curto para programaÃ§Ã£o (PG + YYYY + sequÃªncia hÃ¡ 2 dÃ­gitos)."""
    now = datetime.now()
    prefix = f"PG{now.strftime('%Y')}"
    suffix = 1

    try:
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute(
                "SELECT codigo_programacao FROM programacoes WHERE codigo_programacao LIKE ? ORDER BY codigo_programacao DESC LIMIT 1",
                (f"{prefix}%",),
            )
            row = cur.fetchone()
            if row:
                tail = (row[0] or "").strip()
                tail = tail[len(prefix) :]
                digits = "".join(ch for ch in tail if ch.isdigit())
                if digits:
                    suffix = int(digits) + 1
    except Exception:
        logging.debug("Falha ao calcular próximo código de programação", exc_info=True)

    return f"{prefix}{suffix:02d}"

def generate_motorista_code(motorista_id: int = None) -> str:
    """Gera um código simples e único pro motorista (ex.: MOT000123 / MOTAB12CD)."""
    base = "MOT"
    if motorista_id is not None:
        try:
            return f"{base}{int(motorista_id):06d}"
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
    suffix = "".join(random.choices(string.ascii_uppercase + string.digits, k=6))
    return f"{base}{suffix}"

def generate_usuario_code(usuario_id: int = None) -> str:
    """Gera um código simples e único pro usuário (ex.: USR000123 / USRAB12CD)."""
    base = "USR"
    if usuario_id is not None:
        try:
            return f"{base}{int(usuario_id):06d}"
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
    suffix = "".join(random.choices(string.ascii_uppercase + string.digits, k=6))
    return f"{base}{suffix}"

def generate_motorista_password(length: int = 6) -> str:
    """Senha numérica simples (pra bater com a API atual)."""
    try:
        length = int(length)
    except Exception:
        length = 6
    if length < 4:
        length = 4
    return "".join(random.choices("0123456789", k=length))

def generate_usuario_password(length: int = 6) -> str:
    """Senha numérica simples pro usuário."""
    return generate_motorista_password(length)

def guess_col(cols, candidates):
    """Tenta adivinhar o nome da coluna no Excel"""
    cols_lower = {str(c).strip().lower(): c for c in cols}
    for cand in candidates:
        cand_low = cand.strip().lower()
        for col_low, original in cols_lower.items():
            if cand_low in col_low:
                return original
    return None

def validate_required(value: str, field_name: str, min_len=1, max_len=120):
    v = (value or "").strip()
    if len(v) < min_len:
        return False, f"{field_name} é obrigatório."
    if len(v) > max_len:
        return False, f"{field_name} muito longo (máx {max_len})."
    return True, ""


def validate_codigo(value: str, field_name="Código", min_len=2, max_len=20):
    v = upper((value or "").strip())
    ok, msg = validate_required(v, field_name, min_len=min_len, max_len=max_len)
    if not ok:
        return False, msg
    if not re.match(r"^[A-Z0-9_-]+$", v):
        return False, f"{field_name} deve conter apenas A-Z, 0-9, '_' ou '-'."
    return True, ""


def validate_placa(value: str):
    v = upper((value or "").strip())
    ok, msg = validate_required(v, "Placa", min_len=6, max_len=8)
    if not ok:
        return False, msg
    if not re.match(r"^[A-Z0-9-]+$", v):
        return False, "Placa inválida."
    return True, ""


def validate_money(value: str, field_name="Valor"):
    v = (value or "").strip().replace(".", "").replace(",", ".")
    try:
        f = float(v)
        if f < 0:
            return False, f"{field_name} não pode ser negativo."
        return True, ""
    except Exception:
        return False, f"{field_name} inválido."


# =========================================================
# AUTENTICAÃƒâ€¡ÃƒÆ’O + ADMIN PADRÃƒÆ’O
# =========================================================

import os
import base64
import hashlib
import hmac

def hash_password_pbkdf2(password: str, *, iterations: int = 200_000) -> str:
    password = str(password or "")
    if password == "":
        raise ValueError("Senha vazia.")
    salt = os.urandom(16)
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations, dklen=32)
    return "pbkdf2_sha256${}${}${}".format(
        iterations,
        base64.b64encode(salt).decode("ascii"),
        base64.b64encode(dk).decode("ascii"),
    )

def verify_password_pbkdf2(password: str, stored: str) -> bool:
    try:
        password = str(password or "")
        stored = str(stored or "")

        if not stored.startswith("pbkdf2_sha256$"):
            return False

        _, iters_s, salt_b64, hash_b64 = stored.split("$", 3)
        iterations = int(iters_s)

        salt = base64.b64decode(salt_b64.encode("ascii"))
        expected = base64.b64decode(hash_b64.encode("ascii"))

        dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations, dklen=len(expected))
        return hmac.compare_digest(dk, expected)
    except Exception:
        return False


def autenticar_usuario(login: str, senha: str):
    """
    âœ… Login por NOME + SENHA
    ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ MigraÃƒÆ’Ã‚Â§ÃƒÆ’Ã‚Â£o automÃƒÆ’Ã‚Â¡tica:
       - Se senha no DB já for HASH: valida HASH
       - Se senha no DB for PURA: valida pura e, se OK, converte e salva HASH
    Retorna dict do usuário se ok, senão None.
    """
    login = (login or "").strip()
    senha = (senha or "").strip()
    if not login or not senha:
        return None

    with get_db() as conn:
        cur = conn.cursor()

        # Descobre colunas disponíveis
        cur.execute("PRAGMA table_info(usuarios)")
        cols = [str(r[1] or "").lower() for r in cur.fetchall()]

        has_permissoes = "permissoes" in cols
        has_cpf = "cpf" in cols
        has_telefone = "telefone" in cols
        has_senha = "senha" in cols

        if not has_senha:
            return None

        # Puxa o usuário pelo nome (case-insensitive)
        select_parts = ["id", "nome", "senha"]
        select_parts.append("permissoes" if has_permissoes else "'' as permissoes")
        select_parts.append("cpf" if has_cpf else "'' as cpf")
        select_parts.append("telefone" if has_telefone else "'' as telefone")

        cur.execute(f"""
            SELECT {", ".join(select_parts)}
            FROM usuarios
            WHERE UPPER(nome)=UPPER(?)
            LIMIT 1
        """, (login,))
        row = cur.fetchone()

        if not row:
            return None

        user_id = row[0]
        nome = row[1] or ""
        senha_db = row[2] or ""
        permissoes = row[3] if len(row) > 3 else ""
        cpf = row[4] if len(row) > 4 else ""
        telefone = row[5] if len(row) > 5 else ""

        # 1) Se já é hash, valida por hash
        if str(senha_db).startswith("pbkdf2_sha256$"):
            if not verify_password_pbkdf2(senha, senha_db):
                return None

        # 2) Senha pura: valida pura e MIGRA para hash automaticamente
        else:
            if str(senha_db) != senha:
                return None

            try:
                novo_hash = hash_password_pbkdf2(senha)
                cur.execute("UPDATE usuarios SET senha=? WHERE id=?", (novo_hash, user_id))
                # conn.commit() é automático no seu contexto get_db() se ele commita ao sair;
                # se não, descomente a linha abaixo:
                # conn.commit()
            except Exception as e:
                # Se falhar a migração, pelo menos deixa logar (já validou a senha pura)
                logging.exception("Falha ao migrar senha do usuario id=%s: %s", user_id, e)

    is_admin = ("ADMIN" in (permissoes or "").upper()) or (nome.strip().upper() == "ADMIN")

    return {
        "id": user_id,
        "nome": nome,
        "permissoes": permissoes,
        "cpf": cpf,
        "telefone": telefone,
        "is_admin": is_admin,
    }

def _notify_admin_seed(password: str):
    """Notifica senha temporária do ADMIN sem gravar em arquivo."""
    msg = (
        "ADMIN criado automaticamente.\n"
        f"Senha temporaria: {password}\n\n"
        "Troque a senha no primeiro acesso."
    )
    try:
        if tk._default_root is not None:
            messagebox.showwarning("ADMIN CRIADO", msg)
            return
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)
    print(msg)


def ensure_admin_user():
    """Garante que exista ADMIN (sem sobrescrever senha existente)."""
    with get_db() as conn:
        cur = conn.cursor()

        cur.execute("PRAGMA table_info(usuarios)")
        cols = [str(r[1] or "").lower() for r in cur.fetchall()]
        if "senha" not in cols:
            return

        has_permissoes = "permissoes" in cols

        cur.execute("SELECT id, senha FROM usuarios WHERE UPPER(nome)=?", ("ADMIN",))
        row = cur.fetchone()

        if not row:
            senha_plana = (
                os.environ.get("ROTA_ADMIN_PASS")
                or os.environ.get("ROTA_ADMIN_PASSWORD")
                or ""
            ).strip()
            if not senha_plana:
                senha_plana = secrets.token_urlsafe(8)
            senha_hash = hash_password_pbkdf2(senha_plana)

            if has_permissoes:
                cur.execute(
                    "INSERT INTO usuarios (nome, senha, permissoes) VALUES (?, ?, ?)",
                    ("ADMIN", senha_hash, "ADMIN")
                )
            else:
                cur.execute(
                    "INSERT INTO usuarios (nome, senha) VALUES (?, ?)",
                    ("ADMIN", senha_hash)
                )
            _notify_admin_seed(senha_plana)
        else:
            admin_id = row[0]
            senha_db = row[1] or ""
            # se admin ainda estiver com senha pura, converte para hash mantendo o mesmo valor
            if senha_db and not str(senha_db).startswith("pbkdf2_sha256$"):
                try:
                    novo_hash = hash_password_pbkdf2(str(senha_db))
                    if has_permissoes:
                        cur.execute(
                            "UPDATE usuarios SET senha=?, permissoes=? WHERE id=?",
                            (novo_hash, "ADMIN", admin_id)
                        )
                    else:
                        cur.execute("UPDATE usuarios SET senha=? WHERE id=?", (novo_hash, admin_id))
                except Exception as e:
                    logging.exception("Falha ao migrar senha do ADMIN id=%s: %s", admin_id, e)

# =========================================================
# MIGRAÃƒâ€¡ÃƒÆ’O DE BANCO DE DADOS
# =========================================================
def table_has_column(cur, table, col):
    """Verifica se coluna existe na tabela"""
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]
    return col in cols

def safe_add_column(cur, table, col, coltype):
    """Adiciona coluna apenas se não existir"""
    if not table_has_column(cur, table, col):
        cur.execute(f"ALTER TABLE {table} ADD COLUMN {col} {coltype}")

def db_init():
    """Inicializa/atualiza banco de dados com migrações"""
    with get_db() as conn:
        cur = conn.cursor()

        # MOTORISTAS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS motoristas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT,
                cpf TEXT,
                telefone TEXT
            )
        """)
        safe_add_column(cur, "motoristas", "codigo", "TEXT")
        safe_add_column(cur, "motoristas", "senha", "TEXT")

        # USURIOS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS usuarios (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT,
                permissoes TEXT,
                cpf TEXT,
                
                telefone TEXT
            )
        """)
        # ✅ ADICIONADO (pra login + gerar senha/codigo)
        safe_add_column(cur, "usuarios", "codigo", "TEXT")
        safe_add_column(cur, "usuarios", "senha", "TEXT")

        # VECULOS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS veiculos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                placa TEXT,
                modelo TEXT,
                
                capacidade_cx INTEGER
            )
        """)
        safe_add_column(cur, "veiculos", "capacidade_cx", "INTEGER")
        # Migração: se banco antigo usava capacidade_c, copiar para capacidade_cx
        try:
            if table_has_column(cur, "veiculos", "capacidade_c") and table_has_column(cur, "veiculos", "capacidade_cx"):
                cur.execute("""
                    UPDATE veiculos
                    SET capacidade_cx = CAST(capacidade_c AS INTEGER)
                    WHERE (capacidade_cx IS NULL OR capacidade_cx = '')
                      AND capacidade_c IS NOT NULL
                      AND capacidade_c <> ''
                """)
        except Exception as e:
            logging.exception("Falha ao migrar capacidade_c -> capacidade_cx: %s", e)

        # EQUIPES
        cur.execute("""
            CREATE TABLE IF NOT EXISTS equipes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo TEXT,
                ajudante1 TEXT,
                ajudante2 TEXT
            )
        """)

        
        # CLIENTES
        cur.execute("""
            CREATE TABLE IF NOT EXISTS clientes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cod_cliente TEXT UNIQUE,
                nome_cliente TEXT,
                endereco TEXT,
                bairro TEXT,
                cidade TEXT,
                uf TEXT,
                telefone TEXT,
                rota TEXT
            )
        """)
        safe_add_column(cur, "clientes", "cod_cliente", "TEXT")
        safe_add_column(cur, "clientes", "nome_cliente", "TEXT")
        safe_add_column(cur, "clientes", "endereco", "TEXT")
        safe_add_column(cur, "clientes", "bairro", "TEXT")
        safe_add_column(cur, "clientes", "cidade", "TEXT")
        safe_add_column(cur, "clientes", "uf", "TEXT")
        safe_add_column(cur, "clientes", "telefone", "TEXT")
        safe_add_column(cur, "clientes", "rota", "TEXT")
        safe_add_column(cur, "clientes", "vendedor", "TEXT")

        try:
            cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_clientes_cod ON clientes(cod_cliente)")
        except Exception as e:
            logging.exception("Falha ao criar indice de clientes (cod_cliente): %s", e)

        # VENDAS IMPORTADAS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS vendas_importadas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                pedido TEXT,
                data_venda TEXT,
                cliente TEXT,
                nome_cliente TEXT,
                vendedor TEXT,
                produto TEXT,
                vr_total REAL,
                qnt REAL,
                cidade TEXT,
                valor_unitario REAL,
                observacao TEXT,
                selecionada INTEGER DEFAULT 0
            )
        """)
        safe_add_column(cur, "vendas_importadas", "selecionada", "INTEGER DEFAULT 0")
        safe_add_column(cur, "vendas_importadas", "data_venda", "TEXT")
        safe_add_column(cur, "vendas_importadas", "vr_total", "REAL")
        safe_add_column(cur, "vendas_importadas", "qnt", "REAL")
        safe_add_column(cur, "vendas_importadas", "cidade", "TEXT")

        # PROGRAMAÃƒâ€¡Ãƒâ€¢ES
        cur.execute("""
            CREATE TABLE IF NOT EXISTS programacoes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                data_criacao TEXT,
                motorista TEXT,
                veiculo TEXT,
                equipe TEXT,
                kg_estimado REAL
            )
        """)
        safe_add_column(cur, "programacoes", "codigo_programacao", "TEXT")
        safe_add_column(cur, "programacoes", "data_criacao", "TEXT")
        safe_add_column(cur, "programacoes", "motorista", "TEXT")
        safe_add_column(cur, "programacoes", "veiculo", "TEXT")
        safe_add_column(cur, "programacoes", "equipe", "TEXT")
        safe_add_column(cur, "programacoes", "kg_estimado", "REAL")

        try:
            cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_programacoes_codigo ON programacoes(codigo_programacao)")
        except Exception as e:
            logging.exception("Falha ao criar indice de programacoes (codigo_programacao): %s", e)

        # NOVAS COLUNAS PARA STATUS E ROTAS ATIVAS
        safe_add_column(cur, "programacoes", "status", "TEXT DEFAULT 'ATIVA'")
        safe_add_column(cur, "programacoes", "prestacao_status", "TEXT DEFAULT 'PENDENTE'")
        safe_add_column(cur, "programacoes", "tipo_rota", "TEXT")
        safe_add_column(cur, "programacoes", "granja_carregada", "TEXT")
        safe_add_column(cur, "programacoes", "data_saida", "TEXT")
        safe_add_column(cur, "programacoes", "hora_saida", "TEXT")
        safe_add_column(cur, "programacoes", "data_chegada", "TEXT")
        safe_add_column(cur, "programacoes", "hora_chegada", "TEXT")
        safe_add_column(cur, "programacoes", "diaria_motorista_valor", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "adiantamento", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "num_nf", "TEXT")
        safe_add_column(cur, "programacoes", "kg_carregado", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "media", "REAL DEFAULT 0")

        # ✅ SUA TELA DESPESAS USA "adiantamento_rota" (ADICIONADO)
        safe_add_column(cur, "programacoes", "adiantamento_rota", "REAL DEFAULT 0")

        # NOVAS MIGRAÃƒâ€¡Ãƒâ€¢ES (NF / KM / CÃƒâ€°DULAS)
        safe_add_column(cur, "programacoes", "nf_numero", "TEXT")
        safe_add_column(cur, "programacoes", "nf_kg", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "nf_caixas", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "nf_kg_carregado", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "nf_kg_vendido", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "nf_saldo", "REAL DEFAULT 0")

        safe_add_column(cur, "programacoes", "km_inicial", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "km_final", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "litros", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "km_rodado", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "media_km_l", "REAL DEFAULT 0")
        safe_add_column(cur, "programacoes", "custo_km", "REAL DEFAULT 0")

        safe_add_column(cur, "programacoes", "ced_200_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_100_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_50_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_20_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_10_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_5_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "ced_2_qtd", "INTEGER DEFAULT 0")
        safe_add_column(cur, "programacoes", "valor_dinheiro", "REAL DEFAULT 0")

        # garante prestação pendente em bases antigas (não sobrescreve FECHADA)
        try:
            if table_has_column(cur, "programacoes", "prestacao_status"):
                cur.execute("""
                    UPDATE programacoes
                    SET prestacao_status='PENDENTE'
                    WHERE (prestacao_status IS NULL OR prestacao_status='')
                """)
        except Exception as e:
            logging.exception("Falha ao garantir prestacao_status pendente: %s", e)

        # ITENS DA PROGRAMAÃƒâ€¡ÃƒÆ’O
        cur.execute("""
            CREATE TABLE IF NOT EXISTS programacao_itens (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                cod_cliente TEXT,
                nome_cliente TEXT,
                qnt_caixas INTEGER,
                kg REAL,
                preco REAL,
                endereco TEXT,
                vendedor TEXT,
                pedido TEXT,
                produto TEXT
            )
        """)
        safe_add_column(cur, "programacao_itens", "endereco", "TEXT")
        safe_add_column(cur, "programacao_itens", "pedido", "TEXT")
        safe_add_column(cur, "programacao_itens", "vendedor", "TEXT")
        safe_add_column(cur, "programacao_itens", "produto", "TEXT")
        safe_add_column(cur, "programacao_itens", "status_pedido", "TEXT")
        safe_add_column(cur, "programacao_itens", "caixas_atual", "INTEGER")
        safe_add_column(cur, "programacao_itens", "preco_atual", "REAL")
        safe_add_column(cur, "programacao_itens", "alterado_em", "TEXT")
        safe_add_column(cur, "programacao_itens", "alterado_por", "TEXT")

        # CONTROLE/LOG (sincronização app)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS programacao_itens_controle (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                cod_cliente TEXT,
                status_pedido TEXT,
                caixas_atual INTEGER,
                preco_atual REAL,
                alterado_em TEXT,
                alterado_por TEXT,
                mortalidade_aves INTEGER DEFAULT 0,
                valor_recebido REAL DEFAULT 0,
                forma_recebimento TEXT,
                obs_recebimento TEXT
            )
        """)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS programacao_itens_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                cod_cliente TEXT,
                payload_json TEXT,
                registrado_em TEXT
            )
        """)

        # RECEBIMENTOS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS recebimentos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                cod_cliente TEXT,
                nome_cliente TEXT,
                valor REAL,
                forma_pagamento TEXT,
                observacao TEXT,
                num_nf TEXT,
                data_registro TEXT
            )
        """)

        # DESPESAS
        cur.execute("""
            CREATE TABLE IF NOT EXISTS despesas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo_programacao TEXT,
                descricao TEXT,
                valor REAL,
                data_registro TEXT
            )
        """)

        # MIGRAÃƒâ€¡Ãƒâ€¢ES PARA RELATÃƒâ€œRIOS
        safe_add_column(cur, "despesas", "tipo_despesa", "TEXT DEFAULT 'ROTA'")
        safe_add_column(cur, "despesas", "categoria", "TEXT")
        safe_add_column(cur, "despesas", "motorista", "TEXT")
        safe_add_column(cur, "despesas", "veiculo", "TEXT")
        safe_add_column(cur, "despesas", "observacao", "TEXT")  # ✅ sua tela usa isso

        # NDICES (performance)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_despesas_programacao ON despesas(codigo_programacao)")
        except Exception as e:
            logging.exception("Falha ao criar indice despesas(codigo_programacao): %s", e)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_receb_programacao ON recebimentos(codigo_programacao)")
        except Exception as e:
            logging.exception("Falha ao criar indice recebimentos(codigo_programacao): %s", e)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_receb_cliente ON recebimentos(cod_cliente)")
        except Exception as e:
            logging.exception("Falha ao criar indice recebimentos(cod_cliente): %s", e)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_prog_itens_programacao ON programacao_itens(codigo_programacao)")
        except Exception as e:
            logging.exception("Falha ao criar indice programacao_itens(codigo_programacao): %s", e)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_prog_itens_ctrl_prog_cliente ON programacao_itens_controle(codigo_programacao, cod_cliente)")
        except Exception as e:
            logging.exception("Falha ao criar indice programacao_itens_controle(codigo_programacao, cod_cliente): %s", e)
        try:
            cur.execute("CREATE INDEX IF NOT EXISTS idx_prog_itens_log_prog ON programacao_itens_log(codigo_programacao)")
        except Exception as e:
            logging.exception("Falha ao criar indice programacao_itens_log(codigo_programacao): %s", e)

    # ✅ garante ADMIN (senha segura e temporaria)
    ensure_admin_user()

# =========================================================
# ESTILOS DA INTERFACE (MODERNIZADO)
# =========================================================
def apply_style(root):
    """Aplica estilos Tkinter (tema moderno, sem afetar a lógica do sistema)"""
    style = ttk.Style(root)

    # Em alguns Windows, "clam" funciona melhor e é mais consistente
    try:
        style.theme_use("clam")
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)

    # Paleta moderna
    PRIMARY = "#2B2F8F"
    PRIMARY_DARK = "#1F246F"
    BG = "#F4F6FB"
    CARD = "#FFFFFF"
    TEXT = "#1F2937"
    MUTED = "#6B7280"
    BORDER = "#E5E7EB"
    DANGER = "#B42318"
    DANGER_HOVER = "#D92D20"
    WARN = "#F79009"
    WARN_HOVER = "#FDB022"
    GHOST = "#EEF2F7"
    GHOST_HOVER = "#E5EAF3"

    # Tabelas (Treeview): linhas/colunas mais visÃ­veis
    try:
        style.configure(
            "Treeview",
            rowheight=26,
            borderwidth=1,
            relief="solid",
            background=CARD,
            fieldbackground=CARD,
            foreground=TEXT
        )
        style.configure(
            "Treeview.Heading",
            borderwidth=1,
            relief="raised",
            background=BG,
            foreground=TEXT,
            font=("Segoe UI", 8, "bold")
        )
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)

    # Base
    style.configure(".", font=("Segoe UI", 10))
    style.configure("Sidebar.TFrame", background=PRIMARY)
    style.configure("Content.TFrame", background=BG)
    style.configure("Card.TFrame", background=CARD, relief="flat", borderwidth=0)

    # Labels
    style.configure("CardTitle.TLabel", background=CARD, foreground=TEXT, font=("Segoe UI", 15, "bold"))
    style.configure("CardLabel.TLabel", background=CARD, foreground=MUTED, font=("Segoe UI", 8, "bold"))
    style.configure("SidebarLogo.TLabel", background=PRIMARY, foreground="white", font=("Segoe UI", 16, "bold"))
    style.configure("SidebarSmall.TLabel", background=PRIMARY, foreground="#DDE3FF", font=("Segoe UI", 9))

    # Entradas
    style.configure("Field.TEntry", padding=(10, 8))
    style.map(
        "Field.TEntry",
        bordercolor=[("focus", PRIMARY), ("!focus", BORDER)],
        lightcolor=[("focus", PRIMARY), ("!focus", BORDER)],
        darkcolor=[("focus", PRIMARY), ("!focus", BORDER)],
    )

    # Botões (mantendo seus nomes de style)
    style.configure(
        "Side.TButton",
        background=PRIMARY,
        foreground="white",
        borderwidth=0,
        font=("Segoe UI", 10, "bold"),
        anchor="w",
        padding=(12, 10),
        focusthickness=0,
        focuscolor="none",
    )
    style.map("Side.TButton", background=[("active", PRIMARY_DARK)])

    style.configure(
        "SideActive.TButton",
        background=PRIMARY_DARK,
        foreground="white",
        borderwidth=0,
        font=("Segoe UI", 10, "bold"),
        anchor="w",
        padding=(12, 10),
        focusthickness=0,
        focuscolor="none",
    )

    style.configure(
        "SideSub.TButton",
        background=PRIMARY,
        foreground="#EEF2FF",
        borderwidth=0,
        font=("Segoe UI", 8, "bold"),
        anchor="w",
        padding=(12, 8),
        focusthickness=0,
        focuscolor="none",
    )
    style.map("SideSub.TButton", background=[("active", PRIMARY_DARK)])

    style.configure(
        "SideSubActive.TButton",
        background=PRIMARY_DARK,
        foreground="white",
        borderwidth=0,
        font=("Segoe UI", 8, "bold"),
        anchor="w",
        padding=(12, 8),
        focusthickness=0,
        focuscolor="none",
    )

    style.configure(
        "Primary.TButton",
        background=PRIMARY,
        foreground="white",
        font=("Segoe UI", 10, "bold"),
        padding=(14, 10),
        borderwidth=0,
        focusthickness=0,
        focuscolor="none",
    )
    style.map("Primary.TButton", background=[("active", PRIMARY_DARK)])

    style.configure(
        "Ghost.TButton",
        background=GHOST,
        foreground=TEXT,
        font=("Segoe UI", 10, "bold"),
        padding=(14, 10),
        borderwidth=0,
        focusthickness=0,
        focuscolor="none",
    )
    style.map("Ghost.TButton", background=[("active", GHOST_HOVER)])

    style.configure(
        "Warn.TButton",
        background=WARN,
        foreground="black",
        font=("Segoe UI", 10, "bold"),
        padding=(14, 10),
        borderwidth=0,
        focusthickness=0,
        focuscolor="none",
    )
    style.map("Warn.TButton", background=[("active", WARN_HOVER)])

    style.configure(
        "Danger.TButton",
        background=DANGER,
        foreground="white",
        font=("Segoe UI", 10, "bold"),
        padding=(14, 10),
        borderwidth=0,
        focusthickness=0,
        focuscolor="none",
    )
    style.map("Danger.TButton", background=[("active", DANGER_HOVER)])

    # Separators
    style.configure("TSeparator", background=BORDER)

    # Treeview modernizado
    style.configure(
        "Treeview",
        background="white",
        foreground=TEXT,
        fieldbackground="white",
        rowheight=28,
        bordercolor=BORDER,
        lightcolor=BORDER,
        darkcolor=BORDER,
        borderwidth=1,
        font=("Segoe UI", 9),
    )
    style.configure(
        "Treeview.Heading",
        background="#F3F4F6",
        foreground=TEXT,
        relief="flat",
        font=("Segoe UI", 8, "bold"),
        padding=(8, 6),
    )
    style.map("Treeview", background=[("selected", "#DDE7FF")], foreground=[("selected", TEXT)])


# =========================================================
# BASE PARA PÃƒÂGINAS (mesma lÃƒÂ³gica, sÃƒÂ³ ajuste visual/organizaÃƒÂ§ÃƒÂ£o)
# =========================================================
class PageBase(ttk.Frame):
    """Classe base para todas as páginas da aplicação"""
    def __init__(self, parent, app, title):
        super().__init__(parent, style="Content.TFrame")
        self.app = app

        # Estrutura
        self.grid_rowconfigure(2, weight=1)
        self.grid_columnconfigure(0, weight=1)

        header = ttk.Frame(self, style="Content.TFrame", padding=(18, 16))
        header.grid(row=0, column=0, sticky="ew")
        header.grid_columnconfigure(0, weight=1)

        ttk.Label(
            header,
            text=title,
            font=("Segoe UI", 18, "bold"),
            background="#F4F6FB",
            foreground="#111827"
        ).grid(row=0, column=0, sticky="w")

        self.lbl_status = ttk.Label(
            header,
            text="STATUS: Ã¢â‚¬â€",
            background="#F4F6FB",
            foreground="#6B7280",
            font=("Segoe UI", 8, "bold")
        )
        self.lbl_status.grid(row=1, column=0, sticky="w", pady=(6, 0))

        ttk.Separator(self).grid(row=1, column=0, sticky="ew")

        self.body = ttk.Frame(self, style="Content.TFrame", padding=(18, 14))
        self.body.grid(row=2, column=0, sticky="nsew")
        self.body.grid_columnconfigure(0, weight=1)
        self.body.grid_rowconfigure(1, weight=1)

        ttk.Separator(self).grid(row=3, column=0, sticky="ew")

        footer = ttk.Frame(self, style="Content.TFrame", padding=(18, 12))
        footer.grid(row=4, column=0, sticky="ew")
        footer.grid_columnconfigure(0, weight=1)

        self.footer_left = ttk.Frame(footer, style="Content.TFrame")
        self.footer_left.grid(row=0, column=0, sticky="w")

        self.footer_right = ttk.Frame(footer, style="Content.TFrame")
        self.footer_right.grid(row=0, column=1, sticky="e")

    def set_status(self, txt):
        """Atualiza texto de status na página"""
        self.lbl_status.config(text=txt)

    def on_show(self):
        """Método chamado quando a página é exibida (pode ser sobrescrito)"""
        pass


# =========================================================
# COMPONENTE CRUD GENÉRICO (mesma lógica, layout mais robusto)
# =========================================================
# ==========================
# ===== CADASTRO CRUD (ATUALIZADO) =====
# ==========================

class CadastroCRUD(ttk.Frame):
    """Componente CRUD reutilizável para cadastros (com validações por tabela)"""
    def __init__(self, parent, titulo, table, fields, app=None):
        super().__init__(parent, style="Content.TFrame")
        self.table = table
        self.fields = fields
        self.app = app
        self.selected_id = None
        self._is_admin = bool(getattr(self.app, "user", {}).get("is_admin")) if self.app else False

        # Card
        card = ttk.Frame(self, style="Card.TFrame", padding=16)
        card.pack(fill="both", expand=True)

        card.grid_columnconfigure(0, weight=1)
        card.grid_rowconfigure(6, weight=1)

        ttk.Label(card, text=titulo, style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")

        # FORM responsivo
        form = ttk.Frame(card, style="Card.TFrame")
        form.grid(row=1, column=0, sticky="ew", pady=(12, 10))
        form.grid_columnconfigure(0, weight=1)

        self.entries = {}

        max_cols = 4
        for idx, (col, label) in enumerate(fields):
            r = (idx // max_cols) * 2
            c = idx % max_cols

            form.grid_columnconfigure(c, weight=1, uniform="formcols")

            ttk.Label(form, text=label, style="CardLabel.TLabel").grid(
                row=r, column=c, sticky="w", padx=6, pady=(0, 4)
            )

            ent = ttk.Entry(form, style="Field.TEntry")
            ent.grid(row=r + 1, column=c, sticky="ew", padx=6, pady=(0, 10))
            self.entries[col] = ent

        # BOTÃ•ES
        actions = ttk.Frame(card, style="Card.TFrame")
        actions.grid(row=2, column=0, sticky="ew", pady=(4, 12))
        actions.grid_columnconfigure(20, weight=1)

        ttk.Button(actions, text="SALVAR", style="Primary.TButton", command=self.salvar).grid(row=0, column=0, padx=6)
        ttk.Button(actions, text="EXCLUIR", style="Danger.TButton", command=self.excluir).grid(row=0, column=1, padx=6)
        ttk.Button(actions, text="LIMPAR", style="Ghost.TButton", command=self.limpar).grid(row=0, column=2, padx=6)
        ttk.Button(actions, text="ATUALIZAR", style="Ghost.TButton", command=self.carregar).grid(row=0, column=3, padx=6)

        # Importar clientes (se você ainda usa esse CRUD para clientes em algum lugar)
        if self.table == "clientes":
            ttk.Button(
                actions,
                text="IMPORTAR CLIENTES (EXCEL)",
                style="Warn.TButton",
                command=self.importar_clientes_excel
            ).grid(row=0, column=4, padx=6)

        if self.table == "motoristas":
            self.btn_senha = ttk.Button(
                actions,
                text="ALTERAR SENHA",
                style="Warn.TButton",
                command=self.alterar_senha_motorista
            )
            self.btn_senha.grid(row=0, column=5, padx=6)

        if self.table == "usuarios":
            self.btn_senha = ttk.Button(
                actions,
                text="ALTERAR SENHA",
                style="Warn.TButton",
                command=self.alterar_senha
            )
            self.btn_senha.grid(row=0, column=5, padx=6)

        
        # Tabela
        cols = ["ID"] + [label for _, label in self.fields]
        self.tree = ttk.Treeview(card, columns=cols, show="headings", height=12)
        self.tree.grid(row=3, column=0, sticky="nsew", pady=(0, 6))
        card.grid_rowconfigure(3, weight=1)

        vsb = ttk.Scrollbar(card, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=3, column=1, sticky="ns", pady=(0, 6))

        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=160, anchor="w")
        self.tree.column("ID", width=70, anchor="center")

        enable_treeview_sorting(
            self.tree,
            numeric_cols={"ID"},
            money_cols=set(),
            date_cols=set()
        )

        self.tree.bind("<<TreeviewSelect>>", self._on_select)
        self.carregar()
        self._update_password_controls()

    # -------------------------
    # Helpers
    # -------------------------
    def _norm(self, v):
        return upper(str(v or "").strip())

    def _get(self, key):
        ent = self.entries.get(key)
        return ent.get().strip() if ent else ""

    def _set(self, key, value):
        ent = self.entries.get(key)
        if not ent:
            return
        ent.delete(0, "end")
        ent.insert(0, value)

    def _user_can_change_password(self, user_id):
        if not self.app:
            return False
        if self._is_admin:
            return True
        return str(user_id) == str(self.app.user.get("id"))

    def _update_password_controls(self):
        if self.table not in {"usuarios", "motoristas"}:
            return
        if self.table == "usuarios":
            can_change = self.selected_id and self._user_can_change_password(self.selected_id)
        else:
            can_change = bool(self.selected_id) and self._is_admin
        if hasattr(self, "btn_senha"):
            self.btn_senha.config(state="normal" if can_change else "disabled")
        senha_ent = self.entries.get("senha")
        if senha_ent:
            if self.table == "usuarios":
                if self._is_admin and not self.selected_id:
                    senha_ent.config(state="normal")
                else:
                    senha_ent.config(state="disabled")
            else:
                if self._is_admin and not self.selected_id:
                    senha_ent.config(state="normal")
                else:
                    senha_ent.config(state="disabled")

    def _require_fields(self, fields_required):
        for f in fields_required:
            if not str(self._get(f)).strip():
                return False, f
        return True, ""

    def _dup_exists(self, cur, colname, value_norm, ignore_id=None):
        """
        Verifica duplicidade case-insensitive:
        SELECT id FROM table WHERE UPPER(col)=UPPER(?) AND id<>?
        """
        if not value_norm:
            return False
        try:
            if ignore_id:
                cur.execute(
                    f"SELECT id FROM {self.table} WHERE UPPER({colname})=UPPER(?) AND id<>? LIMIT 1",
                    (value_norm, ignore_id)
                )
            else:
                cur.execute(
                    f"SELECT id FROM {self.table} WHERE UPPER({colname})=UPPER(?) LIMIT 1",
                    (value_norm,)
                )
            return cur.fetchone() is not None
        except Exception:
            # Se por algum motivo a coluna não existir no DB, não trava o sistema.
            return False

    def _dup_exists_exact(self, cur, colname, value, ignore_id=None):
        """
        Verifica duplicidade exata (útil para CPF/telefone quando você normaliza para dígitos).
        """
        if not value:
            return False
        try:
            if ignore_id:
                cur.execute(
                    f"SELECT id FROM {self.table} WHERE {colname}=? AND id<>? LIMIT 1",
                    (value, ignore_id)
                )
            else:
                cur.execute(
                    f"SELECT id FROM {self.table} WHERE {colname}=? LIMIT 1",
                    (value,)
                )
            return cur.fetchone() is not None
        except Exception:
            return False

    # -------------------------
    # AÃƒÂ§ÃƒÂµes padrÃƒÂ£o
    # -------------------------
    def limpar(self):
        self.selected_id = None
        for ent in self.entries.values():
            ent.delete(0, "end")
        self._update_password_controls()

    def carregar(self):
        with get_db() as conn:
            cur = conn.cursor()
            cols_db = ", ".join([c for c, _ in self.fields])
            cur.execute(f"SELECT id, {cols_db} FROM {self.table} ORDER BY id DESC")
            rows = cur.fetchall() or []

        self.tree.delete(*self.tree.get_children())
        senha_pos = None
        if self.table in {"usuarios", "motoristas"}:
            try:
                senha_pos = 1 + [c for c, _ in self.fields].index("senha")
            except Exception:
                senha_pos = None
        for row in rows:
            if senha_pos is not None:
                row = list(row)
                row[senha_pos] = "******" if row[senha_pos] else ""
                row = tuple(row)
            self.tree.insert("", "end", values=tuple(row))

    def salvar(self):
        """
        Salva/atualiza com validações por cadastro:
        - motoristas: valida NOME/CPF/TELEFONE; exige codigo e senha (manual); codigo único; CPF único (se houver coluna)
        - usuarios: exige nome, senha; nome único; sem codigo
        - veiculos: exige placa, modelo, capacidade_cx; placa única; capacidade int >= 0

        Obs: ID é a chave primária autogerada (sequência do SQLite). Você já vê o ID na tabela.
        """
        data = {col: self.entries[col].get().strip() for col, _ in self.fields}

        # Normalizações por tabela
        if self.table in {"motoristas", "usuarios", "veiculos", "equipes", "clientes"}:
            for k in list(data.keys()):
                data[k] = self._norm(data[k])

        # Validar obrigatórios + duplicidade + tipos
        try:
            with get_db() as conn:
                cur = conn.cursor()

                # -------------------------
                # MOTORISTAS
                # -------------------------
                if self.table == "motoristas":
                    # Exige NOME, CÓDIGO e SENHA (manuais) + TELEFONE
                    # CPF é opcional, porém deve ser válido e único quando informado.
                    ok, f = self._require_fields(["nome", "codigo", "senha", "telefone"])
                    if not ok:
                        messagebox.showwarning("ATENÇÃO", f"PREENCHA O CAMPO: {f.upper()}.")
                        return

                    # Nome (básico)
                    nome = self._norm(data.get("nome"))
                    if len(nome) < 3:
                        messagebox.showwarning("ATENÇÃO", "NOME deve ter pelo menos 3 caracteres.")
                        return
                    data["nome"] = nome

                    # Código (login flutter)  manual, mas pode usar GERAR
                    cod = self._norm(data.get("codigo"))
                    if not is_valid_motorista_codigo(cod):
                        messagebox.showwarning(
                            "ATENÇÃO",
                            "CÓDIGO inválido. Use apenas letras/números/._- e 3 a 24 caracteres."
                        )
                        return
                    if self._dup_exists(cur, "codigo", cod, ignore_id=self.selected_id):
                        messagebox.showerror("ERRO", f"J EXISTE MOTORISTA COM ESTE CÓDIGO: {cod}")
                        return
                    data["codigo"] = cod

                    # Senha (login flutter)  manual
                    senha = (self.entries.get("senha").get().strip() if self.entries.get("senha") else "").strip()
                    if self.selected_id:
                        if senha:
                            if not self._is_admin:
                                messagebox.showwarning("ATENÇÃO", "Somente ADMIN pode alterar senha do motorista.")
                                return
                            if not is_valid_motorista_senha(senha):
                                messagebox.showwarning(
                                    "ATENÇÃO",
                                    "SENHA inválida. Use 4 a 24 caracteres (não pode ser vazia)."
                                )
                                return
                            data["senha"] = hash_password_pbkdf2(senha)
                        else:
                            data.pop("senha", None)
                    else:
                        if not is_valid_motorista_senha(senha):
                            messagebox.showwarning(
                                "ATENÇÃO",
                                "SENHA inválida. Use 4 a 24 caracteres (não pode ser vazia)."
                            )
                            return
                        data["senha"] = hash_password_pbkdf2(senha)

                    # CPF (opcional)
                    cpf_raw = self.entries.get("cpf").get().strip() if self.entries.get("cpf") else ""
                    cpf = normalize_cpf(cpf_raw)
                    if cpf and not is_valid_cpf(cpf):
                        messagebox.showwarning("ATENÇÃO", "CPF inválido.")
                        return
                    data["cpf"] = cpf  # salva só dígitos

                    # Telefone
                    tel_raw = self.entries.get("telefone").get().strip() if self.entries.get("telefone") else ""
                    tel = normalize_phone(tel_raw)
                    if not is_valid_phone(tel):
                        messagebox.showwarning(
                            "ATENÇÃO",
                            "TELEFONE inválido. Informe DDD+Número (10 ou 11 dígitos)."
                        )
                        return
                    data["telefone"] = tel  # salva só dígitos

                    # CPF único quando informado (se a coluna existir)
                    if cpf and db_has_column(cur, "motoristas", "cpf"):
                        if self._dup_exists_exact(cur, "cpf", cpf, ignore_id=self.selected_id):
                            messagebox.showerror("ERRO", "J EXISTE MOTORISTA COM ESTE CPF.")
                            return

                # -------------------------
                # USURIOS (login por nome + senha)
                # -------------------------
                if self.table == "usuarios":
                    nome = self._norm(data.get("nome"))
                    senha_plana =""
                    try:
                        senha_plana = (self.entries.get("senha").get() or "").strip()
                    except Exception:
                        senha_plana = str(data.get("senha") or "").strip()

                    if not nome:
                        messagebox.showwarning("ANTENÇÃO", "PREENCHA O CAMPO: NOME.")
                        return
                    if self._dup_exists(cur, "nome", nome, ignore_id=self.selected_id):
                        messagebox.showerror("ERRO", f"J EXISTE USURIO COM ESTE NOME:{nome}")
                        return

                    data["nome"] = nome
                    if self.selected_id:
                        if senha_plana:
                            if not self._is_admin:
                                messagebox.showwarning("ATENÇÃO", "Somente ADMIN pode alterar senha aqui.")
                                return
                            if len(senha_plana) < 6:
                                messagebox.showwarning("ANTENÇÃO", "SENHA deve ter pelo menos 6 caracteres.")
                                return
                            data["senha"] = hash_password_pbkdf2(senha_plana)
                        else:
                            data.pop("senha", None)
                    else:
                        if not senha_plana:
                            messagebox.showwarning("ANTENÇÃO", "PREENCHA O CAMPO: SENHA.")
                            return
                        if len(senha_plana) < 6:
                            messagebox.showwarning("ANTENÇÃO", "SENHA deve ter pelo menos 6 caracteres.")
                            return
                        data["senha"] = hash_password_pbkdf2(senha_plana)

                # -------------------------
                # VECULOS (placa, modelo, capacidade_cx)
                # -------------------------
                if self.table == "veiculos":
                    ok, f = self._require_fields(["placa", "modelo", "capacidade_cx"])
                    if not ok:
                        messagebox.showwarning("ATENÇÃO", f"PREENCHA O CAMPO: {f.upper()}.")
                        return

                    placa = self._norm(data.get("placa"))
                    if self._dup_exists(cur, "placa", placa, ignore_id=self.selected_id):
                        messagebox.showerror("ERRO", f"J EXISTE VECULO COM ESTA PLACA: {placa}")
                        return

                    cap = safe_int(data.get("capacidade_cx"), -1)
                    if cap < 0:
                        messagebox.showwarning("ATENÇÃO", "CAPACIDADE (CX) deve ser um número inteiro >= 0.")
                        return
                    data["capacidade_cx"] = cap

                # -------------------------
                # SALVAR (UPDATE/INSERT)
                # -------------------------
                if self.selected_id:
                    sets = ", ".join([f"{c}=?" for c in data.keys()])
                    values = list(data.values()) + [self.selected_id]
                    cur.execute(f"UPDATE {self.table} SET {sets} WHERE id=?", values)
                else:
                    cols = ", ".join(data.keys())
                    qs = ", ".join(["?"] * len(data))
                    cur.execute(f"INSERT INTO {self.table} ({cols}) VALUES ({qs})", list(data.values()))

        except sqlite3.IntegrityError as e:
            messagebox.showerror("ERRO", f"REGISTRO DUPLICADO OU INVLIDO.\n\n{e}")
            return
        except Exception as e:
            messagebox.showerror("ERRO", str(e))
            return

        self.carregar()
        self.limpar()

        if self.app:
            self.app.refresh_programacao_comboboxes()

    def excluir(self):
        if not self.selected_id:
            messagebox.showwarning("ATENÇÃO", "SELECIONE UM ITEM NA TABELA ANTES DE EXCLUIR.")
            return

        if not messagebox.askyesno("CONFIRMAR", "DESEJA EXCLUIR ESTE REGISTRO?"):
            return

        with get_db() as conn:
            cur = conn.cursor()
            cur.execute(f"DELETE FROM {self.table} WHERE id=?", (self.selected_id,))

        self.carregar()
        self.limpar()

        if self.app:
            self.app.refresh_programacao_comboboxes()

    def _on_select(self, event=None):
        sel = self.tree.selection()
        if not sel:
            return
        row = self.tree.item(sel[0], "values")
        self.selected_id = row[0]
        for i, (col, _) in enumerate(self.fields, start=1):
            if self.table in {"usuarios", "motoristas"} and col == "senha":
                self.entries[col].delete(0, "end")
                continue
            self.entries[col].delete(0, "end")
            self.entries[col].insert(0, row[i])
        self._update_password_controls()

        # Mantive seu importar_clientes_excel como estava (se você ainda usa em algum ponto)
    def importar_clientes_excel(self):
        path = filedialog.askopenfilename(
            title="IMPORTAR CLIENTES (EXCEL)",
            filetypes=[("Excel", "*.xls *.xlsx")]
        )
        if not path:
            return

        if not (require_pandas() and require_excel_support(path)):
            return

        try:
            df = pd.read_excel(path, engine=excel_engine_for(path))

            col_cod = guess_col(df.columns, ["cod", "cód", "codigo", "cliente", "cod cliente"])
            col_nome = guess_col(df.columns, ["nome", "cliente"])
            col_end = guess_col(df.columns, ["endereco", "endereço", "rua", "logradouro"])
            col_bairro = guess_col(df.columns, ["bairro"])
            col_cidade = guess_col(df.columns, ["cidade"])
            col_uf = guess_col(df.columns, ["uf", "estado"])
            col_tel = guess_col(df.columns, ["telefone", "fone", "celular", "contato"])
            col_rota = guess_col(df.columns, ["rota"])

            if not col_cod or not col_nome:
                messagebox.showerror("ERRO", "NÃO IDENTIFIQUEI AS COLUNAS DE CÓDIGO E NOME DO CLIENTE NO EXCEL.")
                return

            total = 0
            with get_db() as conn:
                cur = conn.cursor()
                for _, r in df.iterrows():
                    cod = str(r.get(col_cod, "")).strip()
                    nome = str(r.get(col_nome, "")).strip()
                    if not cod or not nome:
                        continue

                    endereco = str(r.get(col_end, "")).strip() if col_end else ""
                    bairro = str(r.get(col_bairro, "")).strip() if col_bairro else ""
                    cidade = str(r.get(col_cidade, "")).strip() if col_cidade else ""
                    uf = str(r.get(col_uf, "")).strip() if col_uf else ""
                    telefone = str(r.get(col_tel, "")).strip() if col_tel else ""
                    rota = str(r.get(col_rota, "")).strip() if col_rota else ""

                    cur.execute("""
                        INSERT INTO clientes (cod_cliente, nome_cliente, endereco, bairro, cidade, uf, telefone, rota)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                        ON CONFLICT(cod_cliente) DO UPDATE SET
                            nome_cliente=excluded.nome_cliente,
                            endereco=excluded.endereco,
                            bairro=excluded.bairro,
                            cidade=excluded.cidade,
                            uf=excluded.uf,
                            telefone=excluded.telefone,
                            rota=excluded.rota
                    """, (
                        upper(cod),
                        upper(nome),
                        upper(endereco),
                        upper(bairro),
                        upper(cidade),
                        upper(uf),
                        upper(telefone),
                        upper(rota)
                    ))
                    total += 1

            self.carregar()
            messagebox.showinfo("OK", f"CLIENTES IMPORTADOS/ATUALIZADOS: {total}")

        except Exception as e:
            messagebox.showerror("ERRO", str(e))

    def alterar_senha(self):
        if self.table != "usuarios":
            return
        if not self.selected_id:
            messagebox.showwarning("ATENÇÃO", "SELECIONE UM USURIO NA TABELA.")
            return
        if not self._user_can_change_password(self.selected_id):
            messagebox.showwarning("ATENÇÃO", "Você não tem permissão para alterar esta senha.")
            return

        require_current = not self._is_admin

        win = tk.Toplevel(self)
        win.title("Alterar Senha")
        win.resizable(False, False)
        win.transient(self.winfo_toplevel())
        win.grab_set()

        frm = ttk.Frame(win, padding=12)
        frm.grid(row=0, column=0, sticky="nsew")

        row = 0
        ent_atual = None
        if require_current:
            ttk.Label(frm, text="Senha atual:").grid(row=row, column=0, sticky="w", pady=2)
            ent_atual = ttk.Entry(frm, show="*")
            ent_atual.grid(row=row, column=1, sticky="ew", pady=2)
            row += 1

        ttk.Label(frm, text="Nova senha:").grid(row=row, column=0, sticky="w", pady=2)
        ent_nova = ttk.Entry(frm, show="*")
        ent_nova.grid(row=row, column=1, sticky="ew", pady=2)
        row += 1

        ttk.Label(frm, text="Confirmar:").grid(row=row, column=0, sticky="w", pady=2)
        ent_conf = ttk.Entry(frm, show="*")
        ent_conf.grid(row=row, column=1, sticky="ew", pady=2)
        row += 1

        frm.grid_columnconfigure(1, weight=1)

        def _salvar():
            senha_atual = ent_atual.get().strip() if ent_atual else ""
            senha_nova = ent_nova.get().strip()
            senha_conf = ent_conf.get().strip()

            if not senha_nova:
                messagebox.showwarning("ATENÇÃO", "Informe a nova senha.")
                return
            if len(senha_nova) < 6:
                messagebox.showwarning("ATENÇÃO", "A nova senha deve ter pelo menos 6 caracteres.")
                return
            if senha_nova != senha_conf:
                messagebox.showwarning("ATENÃ‡ÃƒO", "ConfirmaÃ§Ã£o nÃ£o confere.")
                return

            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("SELECT senha FROM usuarios WHERE id=?", (self.selected_id,))
                row_db = cur.fetchone()
                if not row_db:
                    messagebox.showerror("ERRO", "Usuário não encontrado.")
                    return
                senha_db = row_db[0] or ""

                if require_current:
                    ok = False
                    if str(senha_db).startswith("pbkdf2_sha256$"):
                        ok = verify_password_pbkdf2(senha_atual, senha_db)
                    else:
                        ok = (senha_db == senha_atual)
                    if not ok:
                        messagebox.showwarning("ATENÇÃO", "Senha atual inválida.")
                        return

                nova_hash = hash_password_pbkdf2(senha_nova)
                cur.execute("UPDATE usuarios SET senha=? WHERE id=?", (nova_hash, self.selected_id))

            messagebox.showinfo("OK", "Senha atualizada com sucesso.")
            try:
                win.destroy()
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)
            self.carregar()
            self.limpar()

        btns = ttk.Frame(frm)
        btns.grid(row=row, column=0, columnspan=2, sticky="e", pady=(8, 0))
        ttk.Button(btns, text="SALVAR", style="Primary.TButton", command=_salvar).grid(row=0, column=0, padx=6)
        ttk.Button(btns, text="CANCELAR", style="Ghost.TButton", command=win.destroy).grid(row=0, column=1, padx=6)

    def alterar_senha_motorista(self):
        if self.table != "motoristas":
            return
        if not self.selected_id:
            messagebox.showwarning("ATENÇÃO", "SELECIONE UM MOTORISTA NA TABELA.")
            return
        if not self._is_admin:
            messagebox.showwarning("ATENÇÃO", "Somente ADMIN pode alterar senha do motorista.")
            return

        win = tk.Toplevel(self)
        win.title("Alterar Senha do Motorista")
        win.resizable(False, False)
        win.transient(self.winfo_toplevel())
        win.grab_set()

        frm = ttk.Frame(win, padding=12)
        frm.grid(row=0, column=0, sticky="nsew")

        ttk.Label(frm, text="Nova senha:").grid(row=0, column=0, sticky="w", pady=2)
        ent_nova = ttk.Entry(frm, show="*")
        ent_nova.grid(row=0, column=1, sticky="ew", pady=2)

        ttk.Label(frm, text="Confirmar:").grid(row=1, column=0, sticky="w", pady=2)
        ent_conf = ttk.Entry(frm, show="*")
        ent_conf.grid(row=1, column=1, sticky="ew", pady=2)

        frm.grid_columnconfigure(1, weight=1)

        def _salvar():
            senha_nova = ent_nova.get().strip()
            senha_conf = ent_conf.get().strip()
            if not senha_nova:
                messagebox.showwarning("ATENÇÃO", "Informe a nova senha.")
                return
            if not is_valid_motorista_senha(senha_nova):
                messagebox.showwarning(
                    "ATENÃƒâ€¡ÃƒÆ’O",
                    "SENHA inválida. Use 4 a 24 caracteres (não pode ser vazia)."
                )
                return
            if senha_nova != senha_conf:
                messagebox.showwarning("ATENÃ‡ÃƒO", "ConfirmaÃ§Ã£o nÃ£o confere.")
                return

            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("UPDATE motoristas SET senha=? WHERE id=?", (self._norm(senha_nova), self.selected_id))

            messagebox.showinfo("OK", "Senha do motorista atualizada com sucesso.")
            try:
                win.destroy()
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)
            self.carregar()
            self.limpar()

        btns = ttk.Frame(frm)
        btns.grid(row=2, column=0, columnspan=2, sticky="e", pady=(8, 0))
        ttk.Button(btns, text="SALVAR", style="Primary.TButton", command=_salvar).grid(row=0, column=0, padx=6)
        ttk.Button(btns, text="CANCELAR", style="Ghost.TButton", command=win.destroy).grid(row=0, column=1, padx=6)


# ==========================
# ===== CADASTROS PAGE (ATUALIZADA) =====
# ==========================

class CadastrosPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Cadastros")

        card = ttk.Frame(self.body, style="Card.TFrame", padding=12)
        card.grid(row=0, column=0, sticky="nsew")
        card.grid_columnconfigure(0, weight=1)
        card.grid_rowconfigure(0, weight=1)

        nb = ttk.Notebook(card)
        nb.grid(row=0, column=0, sticky="nsew")

        # -------------------------
        # MOTORISTAS
        # - ID é gerado pelo SQLite (sequência/autoincrement)
        # - valida CPF/NOME/TELEFONE
        # - código e senha são MANUAIS (botão GERAR é opcional)
        # -------------------------
        frm_motoristas = ttk.Frame(nb, style="Content.TFrame")
        crud_motoristas = CadastroCRUD(
            frm_motoristas,
            "Motoristas",
            "motoristas",
            [
                ("nome", "NOME"),
                ("codigo", "CÓDIGO"),
                ("senha", "SENHA"),
                ("cpf", "CPF"),
                ("telefone", "TELEFONE"),
            ],
            app=app
        )
        crud_motoristas.pack(fill="both", expand=True)
        nb.add(frm_motoristas, text="Motoristas")

        # -------------------------
        # USURIOS (login por nome + senha, sem idade e sem código)
        # -------------------------
        frm_usuarios = ttk.Frame(nb, style="Content.TFrame")
        crud_usuarios = CadastroCRUD(
            frm_usuarios,
            "Usuários",
            "usuarios",
            [
                ("nome", "NOME"),
                ("senha", "SENHA"),
                ("permissoes", "PERMISSÕES"),
                ("cpf", "CPF"),
                ("telefone", "TELEFONE"),
            ],
            app=app
        )
        crud_usuarios.pack(fill="both", expand=True)
        nb.add(frm_usuarios, text="Usuários")

        # -------------------------
        # VECULOS (placa, modelo, capacidade_cx)
        # -------------------------
        frm_veiculos = ttk.Frame(nb, style="Content.TFrame")
        crud_veiculos = CadastroCRUD(
            frm_veiculos,
            "Veículos",
            "veiculos",
            [
                ("placa", "PLACA"),
                ("modelo", "MODELO"),
                ("capacidade_cx", "CAPACIDADE (CX)"),
            ],
            app=app
        )
        crud_veiculos.pack(fill="both", expand=True)
        nb.add(frm_veiculos, text="Veículos")

        # -------------------------
        # EQUIPES (mantém)
        # -------------------------
        frm_equipes = ttk.Frame(nb, style="Content.TFrame")
        crud_equipes = CadastroCRUD(
            frm_equipes,
            "Equipes",
            "equipes",
            [
                ("codigo", "CÓDIGO"),
                ("ajudante1", "AJUDANTE 1"),
                ("ajudante2", "AJUDANTE 2"),
            ],
            app=app
        )
        crud_equipes.pack(fill="both", expand=True)
        nb.add(frm_equipes, text="Equipes")

        # -------------------------
        # CLIENTES (mantém sua ClientesImportPage)
        # -------------------------
        frm_clientes = ttk.Frame(nb, style="Content.TFrame")
        clientes_page = ClientesImportPage(frm_clientes, app=app)
        clientes_page.pack(fill="both", expand=True)
        nb.add(frm_clientes, text="Clientes")

    def on_show(self):
        self.set_status("STATUS: Cadastros (CRUD).")

# ==========================
# ===== FIM DA PARTE 1 =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 2 (ATUALIZADA) =====
# ==========================

class Sidebar(ttk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, style="Sidebar.TFrame", width=260)
        self.app = app
        self.pack_propagate(False)

        self.buttons = {}

        # Topo
        top = ttk.Frame(self, style="Sidebar.TFrame", padding=(14, 16))
        top.pack(fill="x")

        ttk.Label(top, text="ROTAHUB DESKTOP", style="SidebarLogo.TLabel").pack(anchor="w")
        ttk.Label(top, text="Centralizando sua operacao do inicio ao fim.", style="SidebarSmall.TLabel").pack(anchor="w", pady=(2, 0))

        ttk.Separator(self).pack(fill="x", padx=10, pady=(6, 10))

        # ✅ Menu com scroll (evita quebra/sumir item em telas pequenas)
        wrap = ttk.Frame(self, style="Sidebar.TFrame")
        wrap.pack(fill="both", expand=True)

        self.canvas = tk.Canvas(wrap, highlightthickness=0, bd=0, bg="#2B2F8F")
        self.canvas.pack(side="left", fill="both", expand=True)

        vsb = ttk.Scrollbar(wrap, orient="vertical", command=self.canvas.yview)
        vsb.pack(side="right", fill="y")
        self.canvas.configure(yscrollcommand=vsb.set)

        self.menu = ttk.Frame(self.canvas, style="Sidebar.TFrame", padding=(10, 6))
        self.menu_id = self.canvas.create_window((0, 0), window=self.menu, anchor="nw")

        def _on_frame_configure(event=None):
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))

        def _on_canvas_configure(event):
            self.canvas.itemconfig(self.menu_id, width=event.width)

        self.menu.bind("<Configure>", _on_frame_configure)
        self.canvas.bind("<Configure>", _on_canvas_configure)

        # Itens do menu
        self._add_btn("home", "Home", lambda: app.show_page("Home"))
        self._add_btn("cadastros", "Cadastros", lambda: app.show_page("Cadastros"))
        self._add_btn("rotas", "Rotas", lambda: app.show_page("Rotas"))
        self._add_btn("vendas", "Importar Vendas", lambda: app.show_page("ImportarVendas"))
        self._add_btn("programacao", "Programacao", lambda: app.show_page("Programacao"))
        self._add_btn("recebimentos", "Recebimentos", lambda: app.show_page("Recebimentos"))
        self._add_btn("despesas", "Despesas", lambda: app.show_page("Despesas"))
        self._add_btn("relatorios", "Relatorios", lambda: app.show_page("Relatorios"))
        self._add_btn("backup", "Backup / Exportar", lambda: app.show_page("BackupExportar"))

        # Rodapé
        bottom = ttk.Frame(self, style="Sidebar.TFrame", padding=(10, 12))
        bottom.pack(fill="x")

        ttk.Button(bottom, text="SAIR", style="Danger.TButton", command=self._safe_quit).pack(fill="x")

    def _safe_quit(self):
        """Evita travas se houver janelas abertas/toplevels"""
        try:
            self.app.quit()
        except Exception:
            try:
                self.app.destroy()
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

    def _add_btn(self, key, text, cmd):
        """Adiciona botão ao menu lateral"""
        b = ttk.Button(self.menu, text=text, style="Side.TButton", command=cmd)
        b.pack(fill="x", pady=2)
        self.buttons[key] = b

    def set_active(self, page_key):
        """Destaca botão ativo"""
        for k, b in self.buttons.items():
            b.config(style="SideActive.TButton" if k == page_key else "Side.TButton")


class App(tk.Tk):
    def __init__(self, user=None):
        super().__init__()

        # âœ… SeguranÃ§a bÃ¡sica: sempre garante chaves esperadas
        base_user = {"nome": "ADMIN", "is_admin": True}
        if isinstance(user, dict):
            base_user.update(user)
        self.user = base_user

        self.title("ROTA GRANJA - Sistema")
        self.geometry(f"{APP_W}x{APP_H}")
        self.minsize(1200, 700)

        try:
            self.state("zoomed")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        apply_style(self)
        db_init()

        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        self.sidebar = Sidebar(self, self)
        self.sidebar.grid(row=0, column=0, sticky="ns")

        self.container = ttk.Frame(self, style="Content.TFrame")
        self.container.grid(row=0, column=1, sticky="nsew")
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)

        self.pages = {}
        self._build_pages()

        self.show_page("Home")

    def _build_pages(self):
        """ConstrÃ³i todas as pÃ¡ginas da aplicaÃ§Ã£o"""
        self.pages["Home"] = HomePage(self.container, self)
        self.pages["Cadastros"] = CadastrosPage(self.container, self)
        self.pages["Rotas"] = RotasPage(self.container, self)
        self.pages["ImportarVendas"] = ImportarVendasPage(self.container, self)
        self.pages["Programacao"] = ProgramacaoPage(self.container, self)
        self.pages["Recebimentos"] = RecebimentosPage(self.container, self)
        self.pages["Despesas"] = DespesasPage(self.container, self)
        self.pages["Relatorios"] = RelatoriosPage(self.container, self)
        self.pages["BackupExportar"] = BackupExportarPage(self.container, self)

        for p in self.pages.values():
            p.grid(row=0, column=0, sticky="nsew")

    def show_page(self, name):
        """Exibe página e atualiza menu lateral"""
        mapping = {
            "Home": "home",
            "Cadastros": "cadastros",
            "Rotas": "rotas",
            "ImportarVendas": "vendas",
            "Programacao": "programacao",
            "Recebimentos": "recebimentos",
            "Despesas": "despesas",
            "Relatorios": "relatorios",
            "BackupExportar": "backup",
        }

        if name in mapping:
            self.sidebar.set_active(mapping[name])

        page = self.pages.get(name)
        if not page:
            messagebox.showwarning("ATENÇÃO", f"Página '{name}' não encontrada.")
            return

        page.tkraise()
        try:
            page.on_show()
        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao abrir página '{name}':\n\n{e}")

    def refresh_programacao_comboboxes(self):
        """Atualiza comboboxes em páginas relevantes"""
        for nm in ["Programacao", "Despesas", "Relatorios", "Recebimentos", "Home"]:
            p = self.pages.get(nm)
            if p and hasattr(p, "refresh_comboboxes"):
                try:
                    p.refresh_comboboxes()
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

            if nm == "Home" and p and hasattr(p, "on_show"):
                try:
                    p.on_show()
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)


class HomePage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Home")

        card = ttk.Frame(self.body, style="Card.TFrame", padding=18)
        card.grid(row=0, column=0, sticky="ew")
        card.grid_columnconfigure(0, weight=1)
        card.grid_columnconfigure(1, weight=0)

        ttk.Label(card, text="Bem-vindo!", style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")

        self.lbl_clock = ttk.Label(
            card,
            text="--/--/---- --:--:--",
            background="white",
            foreground="#111827",
            font=("Segoe UI", 11, "bold")
        )
        self.lbl_clock.grid(row=0, column=1, sticky="e")

        ttk.Label(
            card,
            text=(
                "• Cadastre Motoristas, Veículos, Equipes e Clientes.\n"
                "• Importe Vendas via Excel.\n"
                "â€¢ Gere ProgramaÃ§Ãµes (cÃ³digos automÃ¡ticos) e vincule pedidos/entregas.\n"
                "• Registre Recebimentos e Despesas.\n"
                "• Emita Relatórios e PDF.\n"
            ),
            style="CardLabel.TLabel",
            justify="left"
        ).grid(row=1, column=0, sticky="w", pady=(6, 0), columnspan=2)

        self.card_stats = ttk.Frame(self.body, style="Content.TFrame")
        self.card_stats.grid(row=1, column=0, sticky="nsew", pady=(14, 0))
        self.card_stats.grid_columnconfigure((0, 1, 2), weight=1)

        self.lbl_total_prog = self._build_stat(self.card_stats, 0, "Programações Ativas", "")
        self.lbl_total_vendas = self._build_stat(self.card_stats, 1, "Vendas Importadas", "")
        self.lbl_total_clientes_ativos = self._build_stat(self.card_stats, 2, "Clientes (Ativos)", "")

        dash = ttk.Frame(self.body, style="Content.TFrame")
        dash.grid(row=2, column=0, sticky="nsew", pady=(14, 0))
        dash.grid_columnconfigure(0, weight=1)
        dash.grid_rowconfigure(0, weight=1)

        card_rotas = ttk.Frame(dash, style="Card.TFrame", padding=12)
        card_rotas.grid(row=0, column=0, sticky="nsew")
        card_rotas.grid_rowconfigure(1, weight=1)
        card_rotas.grid_columnconfigure(0, weight=1)

        ttk.Label(card_rotas, text="Rotas Ativas", style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")

        cols = ["COD", "MOTORISTA", "VECULO", "DATA"]
        self.tree_rotas = ttk.Treeview(card_rotas, columns=cols, show="headings", height=10)
        self.tree_rotas.grid(row=1, column=0, sticky="nsew", pady=(6, 0))

        vsb = ttk.Scrollbar(card_rotas, orient="vertical", command=self.tree_rotas.yview)
        self.tree_rotas.configure(yscrollcommand=vsb.set)
        vsb.grid(row=1, column=1, sticky="ns", pady=(6, 0))

        for c in cols:
            self.tree_rotas.heading(c, text=c)
            self.tree_rotas.column(c, width=160, anchor="w")

        self.tree_rotas.column("COD", width=170)
        self.tree_rotas.column("DATA", width=160, anchor="center")

        self.tree_rotas.bind("<Double-1>", self._open_rota_preview)

        enable_treeview_sorting(
            self.tree_rotas,
            numeric_cols=set(),
            money_cols=set(),
            date_cols={"DATA"}
        )

        self._clock_job = None
        self._update_clock()

    def _build_stat(self, parent, col, title, value):
        c = ttk.Frame(parent, style="Card.TFrame", padding=16)
        c.grid(row=0, column=col, sticky="ew", padx=6)
        ttk.Label(c, text=title, style="CardLabel.TLabel").pack(anchor="w")
        lbl = ttk.Label(c, text=value, font=("Segoe UI", 24, "bold"), background="white")
        lbl.pack(anchor="w", pady=(6, 0))
        return lbl

    def _update_clock(self):
        now = datetime.now().strftime("%d/%m/%Y  %H:%M:%S")
        self.lbl_clock.config(text=now)

        if self._clock_job:
            try:
                self.after_cancel(self._clock_job)
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        self._clock_job = self.after(1000, self._update_clock)

    def on_show(self):
        total_prog = 0
        total_vendas = 0
        total_clientes_ativos = 0
        rows = []

        with get_db() as conn:
            cur = conn.cursor()

            try:
                cur.execute("SELECT COUNT(*) FROM programacoes WHERE status='ATIVA'")
                r = cur.fetchone()
                total_prog = (r[0] if r else 0) or 0
            except Exception:
                try:
                    cur.execute("SELECT COUNT(*) FROM programacoes")
                    r = cur.fetchone()
                    total_prog = (r[0] if r else 0) or 0
                except Exception:
                    total_prog = 0

            try:
                cur.execute("SELECT COUNT(*) FROM vendas_importadas")
                r = cur.fetchone()
                total_vendas = (r[0] if r else 0) or 0
            except Exception:
                total_vendas = 0

            try:
                cur.execute("""
                    SELECT COUNT(DISTINCT cod_cliente)
                    FROM programacao_itens
                    WHERE codigo_programacao IN (
                        SELECT codigo_programacao
                        FROM programacoes
                        WHERE status='ATIVA'
                    )
                """)
                r = cur.fetchone()
                total_clientes_ativos = (r[0] if r else 0) or 0
            except Exception:
                total_clientes_ativos = 0

            for i in self.tree_rotas.get_children():
                self.tree_rotas.delete(i)

            try:
                cur.execute("""
                    SELECT codigo_programacao, motorista, veiculo, data_criacao
                    FROM programacoes
                    WHERE status='ATIVA'
                    ORDER BY id DESC
                    LIMIT 80
                """)
                rows = cur.fetchall() or []
            except Exception:
                try:
                    cur.execute("""
                        SELECT codigo_programacao, motorista, veiculo, data_criacao
                        FROM programacoes
                        ORDER BY id DESC
                        LIMIT 80
                    """)
                    rows = cur.fetchall() or []
                except Exception:
                    rows = []

            for r in rows:
                self.tree_rotas.insert("", "end", values=(r[0], r[1], r[2], r[3]))

        self.lbl_total_prog.config(text=str(total_prog))
        self.lbl_total_vendas.config(text=str(total_vendas))
        self.lbl_total_clientes_ativos.config(text=str(total_clientes_ativos))

        nome = self.app.user.get("nome", "")
        is_admin = bool(self.app.user.get("is_admin", False))
        self.set_status(f"STATUS: Logado como {nome} (ADMIN: {is_admin}).")

    # =========================================================
    # PREVIEW ROTA Ã¢â‚¬â€ PUXA DADOS REAIS DA PROGRAMAÃƒâ€¡ÃƒÆ’O ATIVA
    # =========================================================
    def _open_rota_preview(self, event=None):
        sel = self.tree_rotas.selection()
        if not sel:
            return

        vals = self.tree_rotas.item(sel[0], "values")
        if not vals:
            return

        codigo = upper(vals[0])

        win = tk.Toplevel(self)
        win.title(f"PrÃƒÂ©-visualizaÃƒÂ§ÃƒÂ£o Ã¢â‚¬â€ {codigo}")
        win.geometry("1050x600")
        win.grab_set()
        win.resizable(True, True)

        frm = ttk.Frame(win, padding=14)
        frm.pack(fill="both", expand=True)
        frm.grid_columnconfigure(0, weight=1)
        frm.grid_rowconfigure(2, weight=1)

        lbl_title = ttk.Label(frm, text=f"ROTA ATIVA: {codigo}", font=("Segoe UI", 18, "bold"))
        lbl_title.grid(row=0, column=0, sticky="w", pady=(0, 6))

        header = ttk.Frame(frm, padding=12)
        header.grid(row=1, column=0, sticky="ew", pady=(8, 10))
        header.grid_columnconfigure((0, 1, 2, 3), weight=1)
        try:
            header.configure(style="Card.TFrame")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        lbl_status = ttk.Label(header, text="Status: ", font=("Segoe UI", 10, "bold"))
        lbl_motorista = ttk.Label(header, text="Motorista: ", font=("Segoe UI", 10))
        lbl_equipe = ttk.Label(header, text="Equipe: ", font=("Segoe UI", 10))
        lbl_nf = ttk.Label(header, text="NF: ", font=("Segoe UI", 10))

        lbl_adiant = ttk.Label(header, text="Adiantamento: R$ 0,00", font=("Segoe UI", 10))
        lbl_local_rota = ttk.Label(header, text="Local da Rota: ", font=("Segoe UI", 10))
        lbl_saida = ttk.Label(header, text="SaÃƒÂ­da: Ã¢â‚¬â€ Ã¢â‚¬â€", font=("Segoe UI", 10))
        lbl_local_carreg = ttk.Label(header, text="Carregou em: ", font=("Segoe UI", 10))

        lbl_kg_carregado = ttk.Label(header, text="KG Carregado: 0,00", font=("Segoe UI", 10))
        lbl_caixas_carreg = ttk.Label(header, text="Caixas Carregadas: 0", font=("Segoe UI", 10))
        lbl_caixas_entreg = ttk.Label(header, text="Caixas Entregues: 0", font=("Segoe UI", 10))
        lbl_saldo = ttk.Label(header, text="Saldo (NF - Granja): 0,00", font=("Segoe UI", 10, "bold"))
        lbl_km = ttk.Label(header, text="KM: ", font=("Segoe UI", 10))

        lbl_status.grid(row=0, column=0, sticky="w", padx=6, pady=2)
        lbl_motorista.grid(row=0, column=1, sticky="w", padx=6, pady=2)
        lbl_equipe.grid(row=0, column=2, sticky="w", padx=6, pady=2)
        lbl_nf.grid(row=0, column=3, sticky="w", padx=6, pady=2)

        lbl_adiant.grid(row=1, column=0, sticky="w", padx=6, pady=2)
        lbl_local_rota.grid(row=1, column=1, sticky="w", padx=6, pady=2)
        lbl_saida.grid(row=1, column=2, sticky="w", padx=6, pady=2)
        lbl_local_carreg.grid(row=1, column=3, sticky="w", padx=6, pady=2)

        lbl_kg_carregado.grid(row=2, column=0, sticky="w", padx=6, pady=2)
        lbl_caixas_carreg.grid(row=2, column=1, sticky="w", padx=6, pady=2)
        lbl_caixas_entreg.grid(row=2, column=2, sticky="w", padx=6, pady=2)
        lbl_saldo.grid(row=2, column=3, sticky="w", padx=6, pady=2)
        lbl_km.grid(row=3, column=0, sticky="w", padx=6, pady=2)

        table_wrap = ttk.Frame(frm)
        table_wrap.grid(row=2, column=0, sticky="nsew")
        table_wrap.grid_columnconfigure(0, weight=1)
        table_wrap.grid_rowconfigure(0, weight=1)

        cols = [
            "COD CLIENTE", "NOME", "CX", "KG", "PREÇO", "PEDIDO",
            "STATUS_PEDIDO", "CAIXAS_ATUAL", "PRECO_ATUAL", "ALTERADO_EM",
            "RECEBIDO_VALOR", "MORTALIDADE"
        ]
        tree = ttk.Treeview(table_wrap, columns=cols, show="headings")
        tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(table_wrap, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=0, column=1, sticky="ns")

        hsb = ttk.Scrollbar(table_wrap, orient="horizontal", command=tree.xview)
        tree.configure(xscrollcommand=hsb.set)
        hsb.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        for c in cols:
            tree.heading(c, text=c)
            tree.column(c, width=130, anchor="w")

        tree.column("COD CLIENTE", width=100, anchor="center")
        tree.column("NOME", width=260, anchor="w")
        tree.column("CX", width=70, anchor="center")
        tree.column("KG", width=90, anchor="center")
        tree.column("PREÇO", width=90, anchor="center")
        tree.column("PEDIDO", width=140, anchor="w")
        tree.column("STATUS_PEDIDO", width=140, anchor="center")
        tree.column("CAIXAS_ATUAL", width=110, anchor="center")
        tree.column("PRECO_ATUAL", width=110, anchor="center")
        tree.column("ALTERADO_EM", width=150, anchor="center")
        tree.column("RECEBIDO_VALOR", width=120, anchor="center")
        tree.column("MORTALIDADE", width=110, anchor="center")

        try:
            enable_treeview_sorting(
                tree,
                numeric_cols={"CX", "CAIXAS_ATUAL", "MORTALIDADE"},
                money_cols={"PREÇO", "PRECO_ATUAL", "RECEBIDO_VALOR"},
                date_cols={"ALTERADO_EM"}
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        def _fmt_money(v):
            try:
                v = float(v or 0.0)
                s = f"{v:,.2f}"
                return "R$ " + s.replace(",", "X").replace(".", ",").replace("X", ".")
            except Exception:
                return "R$ 0,00"

        def _load_preview():
            try:
                tree.delete(*tree.get_children())
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            motorista = ""
            veiculo = ""
            equipe = ""
            status = ""
            nf_numero = ""
            local_rota = ""
            local_carreg = ""
            saida_data = ""
            saida_hora = ""
            data_saida = ""
            hora_saida = ""
            km_inicial = 0.0
            km_final = 0.0

            adiant = 0.0
            nf_kg_carregado = 0.0
            nf_caixas = 0
            nf_saldo = 0.0

            # ✅ helper local pra não quebrar se não existir ainda no arquivo
            def _db_has_column_best_effort(cur, table, col):
                try:
                    if "db_has_column" in globals():
                        return db_has_column(cur, table, col)
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)
                try:
                    cur.execute(f"PRAGMA table_info({table})")
                    cols = [str(r[1] or "").lower() for r in cur.fetchall()]
                    return str(col or "").lower() in cols
                except Exception:
                    return False

            # 1) HEADER
            try:
                with get_db() as conn:
                    cur = conn.cursor()

                    cols_chk = [
                        "status",
                        "nf_numero",
                        "local_rota",
                        "local_carregamento",
                        "saida_data",
                        "saida_hora",
                        "data_saida",
                        "hora_saida",
                        "adiantamento",
                        "adiantamento_rota",
                        "nf_kg_carregado",
                        "nf_caixas",
                        "nf_saldo",
                        "km_inicial",
                        "km_final",
                    ]
                    existing = {c: _db_has_column_best_effort(cur, "programacoes", c) for c in cols_chk}

                    select_parts = ["motorista", "veiculo", "equipe"]
                    select_parts.append("status" if existing["status"] else "'' as status")
                    select_parts.append("nf_numero" if existing["nf_numero"] else "'' as nf_numero")
                    select_parts.append("local_rota" if existing["local_rota"] else "'' as local_rota")
                    select_parts.append("local_carregamento" if existing["local_carregamento"] else "'' as local_carregamento")
                    select_parts.append("saida_data" if existing["saida_data"] else "'' as saida_data")
                    select_parts.append("saida_hora" if existing["saida_hora"] else "'' as saida_hora")
                    select_parts.append("data_saida" if existing["data_saida"] else "'' as data_saida")
                    select_parts.append("hora_saida" if existing["hora_saida"] else "'' as hora_saida")
                    select_parts.append("km_inicial" if existing["km_inicial"] else "0 as km_inicial")
                    select_parts.append("km_final" if existing["km_final"] else "0 as km_final")

                    if existing["adiantamento"]:
                        select_parts.append("adiantamento")
                    elif existing["adiantamento_rota"]:
                        select_parts.append("adiantamento_rota as adiantamento")
                    else:
                        select_parts.append("0 as adiantamento")

                    select_parts.append("nf_kg_carregado" if existing["nf_kg_carregado"] else "0 as nf_kg_carregado")
                    select_parts.append("nf_caixas" if existing["nf_caixas"] else "0 as nf_caixas")
                    select_parts.append("nf_saldo" if existing["nf_saldo"] else "0 as nf_saldo")

                    cur.execute(f"""
                        SELECT {", ".join(select_parts)}
                        FROM programacoes
                        WHERE codigo_programacao=?
                        LIMIT 1
                    """, (codigo,))
                    row = cur.fetchone()

                    if row:
                        motorista = row[0] or ""
                        veiculo = row[1] or ""
                        equipe = row[2] or ""
                        status = row[3] or ""
                        nf_numero = row[4] or ""
                        local_rota = row[5] or ""
                        local_carreg = row[6] or ""
                        saida_data = row[7] or ""
                        saida_hora = row[8] or ""
                        data_saida = row[9] or ""
                        hora_saida = row[10] or ""
                        km_inicial = safe_float(row[11], 0.0)
                        km_final = safe_float(row[12], 0.0)
                        adiant = safe_float(row[13], 0.0)
                        nf_kg_carregado = safe_float(row[14], 0.0)
                        nf_caixas = safe_int(row[15], 0)
                        nf_saldo = safe_float(row[16], 0.0)

            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            # 2) ITENS (fallback se helper não existir ainda)
            try:
                if "fetch_programacao_itens" in globals():
                    itens = fetch_programacao_itens(codigo)
                else:
                    itens = []
            except Exception:
                itens = []

            total_cx = 0
            total_kg = 0.0

            for it in itens:
                cod_cliente = it.get("cod_cliente", "")
                nome = it.get("nome_cliente", "")
                cx = safe_int(it.get("qnt_caixas", 0), 0)
                kg = safe_float(it.get("kg", 0.0), 0.0)
                preco = safe_float(it.get("preco", 0.0), 0.0)
                pedido = it.get("pedido", "") or ""
                status_pedido = it.get("status_pedido", "") or ""
                caixas_atual = safe_int(it.get("caixas_atual", 0), 0)
                preco_atual = safe_float(it.get("preco_atual", 0.0), 0.0)
                alterado_em = it.get("alterado_em", "") or ""
                recebido_valor = safe_float(it.get("valor_recebido", 0.0), 0.0)
                mortalidade = safe_int(it.get("mortalidade_aves", 0), 0)

                total_cx += cx
                total_kg += kg

                tree.insert("", "end", values=(
                    cod_cliente,
                    nome,
                    cx,
                    f"{kg:.2f}".replace(".", ","),
                    _fmt_money(preco),
                    pedido,
                    status_pedido,
                    caixas_atual,
                    _fmt_money(preco_atual),
                    alterado_em,
                    _fmt_money(recebido_valor),
                    mortalidade
                ))

            # 3) labels
            lbl_status.config(text=f"Status: {status or ''}")
            lbl_motorista.config(text=f"Motorista: {motorista or ''}")
            equipe_txt = resolve_equipe_nomes(equipe)
            lbl_equipe.config(text=f"Equipe: {equipe_txt or ''}")
            lbl_nf.config(text=f"NF: {nf_numero or ''}")

            lbl_adiant.config(text=f"Adiantamento: {_fmt_money(adiant)}")
            lbl_local_rota.config(text=f"Local da Rota: {local_rota or ''}")
            lbl_local_carreg.config(text=f"Carregou em: {local_carreg or ''}")

            saida_txt = "ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â"
            if saida_data or saida_hora:
                saida_txt = format_date_time(saida_data, saida_hora) or "â€ â€"
            elif data_saida or hora_saida:
                saida_txt = format_date_time(data_saida, hora_saida) or "â€ â€"
            lbl_saida.config(text=f"Saída: {saida_txt}")

            if nf_kg_carregado <= 0:
                nf_kg_carregado = total_kg
            if nf_caixas <= 0:
                nf_caixas = total_cx

            lbl_kg_carregado.config(text=f"KG Carregado: {nf_kg_carregado:.2f}".replace(".", ","))
            lbl_caixas_carreg.config(text=f"Caixas Carregadas: {nf_caixas}")
            lbl_caixas_entreg.config(text=f"Caixas Entregues: {total_cx}")
            lbl_saldo.config(text=f"Saldo (NF - Granja): {nf_saldo:.2f}".replace(".", ","))
            if km_inicial or km_final:
                lbl_km.config(text=f"KM: {km_inicial:.2f} → {km_final:.2f}".replace(".", ","))
            else:
                lbl_km.config(text="KM: ")

            try:
                if motorista or veiculo:
                    lbl_title.config(text=f"ROTA ATIVA: {codigo}    {upper(motorista)}    {upper(veiculo)}")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        _load_preview()

        btns = ttk.Frame(frm)
        btns.grid(row=3, column=0, sticky="e", pady=(6, 0))
        ttk.Button(btns, text="ATUALIZAR", style="Ghost.TButton", command=_load_preview).pack(side="right")


class RotasPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Rotas")

        card = ttk.Frame(self.body, style="Card.TFrame", padding=18)
        card.grid(row=0, column=0, sticky="ew")
        card.grid_columnconfigure(0, weight=1)

        ttk.Label(card, text="Rotas", style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")
        ttk.Label(
            card,
            text="Tela reservada para futuras funcionalidades (mapa, rotas, tracking do App Mobile etc).",
            style="CardLabel.TLabel",
            justify="left"
        ).grid(row=1, column=0, sticky="w", pady=(6, 0))

    def on_show(self):
        self.set_status("STATUS: Rotas (em construção).")


# ==========================
# ===== FIM DA PARTE 2 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INICIO DA PARTE X (FINAL / SEM DUPLICIDADE) =====
# ==========================

import re

# =========================================================
# ORDENAÃ‡ÃƒO UNIVERSAL PARA TREEVIEW (CLIQUE NO CABEÃ‡ALHO)
# =========================================================
def enable_treeview_sorting(tree: ttk.Treeview, numeric_cols=None, money_cols=None, date_cols=None):
    """
    Habilita ordenação clicando no cabeçalho do Treeview.
    - numeric_cols: colunas que devem ser tratadas como número
    - money_cols: colunas monetárias (R$ 1.234,56)
    - date_cols: colunas de data (dd/mm/aaaa ou yyyy-mm-dd)
    """
    numeric_cols = set(numeric_cols or [])
    money_cols = set(money_cols or [])
    date_cols = set(date_cols or [])

    if not hasattr(tree, "_sort_state"):
        tree._sort_state = {"col": None, "reverse": False}

    def _clean_header_text(t: str) -> str:
        t = (t or "").strip()
        if t.endswith(" Ã¢â€ â€˜") or t.endswith(" Ã¢â€ â€œ"):
            return t[:-2]
        return t

    def _to_float(v):
        try:
            if v is None:
                return 0.0
            s = str(v).strip()
            if not s or s in {"", "-", "None"}:
                return 0.0

            s = s.replace("R$", "").replace(" ", "")

            neg = False
            if s.startswith("(") and s.endswith(")"):
                neg = True
                s = s[1:-1].strip()

            s = s.replace(".", "").replace(",", ".")
            val = float(s)
            return -val if neg else val
        except Exception:
            return 0.0

    def _to_date_key(v):
        if v is None:
            return (0, 0, 0)

        s = str(v).strip()
        if not s or s in {"", "-", "None"}:
            return (0, 0, 0)

        # yyyy-mm-dd (ou yyyy-mm-dd hh:mm:ss)
        if "-" in s and len(s) >= 10:
            try:
                y, m, d = s[:10].split("-")
                return (int(y), int(m), int(d))
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        # dd/mm/yyyy (ou dd/mm/yyyy hh:mm:ss)
        if "/" in s and len(s) >= 10:
            try:
                d, m, y = s[:10].split("/")
                return (int(y), int(m), int(d))
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        return (0, 0, 0)

    def sort_by(col):
        if tree._sort_state["col"] == col:
            tree._sort_state["reverse"] = not tree._sort_state["reverse"]
        else:
            tree._sort_state["col"] = col
            tree._sort_state["reverse"] = False

        reverse = tree._sort_state["reverse"]
        data = [(tree.set(iid, col), iid) for iid in tree.get_children("")]

        if col in money_cols or col in numeric_cols:
            data.sort(key=lambda x: _to_float(x[0]), reverse=reverse)
        elif col in date_cols:
            data.sort(key=lambda x: _to_date_key(x[0]), reverse=reverse)
        else:
            data.sort(key=lambda x: str(x[0]).strip().upper(), reverse=reverse)

        for idx, (_, iid) in enumerate(data):
            tree.move(iid, "", idx)

        arrow = " Ã¢â€ â€œ" if reverse else " Ã¢â€ â€˜"
        for c in tree["columns"]:
            tree.heading(c, text=_clean_header_text(tree.heading(c, "text")))

        tree.heading(col, text=_clean_header_text(tree.heading(col, "text")) + arrow)

    for c in tree["columns"]:
        tree.heading(c, command=lambda col=c: sort_by(col))


# =========================================================
# VALIDADORES (CPF / TELEFONE / CÓDIGO / SENHA MOTORISTA)
# =========================================================

_CPF_DIGITS = re.compile(r"\D+")
_PHONE_DIGITS = re.compile(r"\D+")
_MOTORISTA_COD_RE = re.compile(r"^[A-Z0-9._-]{3,24}$")  # já normaliza em upper()

def normalize_cpf(v: str) -> str:
    return _CPF_DIGITS.sub("", str(v or "").strip())

def is_valid_cpf(cpf_digits: str) -> bool:
    """
    Validador de CPF (Brasil).
    Aceita apenas 11 dígitos e verifica dígitos verificadores.
    """
    cpf = normalize_cpf(cpf_digits)
    if len(cpf) != 11:
        return False
    if cpf == cpf[0] * 11:
        return False

    try:
        nums = [int(x) for x in cpf]

        # 1Ã‚Âº dÃƒÂ­gito
        s1 = sum(nums[i] * (10 - i) for i in range(9))
        d1 = (s1 * 10) % 11
        d1 = 0 if d1 == 10 else d1
        if d1 != nums[9]:
            return False

        # 2Ã‚Âº dÃƒÂ­gito
        s2 = sum(nums[i] * (11 - i) for i in range(10))
        d2 = (s2 * 10) % 11
        d2 = 0 if d2 == 10 else d2
        if d2 != nums[10]:
            return False

        return True
    except Exception:
        return False

def normalize_phone(v: str) -> str:
    """
    Normaliza telefone para dígitos.
    Se vier com DDI 55 (Brasil), remove quando fizer sentido.
    """
    s = _PHONE_DIGITS.sub("", str(v or "").strip())
    # remove 55 se vier com DDI e sobrar 10/11 dígitos
    if len(s) in (12, 13) and s.startswith("55"):
        s2 = s[2:]
        if len(s2) in (10, 11):
            return s2
    return s

def is_valid_phone(phone_digits: str) -> bool:
    tel = normalize_phone(phone_digits)
    return len(tel) in (10, 11) and tel.isdigit()

def is_valid_motorista_codigo(cod: str) -> bool:
    cod = upper(str(cod or "").strip())
    return bool(_MOTORISTA_COD_RE.match(cod))

def is_valid_motorista_senha(senha: str) -> bool:
    senha = str(senha or "").strip()
    return 4 <= len(senha) <= 24


# =========================================================
# UTILITRIOS DE BANCO / BUSCA (PROGRAMACOES ATIVAS / ITENS)
# =========================================================

_SAFE_SQL_IDENT = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")

def _safe_ident(name: str) -> str:
    """
    Valida identificador SQL (tabela/coluna) para evitar SQL injection.
    SQLite não aceita parametrizar PRAGMA table_info(?)  então validamos.
    """
    name = str(name or "").strip()
    if not _SAFE_SQL_IDENT.match(name):
        raise ValueError(f"Identificador SQL inválido: {name!r}")
    return name


def db_has_column(cur, table_name: str, column_name: str) -> bool:
    """
    Verifica se uma coluna existe numa tabela (SQLite).
    Segurança: não altera nada, só consulta PRAGMA.
    """
    try:
        table_name = _safe_ident(table_name)
        column_name = str(column_name or "").strip().lower()
        cur.execute(f"PRAGMA table_info({table_name})")
        cols = [str(r[1]).lower() for r in cur.fetchall()]
        return column_name in cols
    except Exception:
        return False


def fetch_programacoes_ativas(limit: int = 400):
    """
    Retorna lista de programações ATIVAS (compatível com bases antigas e novas).
    Saída: lista de dicts: {codigo, motorista, veiculo, equipe, data_criacao, status}
    """
    try:
        equipes_map = {}
        with get_db() as conn:
            cur = conn.cursor()

            has_status = db_has_column(cur, "programacoes", "status")
            has_data = db_has_column(cur, "programacoes", "data_criacao")

            if has_status:
                if has_data:
                    cur.execute("""
                        SELECT codigo_programacao, motorista, veiculo, equipe, data_criacao, status
                        FROM programacoes
                        WHERE status='ATIVA'
                        ORDER BY id DESC
                        LIMIT ?
                    """, (limit,))
                else:
                    cur.execute("""
                        SELECT codigo_programacao, motorista, veiculo, equipe, '' as data_criacao, status
                        FROM programacoes
                        WHERE status='ATIVA'
                        ORDER BY id DESC
                        LIMIT ?
                    """, (limit,))
            else:
                # base antiga sem status: pega as últimas como "ativas"
                if has_data:
                    cur.execute("""
                        SELECT codigo_programacao, motorista, veiculo, equipe, data_criacao, 'ATIVA' as status
                        FROM programacoes
                        ORDER BY id DESC
                        LIMIT ?
                    """, (limit,))
                else:
                    cur.execute("""
                        SELECT codigo_programacao, motorista, veiculo, equipe, '' as data_criacao, 'ATIVA' as status
                        FROM programacoes
                        ORDER BY id DESC
                        LIMIT ?
                    """, (limit,))

            rows = cur.fetchall()

            try:
                cur.execute("SELECT codigo, ajudante1, ajudante2 FROM equipes")
                for er in cur.fetchall() or []:
                    codigo = upper(er[0] if er else "")
                    nomes = format_equipe_nomes(er[1] if er else "", er[2] if er else "", "")
                    if codigo and nomes:
                        equipes_map[codigo] = nomes
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        
        out = []
        for r in rows:
            equipe_raw = r[3] or ""
            equipe_key = upper(equipe_raw)
            equipe_nome = equipes_map.get(equipe_key, equipe_raw)
            out.append({
                "codigo": r[0] or "",
                "motorista": r[1] or "",
                "veiculo": r[2] or "",
                "equipe": equipe_nome or "",
                "data_criacao": r[4] or "",
                "status": r[5] or "",
            })
        return out


    except Exception:
        return []


def fetch_programacao_itens(codigo_programacao: str, limit: int = 8000):
    """
    Retorna itens de uma programacao.
    Saida: lista de dicts:
      {cod_cliente, nome_cliente, produto, endereco, qnt_caixas, kg, preco, vendedor, pedido, obs,
       status_pedido, caixas_atual, preco_atual, alterado_em, alterado_por,
       mortalidade_aves, valor_recebido, forma_recebimento, obs_recebimento}
    Compativel com schemas diferentes.
    """
    codigo_programacao = upper(str(codigo_programacao or "").strip())
    if not codigo_programacao:
        return []

    try:
        with get_db() as conn:
            cur = conn.cursor()

            has_obs = db_has_column(cur, "programacao_itens", "obs") or db_has_column(cur, "programacao_itens", "observacao")
            has_vendedor = db_has_column(cur, "programacao_itens", "vendedor")
            has_pedido = db_has_column(cur, "programacao_itens", "pedido")
            has_end = db_has_column(cur, "programacao_itens", "endereco") or db_has_column(cur, "programacao_itens", "endereco")
            has_produto = db_has_column(cur, "programacao_itens", "produto")

            has_status = db_has_column(cur, "programacao_itens", "status_pedido")
            has_caixas_atual = db_has_column(cur, "programacao_itens", "caixas_atual")
            has_preco_atual = db_has_column(cur, "programacao_itens", "preco_atual")
            has_alt_em = db_has_column(cur, "programacao_itens", "alterado_em")
            has_alt_por = db_has_column(cur, "programacao_itens", "alterado_por")

            # controle
            has_ctrl = db_has_column(cur, "programacao_itens_controle", "codigo_programacao")

            select_cols = [
                "pi.cod_cliente",
                "pi.nome_cliente",
                ("pi.endereco" if has_end else "'' as endereco"),
                ("pi.produto" if has_produto else "'' as produto"),
                "pi.qnt_caixas",
                "pi.kg",
                "pi.preco",
                ("pi.vendedor" if has_vendedor else "'' as vendedor"),
                ("pi.pedido" if has_pedido else "'' as pedido"),
                ("pi.obs" if db_has_column(cur, "programacao_itens", "obs") else ("pi.observacao" if db_has_column(cur, "programacao_itens", "observacao") else "'' as obs")),
                ("pi.status_pedido" if has_status else "'' as status_pedido"),
                ("pi.caixas_atual" if has_caixas_atual else "0 as caixas_atual"),
                ("pi.preco_atual" if has_preco_atual else "0 as preco_atual"),
                ("pi.alterado_em" if has_alt_em else "'' as alterado_em"),
                ("pi.alterado_por" if has_alt_por else "'' as alterado_por"),
            ]

            join_ctrl = ""
            if has_ctrl:
                select_cols.extend([
                    "COALESCE(pc.mortalidade_aves, 0) as mortalidade_aves",
                    "COALESCE(pc.valor_recebido, 0) as valor_recebido",
                    "COALESCE(pc.forma_recebimento, '') as forma_recebimento",
                    "COALESCE(pc.obs_recebimento, '') as obs_recebimento",
                ])
                join_ctrl = "LEFT JOIN programacao_itens_controle pc ON pc.codigo_programacao = pi.codigo_programacao AND UPPER(pc.cod_cliente)=UPPER(pi.cod_cliente)"
            else:
                select_cols.extend([
                    "0 as mortalidade_aves",
                    "0 as valor_recebido",
                    "'' as forma_recebimento",
                    "'' as obs_recebimento",
                ])

            cur.execute(f"""
                SELECT {", ".join(select_cols)}
                FROM programacao_itens pi
                {join_ctrl}
                WHERE pi.codigo_programacao=?
                ORDER BY pi.id ASC
                LIMIT ?
            """, (codigo_programacao, limit))

            rows = cur.fetchall()

        out = []
        for r in rows:
            out.append({
                "cod_cliente": r[0] or "",
                "nome_cliente": r[1] or "",
                "endereco": r[2] or "",
                "produto": r[3] or "",
                "qnt_caixas": safe_int(r[4], 0),
                "kg": safe_float(r[5], 0.0),
                "preco": safe_float(r[6], 0.0),
                "vendedor": r[7] or "",
                "pedido": r[8] or "",
                "obs": (r[9] or "") if has_obs else (r[9] or ""),
                "status_pedido": r[10] or "",
                "caixas_atual": safe_int(r[11], 0),
                "preco_atual": safe_float(r[12], 0.0),
                "alterado_em": r[13] or "",
                "alterado_por": r[14] or "",
                "mortalidade_aves": safe_int(r[15], 0),
                "valor_recebido": safe_float(r[16], 0.0),
                "forma_recebimento": r[17] or "",
                "obs_recebimento": r[18] or "",
            })
        return out

    except Exception:
        return []


def format_prog_display(p: dict) -> str:
    """
    Formata texto amigável p/ lista/combobox sem quebrar.
    Ex: "ABC123 (2026-01-18) - JOAO - ABC1D23"
    """
    try:
        codigo = upper(p.get("codigo", ""))
        data = str(p.get("data_criacao", "") or "")[:10]
        motorista = upper(p.get("motorista", ""))[:18]
        veiculo = upper(p.get("veiculo", ""))[:12]
        if data:
            return f"{codigo} ({data}) - {motorista} - {veiculo}"
        return f"{codigo} - {motorista} - {veiculo}"
    except Exception:
        return upper(str(p.get("codigo", "")))

# ==========================
# ===== FIM DA PARTE X (FINAL) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 3 (FINAL / SEM DUPLICIDADE) =====
# ==========================

# =========================================================
# 3.0.1 CLIENTES (IMPORTAÃƒâ€¡ÃƒÆ’O + EDIÃƒâ€¡ÃƒÆ’O DIRETA NA TABELA)
# =========================================================
class ClientesImportPage(ttk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, style="Content.TFrame")
        self.app = app
        self._editing = None

        card = ttk.Frame(self, style="Card.TFrame", padding=14)
        card.pack(fill="both", expand=True)
        card.grid_columnconfigure(0, weight=1)
        card.grid_rowconfigure(2, weight=1)

        ttk.Label(card, text="Clientes (Base do Wibi)", style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")

        actions = ttk.Frame(card, style="Card.TFrame")
        actions.grid(row=1, column=0, sticky="ew", pady=(12, 10))
        actions.grid_columnconfigure(10, weight=1)

        ttk.Button(actions, text="IMPORTAR CLIENTES (EXCEL)", style="Warn.TButton",
                   command=self.importar_clientes_excel).grid(row=0, column=0, padx=6)

        ttk.Button(actions, text="ATUALIZAR", style="Ghost.TButton",
                   command=self.carregar).grid(row=0, column=1, padx=6)

        ttk.Button(actions, text="INSERIR LINHA", style="Ghost.TButton",
                   command=self.inserir_linha).grid(row=0, column=2, padx=6)

        ttk.Button(actions, text="SALVAR ALTERAÇÕES", style="Primary.TButton",
                   command=self.salvar_alteracoes).grid(row=0, column=3, padx=6)

        self.lbl_info = ttk.Label(
            actions,
            text="Dica: duplo clique na célula para editar. ENTER salva a célula. ESC cancela.",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 8, "bold")
        )
        self.lbl_info.grid(row=0, column=4, padx=12, sticky="w")

        cols = ["CÓD CLIENTE", "NOME CLIENTE", "ENDEREÇO", "TELEFONE", "VENDEDOR"]
        table_wrap = ttk.Frame(card, style="Card.TFrame")
        table_wrap.grid(row=2, column=0, sticky="nsew")
        table_wrap.grid_columnconfigure(0, weight=1)
        table_wrap.grid_rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(table_wrap, columns=cols, show="headings")
        self.tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(table_wrap, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=0, column=1, sticky="ns")

        hsb = ttk.Scrollbar(table_wrap, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=hsb.set)
        hsb.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=190, minwidth=120, anchor="w")

        self.tree.column("ENDEREÇO", width=420, minwidth=200)
        self.tree.bind("<Double-1>", self._start_edit_cell)

        enable_treeview_sorting(
            self.tree,
            numeric_cols={"CÓD CLIENTE"},
            money_cols=set(),
            date_cols=set()
        )

        # Se rolar o tree durante edição, fecha/commita corretamente
        self.tree.bind("<MouseWheel>", self._on_tree_scroll, add=True)
        self.tree.bind("<Button-4>", self._on_tree_scroll, add=True)  # linux
        self.tree.bind("<Button-5>", self._on_tree_scroll, add=True)  # linux

        self.carregar()

    # -------------------------
    # Helpers (reduz duplicidade)
    # -------------------------
    def _get_row_values(self, iid):
        vals = self.tree.item(iid, "values") or ("", "", "", "", "")
        vals = list(vals) + [""] * (5 - len(vals))
        return [str(v or "").strip() for v in vals[:5]]

    def _is_blank_row(self, cod, nome, endereco, telefone, vendedor):
        return not (cod or nome or endereco or telefone or vendedor)

    def _normalize_cod(self, cod):
        return str(cod or "").strip()

    def carregar(self):
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT cod_cliente, nome_cliente, endereco, telefone, vendedor
                FROM clientes
                ORDER BY nome_cliente ASC
                LIMIT 5000
            """)
            rows = cur.fetchall()

        self.tree.delete(*self.tree.get_children())

        for r in rows:
            self.tree.insert("", "end", values=(r[0] or "", r[1] or "", r[2] or "", r[3] or "", r[4] or ""))

        if self.app and hasattr(self.app, "refresh_programacao_comboboxes"):
            self.app.refresh_programacao_comboboxes()

    def inserir_linha(self):
        self.tree.insert("", "end", values=("", "", "", "", ""))
        items = self.tree.get_children()
        if items:
            self.tree.see(items[-1])

    def _on_tree_scroll(self, event=None):
        if self._editing:
            self._commit_edit()

    def _start_edit_cell(self, event=None):
        if self._editing:
            self._commit_edit()

        region = self.tree.identify("region", event.x, event.y)
        if region != "cell":
            return

        row_id = self.tree.identify_row(event.y)
        col_id = self.tree.identify_column(event.x)
        if not row_id or not col_id:
            return

        col_index = int(col_id.replace("#", "")) - 1
        vals = self._get_row_values(row_id)
        if col_index < 0 or col_index >= len(vals):
            return

        bbox = self.tree.bbox(row_id, col_id)
        if not bbox:
            return

        x, y, w, h = bbox
        value = vals[col_index]

        entry = ttk.Entry(self.tree, style="Field.TEntry")
        entry.place(x=x, y=y, width=w, height=h)
        entry.insert(0, value)
        entry.focus_set()
        entry.selection_range(0, "end")

        entry.bind("<Return>", lambda e: self._commit_edit())
        entry.bind("<Escape>", lambda e: self._cancel_edit())
        entry.bind("<FocusOut>", lambda e: self._commit_edit())

        self._editing = (row_id, col_index, entry)

    def _commit_edit(self):
        if not self._editing:
            return

        row_id, col_index, entry = self._editing
        try:
            new_value = entry.get()
        except Exception:
            new_value = ""

        vals = self._get_row_values(row_id)
        if 0 <= col_index < len(vals):
            vals[col_index] = str(new_value).strip()
            self.tree.item(row_id, values=tuple(vals))

        try:
            entry.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        self._editing = None

    def _cancel_edit(self):
        if not self._editing:
            return
        _, _, entry = self._editing
        try:
            entry.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        self._editing = None

    def salvar_alteracoes(self):
        if self._editing:
            self._commit_edit()

        items = self.tree.get_children()
        if not items:
            messagebox.showwarning("ATENÇÃO", "Não há dados para salvar.")
            return

        linhas = []
        cods_seen = set()

        for iid in items:
            cod, nome, endereco, telefone, vendedor = self._get_row_values(iid)

            if self._is_blank_row(cod, nome, endereco, telefone, vendedor):
                continue

            cod_norm = self._normalize_cod(cod)
            nome_norm = str(nome or "").strip()

            if not cod_norm or not nome_norm:
                messagebox.showwarning("ATENÇÃO", "Todas as linhas precisam ter pelo menos CÓD CLIENTE e NOME CLIENTE.")
                return

            cod_key = upper(cod_norm)
            if cod_key in cods_seen:
                messagebox.showwarning("ATENÇÃO", f"CÓD CLIENTE duplicado na tabela: {cod_norm}\n\nCorrija antes de salvar.")
                return
            cods_seen.add(cod_key)

            linhas.append((upper(cod_norm), upper(nome_norm), upper(endereco), upper(telefone), upper(vendedor)))

        if not linhas:
            messagebox.showwarning("ATENÇÃO", "Nenhuma linha válida para salvar.")
            return

        total = 0
        try:
            with get_db() as conn:
                cur = conn.cursor()
                for cod, nome, endereco, telefone, vendedor in linhas:
                    cur.execute("""
                        INSERT INTO clientes (cod_cliente, nome_cliente, endereco, telefone, vendedor)
                        VALUES (?, ?, ?, ?, ?)
                        ON CONFLICT(cod_cliente) DO UPDATE SET
                            nome_cliente=excluded.nome_cliente,
                            endereco=excluded.endereco,
                            telefone=excluded.telefone,
                            vendedor=excluded.vendedor
                    """, (cod, nome, endereco, telefone, vendedor))
                    total += 1

            messagebox.showinfo("OK", f"Clientes salvos/atualizados: {total}")

        except Exception as e:
            messagebox.showerror("ERRO", str(e))

        self.carregar()

    def importar_clientes_excel(self):
        path = filedialog.askopenfilename(
            title="IMPORTAR CLIENTES (EXCEL)",
            filetypes=[("Excel", "*.xls *.xlsx")]
        )
        if not path:
            return

        if not (require_pandas() and require_excel_support(path)):
            return

        try:
            df = pd.read_excel(path, engine=excel_engine_for(path))

            col_cod = guess_col(df.columns, ["cod", "cód", "codigo", "cliente", "cod cliente"])
            col_nome = guess_col(df.columns, ["nome", "cliente"])
            col_end = guess_col(df.columns, ["endereco", "endereço", "rua", "logradouro"])
            col_tel = guess_col(df.columns, ["telefone", "fone", "celular", "contato"])
            col_vendedor = guess_col(df.columns, ["vendedor", "vend", "representante"])

            if not col_cod or not col_nome:
                messagebox.showerror("ERRO", "NÃO IDENTIFIQUEI AS COLUNAS DE CÓDIGO E NOME DO CLIENTE NO EXCEL.")
                return

            total = 0
            with get_db() as conn:
                cur = conn.cursor()
                for _, r in df.iterrows():
                    cod = str(r.get(col_cod, "")).strip()
                    nome = str(r.get(col_nome, "")).strip()
                    if not cod or not nome:
                        continue

                    endereco = str(r.get(col_end, "")).strip() if col_end else ""
                    telefone = str(r.get(col_tel, "")).strip() if col_tel else ""
                    vendedor = str(r.get(col_vendedor, "")).strip() if col_vendedor else ""

                    cur.execute("""
                        INSERT INTO clientes (cod_cliente, nome_cliente, endereco, telefone, vendedor)
                        VALUES (?, ?, ?, ?, ?)
                        ON CONFLICT(cod_cliente) DO UPDATE SET
                            nome_cliente=excluded.nome_cliente,
                            endereco=excluded.endereco,
                            telefone=excluded.telefone,
                            vendedor=excluded.vendedor
                    """, (upper(cod), upper(nome), upper(endereco), upper(telefone), upper(vendedor)))
                    total += 1

            messagebox.showinfo("OK", f"CLIENTES IMPORTADOS/ATUALIZADOS: {total}")
            self.carregar()

        except Exception as e:
            messagebox.showerror("ERRO", str(e))


class CadastrosPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Cadastros")

        card = ttk.Frame(self.body, style="Card.TFrame", padding=12)
        card.grid(row=0, column=0, sticky="nsew")
        card.grid_columnconfigure(0, weight=1)
        card.grid_rowconfigure(0, weight=1)

        nb = ttk.Notebook(card)
        nb.grid(row=0, column=0, sticky="nsew")

        frm_motoristas = ttk.Frame(nb, style="Content.TFrame")
        crud_motoristas = CadastroCRUD(
            frm_motoristas,
            "Motoristas",
            "motoristas",
            [
                ("nome", "NOME"),
                ("codigo", "CODIGO"),
                ("senha", "SENHA"),
                
                ("cpf", "CPF"),
                
                ("telefone", "TELEFONE"),
            ],
            app=app
        )
        crud_motoristas.pack(fill="both", expand=True)
        nb.add(frm_motoristas, text="Motoristas")

        frm_usuarios = ttk.Frame(nb, style="Content.TFrame")
        crud_usuarios = CadastroCRUD(
            frm_usuarios,
            "Usuários",
            "usuarios",
            [
                ("nome", "NOME"),
                ("codigo", "CODIGO"),
                ("senha", "SENHA"),
                ("permissoes", "PERMISSÕES"),
                ("cpf", "CPF"),
                
                ("telefone", "TELEFONE"),
            ],
            app=app
        )
        crud_usuarios.pack(fill="both", expand=True)
        nb.add(frm_usuarios, text="Usuários")

        frm_veiculos = ttk.Frame(nb, style="Content.TFrame")
        crud_veiculos = CadastroCRUD(
            frm_veiculos,
            "Veículos",
            "veiculos",
            [
                ("placa", "PLACA"),
                ("modelo", "MODELO"),
                
                ("capacidade_cx", "CAPACIDADE (CX)"),
            ],
            app=app
        )
        crud_veiculos.pack(fill="both", expand=True)
        nb.add(frm_veiculos, text="Veículos")

        frm_equipes = ttk.Frame(nb, style="Content.TFrame")
        crud_equipes = CadastroCRUD(
            frm_equipes,
            "Equipes",
            "equipes",
            [
                ("codigo", "CÓDIGO"),
                ("ajudante1", "AJUDANTE 1"),
                ("ajudante2", "AJUDANTE 2"),
            ],
            app=app
        )
        crud_equipes.pack(fill="both", expand=True)
        nb.add(frm_equipes, text="Equipes")

        
        frm_clientes = ttk.Frame(nb, style="Content.TFrame")
        clientes_page = ClientesImportPage(frm_clientes, app=app)
        clientes_page.pack(fill="both", expand=True)
        nb.add(frm_clientes, text="Clientes")

    def on_show(self):
        self.set_status("STATUS: Cadastros (CRUD + Base de Clientes via Wibi).")

# ==========================
# ===== FIM DA PARTE 3 (FINAL) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 4 (ATUALIZADA) =====
# ==========================

# =========================================================
# 4.0 IMPORTAÃƒâ€¡ÃƒÆ’O DE VENDAS
# =========================================================
class ImportarVendasPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Importar Vendas (Excel)")

        top = ttk.Frame(self.body, style="Content.TFrame")
        top.grid(row=0, column=0, sticky="ew")
        top.grid_columnconfigure(3, weight=1)

        ttk.Button(top, text="IMPORTAR EXCEL", style="Primary.TButton", command=self.importar_excel).grid(row=0, column=0, padx=6)
        ttk.Button(top, text="LIMPAR TUDO", style="Danger.TButton", command=self.limpar_tudo).grid(row=0, column=1, sticky="w", padx=6)
        ttk.Button(top, text="ATUALIZAR", style="Ghost.TButton", command=self.carregar).grid(row=0, column=2, padx=6)

        self.lbl_info = ttk.Label(
            top,
            text="Selecione as vendas que irão para Programação (duplo clique marca/desmarca).",
            background="#F4F6FB",
            foreground="#6B7280",
            font=("Segoe UI", 8, "bold")
        )
        self.lbl_info.grid(row=0, column=3, sticky="w", padx=10)

        card = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        card.grid(row=1, column=0, sticky="nsew", pady=(14, 0))
        card.grid_columnconfigure(0, weight=1)
        card.grid_rowconfigure(2, weight=1)

        # Filtros
        filt = ttk.Frame(card, style="Card.TFrame")
        filt.grid(row=0, column=0, sticky="ew", pady=(0, 12))
        filt.grid_columnconfigure(1, weight=1)
        filt.grid_columnconfigure(9, weight=1)

        ttk.Label(filt, text="Buscar:", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w")
        self.ent_busca = ttk.Entry(filt, style="Field.TEntry")
        self.ent_busca.grid(row=0, column=1, sticky="ew", padx=6)
        self.ent_busca.bind("<Return>", lambda e: self.carregar())

        ttk.Button(filt, text="FILTRAR", style="Ghost.TButton", command=self.carregar).grid(row=0, column=2, padx=6)

        ttk.Button(filt, text="MARCAR TODOS", style="Warn.TButton", command=lambda: self.set_all_selected(1)).grid(row=0, column=3, padx=6)
        ttk.Button(filt, text="DESMARCAR TODOS", style="Ghost.TButton", command=lambda: self.set_all_selected(0)).grid(row=0, column=4, padx=6)

        # Tabela (com scroll horizontal)
        cols = ["ID", "SEL", "PEDIDO", "DATA", "CLIENTE", "NOME COMPLETO", "PRODUTO", "VR TOTAL", "QNT", "CIDADE", "VENDEDOR"]
        table_wrap = ttk.Frame(card, style="Card.TFrame")
        table_wrap.grid(row=2, column=0, sticky="nsew")
        table_wrap.grid_columnconfigure(0, weight=1)
        table_wrap.grid_rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(table_wrap, columns=cols, show="headings")
        self.tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(table_wrap, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=0, column=1, sticky="ns")

        hsb = ttk.Scrollbar(table_wrap, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=hsb.set)
        hsb.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=140, minwidth=90, anchor="w")

        self.tree.column("ID", width=70, minwidth=60, anchor="center")
        self.tree.column("SEL", width=55, minwidth=55, anchor="center")
        self.tree.column("DATA", width=110, minwidth=90, anchor="center")
        self.tree.column("VR TOTAL", width=110, minwidth=90, anchor="e")
        self.tree.column("QNT", width=90, minwidth=70, anchor="center")
        self.tree.column("CIDADE", width=160, minwidth=120, anchor="w")
        self.tree.column("VENDEDOR", width=160, minwidth=120, anchor="w")

        self.tree.bind("<Double-1>", self.toggle_selected)

        enable_treeview_sorting(
            self.tree,
            numeric_cols={"ID", "QNT"},
            money_cols={"VR TOTAL"},
            date_cols={"DATA"}
        )

        self.carregar()

    def on_show(self):
        self.set_status("STATUS: ImportaÃ§Ã£o e seleÃ§Ã£o de vendas para programaÃ§Ã£o.")
        self.carregar()

    # -------------------------
    # Helpers seguranÃ§a/normalizaÃ§Ã£o
    # -------------------------
    def _norm(self, v):
        return upper(str(v or "").strip())

    def _ensure_vendas_usada_cols(self):
        """Garante colunas para evitar reutilização (não quebra bases antigas)."""
        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("PRAGMA table_info(vendas_importadas)")
                cols = [str(r[1]).lower() for r in cur.fetchall()]

                if "usada" not in cols:
                    cur.execute("ALTER TABLE vendas_importadas ADD COLUMN usada INTEGER DEFAULT 0")
                if "usada_em" not in cols:
                    cur.execute("ALTER TABLE vendas_importadas ADD COLUMN usada_em TEXT")
                if "codigo_programacao" not in cols:
                    cur.execute("ALTER TABLE vendas_importadas ADD COLUMN codigo_programacao TEXT")
        except Exception as e:
            logging.exception("Falha ao garantir colunas de vendas_importadas: %s", e)

    def importar_excel(self):
        path = filedialog.askopenfilename(
            title="IMPORTAR VENDAS (EXCEL)",
            filetypes=[("Excel", "*.xls *.xlsx")]
        )
        if not path:
            return

        if not (require_pandas() and require_excel_support(path)):
            return

        try:
            df = pd.read_excel(path, engine=excel_engine_for(path))

            col_pedido = guess_col(df.columns, ["numero pedido", "num pedido", "n pedido", "pedido"])
            col_data = guess_col(df.columns, ["data venda", "data", "dt"])
            col_cliente = guess_col(df.columns, ["cod cliente", "codigo cliente", "cliente", "cod"])
            col_nome = guess_col(df.columns, ["nome completo", "nome cliente", "razao", "nome"])
            col_prod = guess_col(df.columns, ["descricao do produto", "produto", "descr", "item"])
            col_vr_total = guess_col(df.columns, ["vr. total", "vr total", "valor total", "total"])
            col_qnt = guess_col(df.columns, ["qnt", "qtd", "quantidade"])
            col_cidade = guess_col(df.columns, ["cidade", "municipio"])
            col_vend = guess_col(df.columns, ["nome do vendedor", "vendedor", "vend"])
            col_obs = guess_col(df.columns, ["obs", "observ", "observacao"])

            missing = []
            if not col_pedido:
                missing.append("Numero Pedido")
            if not col_data:
                missing.append("Data")
            if not col_cliente:
                missing.append("Cliente")
            if not col_nome:
                missing.append("Nome Completo")
            if not col_prod:
                missing.append("Descricao do Produto")
            if not col_vr_total:
                missing.append("Vr. Total")
            if not col_qnt:
                missing.append("Qnt.")
            if not col_cidade:
                missing.append("Cidade")
            if not col_vend:
                missing.append("Nome do Vendedor")

            if missing:
                messagebox.showerror("ERRO", "Nao identifiquei as colunas: " + ", ".join(missing))
                return

            total = 0
            ignoradas = 0

            self._ensure_vendas_usada_cols()

            with get_db() as conn:
                cur = conn.cursor()

                for _, r in df.iterrows():
                    pedido = str(r.get(col_pedido, "")).strip()
                    if not pedido:
                        continue

                    data_venda = str(r.get(col_data, "")).strip() if col_data else ""
                    cliente = str(r.get(col_cliente, "")).strip()

                    nome_cliente = str(r.get(col_nome, "")).strip() if col_nome else ""
                    vendedor = str(r.get(col_vend, "")).strip() if col_vend else ""
                    produto = str(r.get(col_prod, "")).strip() if col_prod else ""
                    vr_total = safe_float(r.get(col_vr_total, 0)) if col_vr_total else 0.0
                    qnt = safe_float(r.get(col_qnt, 0)) if col_qnt else 0.0
                    cidade = str(r.get(col_cidade, "")).strip() if col_cidade else ""
                    valor_unit = (vr_total / qnt) if qnt else 0.0
                    obs = str(r.get(col_obs, "")).strip() if col_obs else ""

                    # ✅ Chave natural para evitar duplicidade (sem mexer no banco)
                    pedido_u = self._norm(pedido)
                    cliente_u = self._norm(cliente)
                    produto_u = self._norm(produto)

                    # Se não tiver cliente, não insere (proteção extra)
                    if not cliente_u:
                        ignoradas += 1
                        continue

                    try:
                        cur.execute("""
                            SELECT 1
                            FROM vendas_importadas
                            WHERE pedido=? AND cliente=? AND produto=? AND data_venda=?
                            LIMIT 1
                        """, (pedido_u, cliente_u, produto_u, data_venda))
                        exists = cur.fetchone()
                    except Exception:
                        exists = None  # se schema mudar, não bloqueia importação

                    if exists:
                        ignoradas += 1
                        continue

                    # âœ… Insere como NÃƒO usada por padrÃ£o
                    cur.execute("""
                        INSERT INTO vendas_importadas
                        (pedido, data_venda, cliente, nome_cliente, vendedor, produto, vr_total, qnt, cidade, valor_unitario, observacao, selecionada, usada, usada_em, codigo_programacao)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, 0, '', '')
                    """, (
                        pedido_u,
                        data_venda,
                        cliente_u,
                        self._norm(nome_cliente),
                        self._norm(vendedor),
                        produto_u,
                        float(vr_total or 0),
                        float(qnt or 0),
                        self._norm(cidade),
                        float(valor_unit or 0),
                        self._norm(obs),
                    ))
                    total += 1

            msg = f"Vendas importadas: {total}"
            if ignoradas:
                msg += f"\nIgnoradas (duplicadas/inválidas): {ignoradas}"

            if hasattr(self, "ent_busca"):
                try:
                    self.ent_busca.delete(0, "end")
                except Exception:
                    logging.debug("Falha ao limpar busca após importação", exc_info=True)

            messagebox.showinfo("OK", msg)
            self.carregar()

        except Exception as e:
            messagebox.showerror("ERRO", str(e))

    def carregar(self):
        self._ensure_vendas_usada_cols()

        busca = self._norm(self.ent_busca.get()) if hasattr(self, "ent_busca") else ""

        with get_db() as conn:
            cur = conn.cursor()
            if busca:
                cur.execute("""
                    SELECT id, selecionada, pedido, data_venda, cliente, nome_cliente, produto, vr_total, qnt, cidade, vendedor
                    FROM vendas_importadas
                    WHERE (IFNULL(usada,0)=0)
                      AND (
                        pedido LIKE ? OR cliente LIKE ? OR nome_cliente LIKE ? OR vendedor LIKE ? OR produto LIKE ?
                      )
                    ORDER BY id DESC
                """, (f"%{busca}%", f"%{busca}%", f"%{busca}%", f"%{busca}%", f"%{busca}%"))
            else:
                cur.execute("""
                    SELECT id, selecionada, pedido, data_venda, cliente, nome_cliente, produto, vr_total, qnt, cidade, vendedor
                    FROM vendas_importadas
                    WHERE (IFNULL(usada,0)=0)
                    ORDER BY id DESC
                """)
            rows = cur.fetchall() or []

        self.tree.delete(*self.tree.get_children())

        selected_count = 0
        for row in rows:
            rid = row[0]
            selecionada = 1 if row[1] == 1 else 0
            if selecionada:
                selected_count += 1

            sel = "✅" if selecionada else ""
            valor = row[7] if row[7] is not None else 0
            try:
                valor_txt = f"{float(valor):.3f}"
            except Exception:
                valor_txt = "0.000"

            qnt_val = row[8] if row[8] is not None else 0
            try:
                qnt_txt = f"{float(qnt_val):.3f}"
            except Exception:
                qnt_txt = "0.000"

            self.tree.insert("", "end", values=(
                rid, sel, row[2], row[3], row[4], row[5], row[6], valor_txt, qnt_txt, row[9], row[10]
            ))

        self.set_status(f"STATUS: {len(rows)} registros carregados (NÃO usadas)  Selecionadas: {selected_count}.")

    def toggle_selected(self, event=None):
        # ✅ só alterna se clicar em uma célula (evita bug ao clicar em cabeçalho)
        if event is not None:
            region = self.tree.identify("region", event.x, event.y)
            if region != "cell":
                return

        item = self.tree.selection()
        if not item:
            return

        vals = self.tree.item(item[0], "values")
        rid = vals[0]

        # ✅ Update em uma query (mais rápido e seguro)
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                UPDATE vendas_importadas
                SET selecionada = CASE WHEN selecionada=1 THEN 0 ELSE 1 END
                WHERE id=?
            """, (rid,))

        self.carregar()

    def set_all_selected(self, val):
        self._ensure_vendas_usada_cols()

        with get_db() as conn:
            cur = conn.cursor()
            # âœ… sÃ³ marca/desmarca as que nÃ£o foram usadas
            cur.execute("UPDATE vendas_importadas SET selecionada=? WHERE IFNULL(usada,0)=0", (int(val),))
        self.carregar()

    def limpar_tudo(self):
        if not messagebox.askyesno("CONFIRMAR", "Deseja apagar TODAS as vendas importadas?"):
            return

        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("DELETE FROM vendas_importadas")

        self.carregar()


# ==========================
# ===== FIM DA PARTE 4 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 5 (ATUALIZADA) =====
# ==========================

# =========================================================
# 5.0 PROGRAMACAO PAGE
# =========================================================
class ProgramacaoPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Programação")

        self._editing = None
        self._prog_cols_checked = False  # evita PRAGMA/ALTER toda hora
        self._vendas_cols_checked = False  # evita PRAGMA/ALTER toda hora
        self._equipe_display_map = {}

        # -------------------------
        # CabeÃ§alho (dados da programaÃ§Ã£o)
        # -------------------------
        card = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        card.grid(row=0, column=0, sticky="ew")
        card.grid_columnconfigure(7, weight=1)

        ttk.Label(card, text="Motorista", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w")
        self.cb_motorista = ttk.Combobox(card, state="readonly")
        self.cb_motorista.grid(row=1, column=0, sticky="ew", padx=6)

        ttk.Label(card, text="Veículo", style="CardLabel.TLabel").grid(row=0, column=1, sticky="w")
        self.cb_veiculo = ttk.Combobox(card, state="readonly")
        self.cb_veiculo.grid(row=1, column=1, sticky="ew", padx=6)

        ttk.Label(card, text="Equipe", style="CardLabel.TLabel").grid(row=0, column=2, sticky="w")
        self.cb_equipe = ttk.Combobox(card, state="readonly")
        self.cb_equipe.grid(row=1, column=2, sticky="ew", padx=6)

        ttk.Label(card, text="Local da Rota", style="CardLabel.TLabel").grid(row=0, column=3, sticky="w")
        self.cb_local_rota = ttk.Combobox(card, state="readonly", values=["SERRA", "SERTÃO"])
        self.cb_local_rota.grid(row=1, column=3, sticky="ew", padx=6)

        ttk.Label(card, text="KG Estimado", style="CardLabel.TLabel").grid(row=0, column=4, sticky="w")
        self.ent_kg = ttk.Entry(card, style="Field.TEntry")
        self.ent_kg.grid(row=1, column=4, sticky="ew", padx=6)

        ttk.Label(card, text="Adiantamento (R$)", style="CardLabel.TLabel").grid(row=0, column=5, sticky="w")
        self.ent_adiantamento_prog = ttk.Entry(card, style="Field.TEntry")
        self.ent_adiantamento_prog.grid(row=1, column=5, sticky="ew", padx=6)
        self.ent_adiantamento_prog.insert(0, "0,00")

        ttk.Label(card, text="Código", style="CardLabel.TLabel").grid(row=0, column=6, sticky="w")
        self.ent_codigo = ttk.Entry(card, style="Field.TEntry", state="readonly")
        self.ent_codigo.grid(row=1, column=6, sticky="ew", padx=6)

        # -------------------------
        # Itens (vendas / edição)
        # -------------------------
        card2 = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        card2.grid(row=1, column=0, sticky="nsew", pady=(14, 0))
        self.body.grid_rowconfigure(1, weight=1)

        card2.grid_columnconfigure(0, weight=1)
        card2.grid_rowconfigure(1, weight=1)

        top2 = ttk.Frame(card2, style="Card.TFrame")
        top2.grid(row=0, column=0, sticky="ew", pady=(0, 12))
        top2.grid_columnconfigure(10, weight=1)

        ttk.Button(
            top2,
            text="CARREGAR VENDAS SELECIONADAS",
            style="Warn.TButton",
            command=self.carregar_vendas_selecionadas
        ).grid(row=0, column=0, padx=6)

        ttk.Button(top2, text="INSERIR LINHA", style="Ghost.TButton",
                   command=self.inserir_linha).grid(row=0, column=1, padx=6)

        ttk.Button(top2, text="REMOVER LINHA", style="Danger.TButton",
                   command=self.remover_linha).grid(row=0, column=2, padx=6)

        ttk.Button(top2, text="LIMPAR ITENS", style="Danger.TButton",
                   command=self.limpar_itens).grid(row=0, column=3, padx=6)

        ttk.Button(
            top2,
            text="SALVAR PROGRAMAÇÃO",
            style="Primary.TButton",
            command=self.salvar_programacao
        ).grid(row=0, column=4, padx=6)

        ttk.Label(
            top2,
            text="Dica: duplo clique para editar Endereço/Caixas/KG/Preço/Vendedor/Pedido/Obs. ENTER confirma, ESC cancela.",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 8, "bold")
        ).grid(row=0, column=5, padx=12, sticky="w")

        cols = ["COD CLIENTE", "NOME CLIENTE", "PRODUTO", "ENDEREÇO", "CAIXAS", "KG", "PREÇO", "VENDEDOR", "PEDIDO", "OBS"]

        table_wrap = ttk.Frame(card2, style="Card.TFrame")
        table_wrap.grid(row=1, column=0, sticky="nsew")
        table_wrap.grid_columnconfigure(0, weight=1)
        table_wrap.grid_rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(table_wrap, columns=cols, show="headings")
        self.tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(table_wrap, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=0, column=1, sticky="ns")

        hsb = ttk.Scrollbar(table_wrap, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=hsb.set)
        hsb.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=160, minwidth=90, anchor="w")

        self.tree.column("ENDEREÇO", width=260, minwidth=180)
        self.tree.column("NOME CLIENTE", width=260, minwidth=160)
        self.tree.column("PRODUTO", width=160, minwidth=120)
        self.tree.column("PEDIDO", width=160, minwidth=120)
        self.tree.column("OBS", width=260, minwidth=140)
        self.tree.column("CAIXAS", width=90, anchor="center")
        self.tree.column("KG", width=90, anchor="center")
        self.tree.column("PREÇO", width=110, anchor="e")

        self.tree.bind("<Double-1>", self._start_edit_cell)
        self.tree.bind("<MouseWheel>", self._on_tree_scroll, add=True)
        self.tree.bind("<Button-4>", self._on_tree_scroll, add=True)  # linux
        self.tree.bind("<Button-5>", self._on_tree_scroll, add=True)  # linux

        enable_treeview_sorting(
            self.tree,
            numeric_cols={"CAIXAS", "KG"},
            money_cols={"PREÇO"},
            date_cols=set()
        )

        self.refresh_comboboxes()

    # -------------------------
    # Utilitários
    # -------------------------
    def _motorista_display(self, nome: str, codigo: str) -> str:
        nome = upper(nome)
        codigo = upper(codigo)
        if codigo:
            return f"{nome} ({codigo})"
        return nome

    def _parse_motorista_display(self, s: str):
        s = upper(s).strip()
        if not s:
            return "", ""
        m = re.match(r"^(.*)\s+\(([A-Z0-9_-]+)\)\s*$", s)
        if m:
            return upper(m.group(1)), upper(m.group(2))
        return upper(s), ""

    def _equipe_display(self, codigo: str, ajudante1: str, ajudante2: str) -> str:
        return format_equipe_nomes(ajudante1, ajudante2, codigo)

    def _parse_equipe_display(self, s: str) -> str:
        s = upper(s).strip()
        if not s:
            return ""
        try:
            return self._equipe_display_map.get(s, s)
        except Exception:
            return s

    def _resolve_equipe_ajudantes(self, equipe_codigo: str) -> str:
        return resolve_equipe_nomes(equipe_codigo)

    def _get_row_values(self, iid):
        vals = self.tree.item(iid, "values") or ("", "", "", "", "", "", "", "", "", "")
        vals = list(vals) + [""] * (10 - len(vals))
        return [str(v or "").strip() for v in vals[:10]]

    def _on_tree_scroll(self, event=None):
        if self._editing:
            self._commit_edit()

    def refresh_comboboxes(self):
        with get_db() as conn:
            cur = conn.cursor()

            valores_motoristas = []
            try:
                cur.execute("SELECT nome, codigo FROM motoristas ORDER BY nome")
                for r in cur.fetchall():
                    valores_motoristas.append(self._motorista_display(r[0], r[1]))
            except Exception:
                cur.execute("SELECT nome FROM motoristas ORDER BY nome")
                valores_motoristas = [r[0] for r in cur.fetchall()]

            self.cb_motorista["values"] = valores_motoristas

            cur.execute("SELECT placa FROM veiculos ORDER BY placa")
            self.cb_veiculo["values"] = [r[0] for r in cur.fetchall()]

            self._equipe_display_map = {}
            try:
                cur.execute("SELECT codigo, ajudante1, ajudante2 FROM equipes ORDER BY codigo")
                valores_equipes = []
                for r in cur.fetchall():
                    codigo = r[0] if r else ""
                    ajudante1 = r[1] if r else ""
                    ajudante2 = r[2] if r else ""
                    display = self._equipe_display(codigo, ajudante1, ajudante2)
                    if display:
                        valores_equipes.append(display)
                        if codigo:
                            self._equipe_display_map[upper(display)] = upper(codigo)
                self.cb_equipe["values"] = valores_equipes
            except Exception:
                cur.execute("SELECT codigo FROM equipes ORDER BY codigo")
                self.cb_equipe["values"] = [r[0] for r in cur.fetchall()]

    def on_show(self):
        self.set_status("STATUS: Carregue vendas e ajuste dados antes de salvar a programação.")
        self.refresh_comboboxes()

    # -------------------------
    # AÃƒÂ§ÃƒÂµes de itens
    # -------------------------
    def inserir_linha(self):
        self.tree.insert("", "end", values=("", "", "", "", "1", "0.00", "0.00", "", "", ""))
        items = self.tree.get_children()
        if items:
            self.tree.see(items[-1])

    def remover_linha(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("ATENÇÃO", "Selecione uma linha para remover.")
            return
        for iid in sel:
            self.tree.delete(iid)

    def limpar_itens(self):
        self.tree.delete(*self.tree.get_children())

    def carregar_vendas_selecionadas(self):
        """
        ✅ Melhorado: carrega tudo em 1 query (sem N+1).
        Também evita duplicar por (pedido + cod_cliente).
        """
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT
                    v.pedido,
                    v.data_venda,
                    v.cliente AS cod_cliente,
                    v.nome_cliente,
                    v.vendedor,
                    v.produto,
                    v.vr_total,
                    v.qnt,
                    v.valor_unitario,
                    v.observacao,
                    v.cidade,
                    COALESCE(c.endereco, '') AS endereco
                FROM vendas_importadas v
                LEFT JOIN clientes c
                       ON c.cod_cliente = v.cliente
                WHERE v.selecionada = 1
                ORDER BY v.id ASC
            """)
            vendas = cur.fetchall() or []

        self.limpar_itens()

        seen = set()
        for (pedido, data_venda, cod_cliente, nome_cliente, vendedor, produto, vr_total, qnt, valor_unit, obs, cidade, endereco) in vendas:
            cod_cliente = upper(cod_cliente)
            pedido_u = upper(pedido)

            key = (pedido_u, cod_cliente)
            if key in seen:
                continue
            seen.add(key)

            caixas = 1
            kg = 0.0
            vr_total_f = safe_float(vr_total, 0.0)
            qnt_f = safe_float(qnt, 0.0)
            valor_unit_f = safe_float(valor_unit, 0.0)
            if qnt_f > 0:
                preco = vr_total_f / qnt_f
            else:
                preco = valor_unit_f
            cidade_txt = upper(cidade) if cidade else ""
            endereco_txt = upper(endereco) if endereco else ""
            endereco_final = cidade_txt if cidade_txt else endereco_txt
            observacao = upper(obs) if obs else ""

            if obs:
                low = str(obs).lower()
                m = re.search(r"(\d+[\,\.]?\d*)\s*kg", low)
                if m:
                    kg = safe_float(m.group(1), 0.0)

                m2 = re.search(r"(\d+)\s*cx", low)
                if m2:
                    caixas = safe_int(m2.group(1), 1)

            self.tree.insert("", "end", values=(
                cod_cliente,
                upper(nome_cliente),
                upper(produto),
                endereco_final,
                str(caixas),
                f"{float(kg):.2f}",
                f"{float(preco):.2f}",
                upper(vendedor),
                upper(pedido),
                observacao
            ))

        self.set_status(f"STATUS: Itens carregados: {len(self.tree.get_children())} vendas selecionadas. (edite antes de salvar)")

    # -------------------------
    # EdiÃ§Ã£o de cÃ©lula (com regras)
    # -------------------------
    def _start_edit_cell(self, event=None):
        if self._editing:
            self._commit_edit()

        region = self.tree.identify("region", event.x, event.y)
        if region != "cell":
            return

        row_id = self.tree.identify_row(event.y)
        col_id = self.tree.identify_column(event.x)
        if not row_id or not col_id:
            return

        col_index = int(col_id.replace("#", "")) - 1
        cols = list(self.tree["columns"])

        if col_index < 0 or col_index >= len(cols):
            return

        col_name = cols[col_index]

        # ✅ Regra: só permite editar essas colunas
        editable = {"ENDEREÇO", "CAIXAS", "KG", "PREÇO", "VENDEDOR", "PEDIDO", "OBS"}
        if col_name not in editable:
            return

        bbox = self.tree.bbox(row_id, col_id)
        if not bbox:
            return

        vals = self._get_row_values(row_id)
        value = vals[col_index]

        x, y, w, h = bbox
        entry = ttk.Entry(self.tree, style="Field.TEntry")
        entry.place(x=x, y=y, width=w, height=h)
        entry.insert(0, value)
        entry.focus_set()
        entry.selection_range(0, "end")

        entry.bind("<Return>", lambda e: self._commit_edit())
        entry.bind("<Escape>", lambda e: self._cancel_edit())
        entry.bind("<FocusOut>", lambda e: self._commit_edit())

        self._editing = (row_id, col_index, col_name, entry)

    def _commit_edit(self):
        if not self._editing:
            return

        row_id, col_index, col_name, entry = self._editing
        new_value = str(entry.get() or "").strip()

        # Ã¢Å“â€¦ ValidaÃƒÂ§ÃƒÂ£o por tipo
        if col_name == "CAIXAS":
            v = safe_int(new_value, 0)
            if v < 0:
                v = 0
            new_value = str(v)

        elif col_name in {"KG", "PREÇO"}:
            v = safe_float(new_value, 0.0)
            if v < 0:
                v = 0.0
            new_value = f"{v:.2f}"

        vals = self._get_row_values(row_id)
        vals[col_index] = new_value
        self.tree.item(row_id, values=tuple(vals))

        try:
            entry.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        self._editing = None

    def _cancel_edit(self):
        if not self._editing:
            return
        _, _, _, entry = self._editing
        try:
            entry.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        self._editing = None

    # -------------------------
    # Compatibilidade API / DB
    # -------------------------
    def _ensure_prog_columns_for_api(self, cur):
        # Garante colunas que a API usa (sem quebrar bases antigas)
        try:
            cur.execute("PRAGMA table_info(programacoes)")
            cols = [upper(r[1]).lower() for r in cur.fetchall()]
        except Exception:
            cols = []

        def add_col(name: str, coltype: str):
            if name.lower() not in cols:
                try:
                    cur.execute(f"ALTER TABLE programacoes ADD COLUMN {name} {coltype}")
                    cols.append(name.lower())
                except Exception as e:
                    logging.exception("Falha ao adicionar coluna programacoes.%s: %s", name, e)

        add_col("motorista_id", "INTEGER")
        add_col("codigo", "TEXT")
        add_col("data", "TEXT")
        add_col("total_caixas", "INTEGER DEFAULT 0")
        add_col("quilos", "REAL DEFAULT 0")
        add_col("saida_dt", "TEXT")
        add_col("chegada_dt", "TEXT")

    def _ensure_vendas_usada_cols(self, cur):
        """Garante colunas para bloquear reutilização (compatível com bases antigas)."""
        try:
            cur.execute("PRAGMA table_info(vendas_importadas)")
            cols = [str(r[1]).lower() for r in cur.fetchall()]
        except Exception:
            cols = []

        def add_col(name: str, coltype: str):
            if name.lower() not in cols:
                try:
                    cur.execute(f"ALTER TABLE vendas_importadas ADD COLUMN {name} {coltype}")
                    cols.append(name.lower())
                except Exception as e:
                    logging.exception("Falha ao adicionar coluna vendas_importadas.%s: %s", name, e)

        add_col("usada", "INTEGER DEFAULT 0")
        add_col("usada_em", "TEXT")
        add_col("codigo_programacao", "TEXT")

    def salvar_programacao(self):
        if self._editing:
            self._commit_edit()

        motorista_sel = upper(self.cb_motorista.get()).strip()
        motorista_nome, motorista_codigo = self._parse_motorista_display(motorista_sel)

        veiculo = upper(self.cb_veiculo.get()).strip()
        equipe = self._parse_equipe_display(self.cb_equipe.get())
        local_rota = upper(self.cb_local_rota.get()).strip()
        kg_estimado = safe_float(self.ent_kg.get(), 0.0)
        adiantamento_val = safe_money(self.ent_adiantamento_prog.get(), 0.0)
        if adiantamento_val < 0:
            messagebox.showwarning("ATENÇÃO", "Adiantamento não pode ser negativo.")
            return

        if not motorista_nome or not veiculo:
            messagebox.showwarning("ATENÇÃO", "Selecione Motorista e Veículo.")
            return
        if local_rota not in {"SERRA", "SERTÃO"}:
            messagebox.showwarning("ATENÇÃO", "Selecione o Local da Rota (SERRA ou SERTÃO).")
            return

        itens = []
        for iid in self.tree.get_children():
            itens.append(self._get_row_values(iid))

        if not itens:
            messagebox.showwarning("ATENÇÃO", "Carregue itens (vendas selecionadas) antes de salvar.")
            return

        # Ã¢Å“â€¦ validaÃƒÂ§ÃƒÂ£o mÃƒÂ­nima por linha (seguranÃƒÂ§a)
        for v in itens:
            cod_cliente = v[0]
            nome_cliente = v[1]
            if not str(cod_cliente).strip() or not str(nome_cliente).strip():
                messagebox.showwarning("ATENÇÃO", "Há linhas sem COD CLIENTE ou NOME CLIENTE. Corrija antes de salvar.")
                return

        codigo = None
        data_criacao = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Totais (compatibilidade API)
        try:
            total_caixas = sum(safe_int(v[4], 0) for v in itens)
        except Exception:
            total_caixas = 0
        try:
            total_quilos = round(sum(safe_float(v[5], 0.0) for v in itens), 2)
        except Exception:
            total_quilos = 0.0

        motorista_id = None

        try:
            with get_db() as conn:
                cur = conn.cursor()

                if not self._prog_cols_checked:
                    self._ensure_prog_columns_for_api(cur)
                    self._prog_cols_checked = True

                if not self._vendas_cols_checked:
                    self._ensure_vendas_usada_cols(cur)
                    self._vendas_cols_checked = True

                # Valida capacidade do veículo (CX) antes de salvar programação.
                cap_col = "capacidade_cx"
                try:
                    cur.execute("PRAGMA table_info(veiculos)")
                    cols_vei = [str(r[1]).lower() for r in cur.fetchall()]
                    if "capacidade_cx" not in cols_vei and "capacidade_c" in cols_vei:
                        cap_col = "capacidade_c"
                except Exception:
                    cap_col = "capacidade_cx"

                try:
                    cur.execute(
                        f"SELECT {cap_col} FROM veiculos WHERE UPPER(placa)=UPPER(?) LIMIT 1",
                        (veiculo,),
                    )
                    vrow = cur.fetchone()
                except Exception:
                    vrow = None

                if not vrow:
                    messagebox.showwarning(
                        "ATENÃ‡ÃƒO",
                        f"Veículo não encontrado no cadastro: {veiculo}."
                    )
                    return

                capacidade_cx = safe_int(vrow[0], -1)
                if capacidade_cx < 0:
                    messagebox.showwarning(
                        "ATENÃ‡ÃƒO",
                        f"Capacidade (CX) inválida para o veículo {veiculo}. Ajuste no cadastro de veículos."
                    )
                    return

                if total_caixas > capacidade_cx:
                    messagebox.showwarning(
                        "ATENÃ‡ÃƒO",
                        f"Capacidade excedida para o veículo {veiculo}.\n\n"
                        f"Caixas na programação: {total_caixas}\n"
                        f"Capacidade do veículo: {capacidade_cx}"
                    )
                    return

                # Resolve motorista_id priorizando codigo, depois nome
                try:
                    if motorista_codigo:
                        cur.execute("SELECT id FROM motoristas WHERE UPPER(codigo)=UPPER(?) LIMIT 1", (motorista_codigo,))
                    else:
                        cur.execute("SELECT id FROM motoristas WHERE UPPER(nome)=UPPER(?) LIMIT 1", (motorista_nome,))
                    r = cur.fetchone()
                    if r:
                        motorista_id = safe_int(r[0], 0)
                except Exception:
                    motorista_id = None

                # Insert compatível (tenta gerar código único)
                inserted = False
                for _ in range(5):
                    codigo = generate_program_code()
                    try:
                        cur.execute(
                            "SELECT 1 FROM programacoes WHERE codigo_programacao=? LIMIT 1",
                            (codigo,)
                        )
                        if cur.fetchone():
                            continue
                    except Exception:
                        logging.debug("Falha ignorada", exc_info=True)
                    try:
                        cur.execute("""
                            INSERT INTO programacoes (
                                codigo_programacao, codigo, data, data_criacao,
                                motorista, motorista_id, veiculo, equipe,
                                kg_estimado, status, total_caixas, quilos
                            )
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'ATIVA', ?, ?)
                        """, (
                            codigo, codigo, data_criacao, data_criacao,
                            motorista_nome, safe_int(motorista_id, 0), veiculo, equipe,
                            kg_estimado, total_caixas, total_quilos
                        ))
                        inserted = True
                        break
                    except sqlite3.IntegrityError:
                        continue
                    except Exception:
                        try:
                            cur.execute("""
                                INSERT INTO programacoes (codigo_programacao, data_criacao, motorista, veiculo, equipe, kg_estimado, status)
                                VALUES (?, ?, ?, ?, ?, ?, 'ATIVA')
                            """, (codigo, data_criacao, motorista_nome, veiculo, equipe, kg_estimado))
                            inserted = True
                            break
                        except sqlite3.IntegrityError:
                            continue

                if not inserted:
                    raise sqlite3.IntegrityError("Falha ao gerar código único para programação.")

                # Salva local da rota com compatibilidade de bases.
                try:
                    cur.execute("PRAGMA table_info(programacoes)")
                    cols_prog = [str(r[1]).lower() for r in cur.fetchall()]
                    if "tipo_rota" in cols_prog:
                        cur.execute(
                            "UPDATE programacoes SET tipo_rota=? WHERE codigo_programacao=?",
                            (local_rota, codigo),
                        )
                    if "local_rota" in cols_prog:
                        cur.execute(
                            "UPDATE programacoes SET local_rota=? WHERE codigo_programacao=?",
                            (local_rota, codigo),
                        )
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

                # Salva adiantamento com compatibilidade entre colunas novas/legadas.
                try:
                    cur.execute("PRAGMA table_info(programacoes)")
                    cols_prog = [str(r[1]).lower() for r in cur.fetchall()]
                    if "adiantamento" in cols_prog:
                        cur.execute(
                            "UPDATE programacoes SET adiantamento=? WHERE codigo_programacao=?",
                            (adiantamento_val, codigo),
                        )
                    if "adiantamento_rota" in cols_prog:
                        cur.execute(
                            "UPDATE programacoes SET adiantamento_rota=? WHERE codigo_programacao=?",
                            (adiantamento_val, codigo),
                        )
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

                # garante prestação pendente quando coluna existir
                try:
                    if db_has_column(cur, "programacoes", "prestacao_status"):
                        cur.execute(
                            "UPDATE programacoes SET prestacao_status='PENDENTE' WHERE codigo_programacao=?",
                            (codigo,)
                        )
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

                # Itens
                for (cod_cliente, nome_cliente, produto, endereco, caixas, kg, preco, vendedor, pedido, obs) in itens:
                    cur.execute("""
                        INSERT INTO programacao_itens (
                            codigo_programacao, cod_cliente, nome_cliente,
                            qnt_caixas, kg, preco, endereco, vendedor, pedido, produto
                        )
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """, (
                        codigo,
                        upper(cod_cliente),
                        upper(nome_cliente),
                        safe_int(caixas, 0),
                        safe_float(kg, 0.0),
                        safe_float(preco, 0.0),
                        upper(endereco),
                        upper(vendedor),
                        upper(pedido),
                        upper(produto)
                    ))

                    # Mantém clientes atualizados (compatível com bases antigas)
                    if cod_cliente and nome_cliente:
                        try:
                            cur.execute("""
                                INSERT INTO clientes (cod_cliente, nome_cliente, endereco, telefone, vendedor)
                                VALUES (?, ?, ?, '', ?)
                                ON CONFLICT(cod_cliente) DO UPDATE SET
                                    nome_cliente=excluded.nome_cliente,
                                    endereco=excluded.endereco,
                                    vendedor=excluded.vendedor
                            """, (upper(cod_cliente), upper(nome_cliente), upper(endereco), upper(vendedor)))
                        except Exception:
                            cur.execute("""
                                INSERT INTO clientes (cod_cliente, nome_cliente, endereco, telefone)
                                VALUES (?, ?, ?, '')
                                ON CONFLICT(cod_cliente) DO UPDATE SET
                                    nome_cliente=excluded.nome_cliente,
                                    endereco=excluded.endereco
                            """, (upper(cod_cliente), upper(nome_cliente), upper(endereco)))

                # =========================================================
                # ✅ REGRA NOVA: Vendas selecionadas viram "usadas" e somem
                # =========================================================
                try:
                    cur.execute("""
                        UPDATE vendas_importadas
                        SET
                            usada = 1,
                            usada_em = ?,
                            codigo_programacao = ?,
                            selecionada = 0
                        WHERE selecionada = 1
                    """, (data_criacao, codigo))
                except Exception:
                    # fallback: pelo menos zera selecionada se algo der ruim
                    cur.execute("UPDATE vendas_importadas SET selecionada=0 WHERE selecionada=1")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao salvar programação: {str(e)}")
            return

        self.ent_codigo.config(state="normal")
        self.ent_codigo.delete(0, "end")
        self.ent_codigo.insert(0, codigo)
        self.ent_codigo.config(state="readonly")

        messagebox.showinfo("OK", f"Programação salva: {codigo} (ABERTA/ATIVA)")
        self.set_status(f"STATUS: Programação salva: {codigo} (ABERTA/ATIVA)")

        self.app.refresh_programacao_comboboxes()

        if messagebox.askyesno("PDF", "Deseja gerar o PDF da programação agora?\n\n(Pronto para impressão A4)"):
            self.gerar_pdf_programacao_salva(codigo, motorista_nome, veiculo, equipe, kg_estimado)

        self.limpar_itens()

    def gerar_pdf_programacao_salva(self, codigo, motorista, veiculo, equipe, kg_estimado):
        if not require_reportlab():
            return
        path = filedialog.asksaveasfilename(
            title="Salvar PDF da Programação",
            defaultextension=".pdf",
            filetypes=[("PDF", "*.pdf")],
            initialfile=f"PROGRAMACAO_{codigo}.pdf"
        )
        if not path:
            return

        itens = []
        for iid in self.tree.get_children():
            itens.append(self._get_row_values(iid))

        if not itens:
            messagebox.showwarning("ATENÇÃO", "Sem itens na programação.")
            return

        try:
            c = canvas.Canvas(path, pagesize=A4)
            w, h = A4

            y = h - 60
            c.setFont("Helvetica-Bold", 14)
            c.drawString(40, y, f"PROGRAMAÇÃO: {codigo}")
            y -= 22

            c.setFont("Helvetica", 10)
            c.drawString(40, y, f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
            y -= 16
            equipe_txt = self._resolve_equipe_ajudantes(equipe)
            c.drawString(40, y, f"Motorista: {motorista}  |  Veículo: {veiculo}  |  Equipe: {equipe_txt}")
            y -= 16
            c.drawString(40, y, f"KG Estimado: {kg_estimado:.2f}")
            y -= 24

            c.setFont("Helvetica-Bold", 9)
            c.drawString(40, y, "CLIENTE / ENDEREÇO")
            c.drawString(320, y, "CX")
            c.drawString(350, y, "KG")
            c.drawString(390, y, "PREÇO")
            c.drawString(440, y, "VENDEDOR")
            c.drawString(520, y, "PEDIDO")
            y -= 10
            c.line(40, y, w - 40, y)
            y -= 14

            c.setFont("Helvetica", 8)
            for (cod_cliente, nome_cliente, produto, endereco, caixas, kg, preco, vendedor, pedido, obs) in itens:
                # EspaÃƒÆ’Ã‚Â§o mÃƒÆ’Ã‚Â­nimo para 2 linhas (cliente + endereÃƒÆ’Ã‚Â§o) + espaÃƒÆ’Ã‚Â§o extra
                if y < 90:
                    c.showPage()
                    y = h - 60
                    c.setFont("Helvetica", 8)

                linha_cliente = f"{cod_cliente} - {nome_cliente}"
                if len(linha_cliente) > 65:
                    linha_cliente = linha_cliente[:65] + "..."

                c.drawString(40, y, linha_cliente)
                c.drawRightString(340, y, str(caixas))
                c.drawRightString(372, y, str(kg))
                c.drawRightString(425, y, str(preco))
                c.drawString(440, y, str(vendedor)[:10])
                c.drawString(520, y, str(pedido)[:18])
                y -= 12

                # EndereÃ§o em linha separada (mais organizado)
                if endereco:
                    end_line = str(endereco)
                    if len(end_line) > 90:
                        end_line = end_line[:90] + "..."
                    c.setFont("Helvetica-Oblique", 8)
                    c.drawString(50, y, end_line)
                    c.setFont("Helvetica", 8)
                    y -= 10

                if obs:
                    obs_line = f"OBS: {str(obs)}"
                    if len(obs_line) > 110:
                        obs_line = obs_line[:110] + "..."
                    c.setFont("Helvetica-Oblique", 8)
                    c.drawString(50, y, obs_line)
                    c.setFont("Helvetica", 8)
                    y -= 10

                # EspaÃ§o extra entre clientes
                y -= 4

            c.save()
            messagebox.showinfo("OK", "PDF gerado com sucesso! (A4 pronto para impressão)")

        except Exception as e:
            messagebox.showerror("ERRO", str(e))


# ==========================
# ===== FIM DA PARTE 5 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 6 (ATUALIZADA) =====
# ==========================

# =========================================================
# 6.0 FUNÇÃO SIMPLE INPUT (antes de RecebimentosPage)
# =========================================================
def simple_input(title, prompt, master=None, initial="", allow_empty=True, max_len=200):
    """
    Janela de diálogo simples para entrada de texto.

    Compatível com seu uso atual:
        simple_input("Título", "Pergunta?")

    Extras opcionais (não quebram):
        master=app  -> mantém a janela presa ao app
        initial="..." -> valor inicial
        allow_empty=False -> obriga preencher
        max_len -> limita tamanho (segurança)
    """
    # Se não passar master, tenta usar a janela root atual
    if master is None:
        try:
            master = tk._default_root
        except Exception:
            master = None

    win = tk.Toplevel(master) if master else tk.Toplevel()
    win.title(title)
    win.geometry("460x190")
    win.resizable(False, False)
    win.grab_set()

    # Melhor UX: janela modal ligada ao app
    if master:
        try:
            win.transient(master)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    # Layout moderno (card)
    outer = ttk.Frame(win, style="Content.TFrame", padding=14)
    outer.pack(fill="both", expand=True)

    card = ttk.Frame(outer, style="Card.TFrame", padding=14)
    card.pack(fill="both", expand=True)
    card.grid_columnconfigure(0, weight=1)

    ttk.Label(card, text=title, style="CardTitle.TLabel").grid(row=0, column=0, sticky="w")
    ttk.Label(card, text=prompt, style="CardLabel.TLabel", justify="left").grid(row=1, column=0, sticky="w", pady=(8, 8))

    ent = ttk.Entry(card, style="Field.TEntry")
    ent.grid(row=2, column=0, sticky="ew")
    if initial:
        ent.insert(0, str(initial)[:max_len])
        ent.selection_range(0, "end")
    ent.focus_set()

    result = {"value": ""}

    def _get_value():
        v = str(ent.get() or "")
        v = v.strip()
        if max_len and len(v) > max_len:
            v = v[:max_len]
        return v

    def ok():
        v = _get_value()
        if (not allow_empty) and (not v):
            messagebox.showwarning("ATENÇÃO", "Preencha o campo antes de confirmar.")
            ent.focus_set()
            return
        result["value"] = v
        try:
            win.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def cancel():
        result["value"] = ""
        try:
            win.destroy()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    # Se fechar no X, sempre cancela
    win.protocol("WM_DELETE_WINDOW", cancel)

    btns = ttk.Frame(card, style="Card.TFrame")
    btns.grid(row=3, column=0, sticky="ew", pady=(14, 0))
    btns.grid_columnconfigure(0, weight=1)

    left = ttk.Frame(btns, style="Card.TFrame")
    left.grid(row=0, column=0, sticky="w")

    ttk.Button(left, text="CONFIRMAR", style="Primary.TButton", command=ok).pack(side="left")
    ttk.Button(left, text="CANCELAR", style="Ghost.TButton", command=cancel).pack(side="left", padx=8)

    # Atalhos
    win.bind("<Return>", lambda e: ok())
    win.bind("<Escape>", lambda e: cancel())

    # Centraliza na tela (simples e sem depender de libs)
    try:
        win.update_idletasks()
        w = win.winfo_width()
        h = win.winfo_height()
        sw = win.winfo_screenwidth()
        sh = win.winfo_screenheight()
        x = int((sw / 2) - (w / 2))
        y = int((sh / 2) - (h / 2))
        win.geometry(f"{w}x{h}+{x}+{y}")
    except Exception:
        logging.debug("Falha ignorada", exc_info=True)

    win.wait_window()
    return result["value"]

# ==========================
# ===== FIM DA PARTE 6 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INICIO DA PARTE 6B (ATUALIZADA) =====
# ==========================

class RecebimentosPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Recebimentos")

        self._current_prog = ""
        self._selected_cliente = None
        self._sort_reverse = False
        self._current_sort_column = None
        self._is_collapsed_after_close = False  # modo oculto apos finalizar/salvar
        self._rota_atual = ""

        # -------------------------
        # Card superior (programacao + dados de rota)
        # -------------------------
        self.card = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        self.card.grid(row=0, column=0, sticky="ew")
        self.body.grid_columnconfigure(0, weight=1)

        for i in range(0, 20):
            self.card.grid_columnconfigure(i, weight=0)
        # Coluna do texto informativo pode expandir, sem empurrar botÃ£o
        self.card.grid_columnconfigure(2, weight=1)
        # EspaÃ§ador final para absorver resize
        self.card.grid_columnconfigure(11, weight=1)

        ttk.Label(self.card, text="Programacao (pendente)", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w")
        self.cb_prog = ttk.Combobox(self.card, state="readonly", width=24)
        self.cb_prog.grid(row=1, column=0, sticky="w", padx=(0, 10))

        ttk.Button(self.card, text="CARREGAR", style="Ghost.TButton", command=self.carregar_programacao)\
            .grid(row=1, column=1, padx=(0, 14))

        self.lbl_motorista_info = ttk.Label(
            self.card,
            text="Motorista: ?",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 9, "bold")
        )
        self.lbl_motorista_info.grid(row=1, column=2, sticky="w", padx=(8, 8))

        self.lbl_veiculo_info = ttk.Label(
            self.card,
            text="Veiculo: ?",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 9, "bold")
        )
        self.lbl_veiculo_info.grid(row=1, column=3, sticky="w", padx=(8, 8))

        self.lbl_equipe_info = ttk.Label(
            self.card,
            text="Equipe: ?",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 9, "bold")
        )
        self.lbl_equipe_info.grid(row=1, column=4, sticky="w", padx=(8, 12))

        self.lbl_rota_info = ttk.Label(
            self.card,
            text="Rota: -",
            background="white",
            foreground="#6B7280",
            font=("Segoe UI", 9, "bold")
        )
        self.lbl_rota_info.grid(row=1, column=5, sticky="w", padx=(8, 12))

        ttk.Label(self.card, text="Diaria Motorista (R$)", style="CardLabel.TLabel").grid(row=0, column=6, sticky="w")
        self.ent_diaria_motorista = ttk.Entry(self.card, style="Field.TEntry", width=12)
        self.ent_diaria_motorista.grid(row=1, column=6, sticky="w", padx=(6, 10))
        self.ent_diaria_motorista.insert(0, "0,00")
        self._bind_money_entry(self.ent_diaria_motorista)

        ttk.Label(self.card, text="Saida (data)", style="CardLabel.TLabel").grid(row=0, column=7, sticky="w")
        self.ent_data_saida = ttk.Entry(self.card, style="Field.TEntry", width=12)
        self.ent_data_saida.grid(row=1, column=7, sticky="w", padx=(6, 10))

        ttk.Label(self.card, text="Saida (hora)", style="CardLabel.TLabel").grid(row=0, column=8, sticky="w")
        self.ent_hora_saida = ttk.Entry(self.card, style="Field.TEntry", width=9)
        self.ent_hora_saida.grid(row=1, column=8, sticky="w", padx=(6, 10))

        ttk.Label(self.card, text="Chegada (data)", style="CardLabel.TLabel").grid(row=0, column=9, sticky="w")
        self.ent_data_chegada = ttk.Entry(self.card, style="Field.TEntry", width=12)
        self.ent_data_chegada.grid(row=1, column=9, sticky="w", padx=(6, 10))

        ttk.Label(self.card, text="Chegada (hora)", style="CardLabel.TLabel").grid(row=0, column=10, sticky="w")
        self.ent_hora_chegada = ttk.Entry(self.card, style="Field.TEntry", width=9)
        self.ent_hora_chegada.grid(row=1, column=10, sticky="w", padx=(6, 10))

        actions = ttk.Frame(self.card, style="Card.TFrame")
        actions.grid(row=2, column=0, columnspan=15, sticky="ew", pady=(8, 0))
        actions.grid_columnconfigure(0, weight=1)

        ttk.Button(actions, text="SALVAR DADOS DA ROTA", style="Primary.TButton", command=self.salvar_dados_rota)\
            .grid(row=0, column=1, sticky="e", padx=(0, 8))

        ttk.Button(
            actions,
            text="PROXIMO (DESPESAS)",
            style="Warn.TButton",
            command=self._ir_para_despesas
        ).grid(row=0, column=2, sticky="e")

        # -------------------------
        # Card principal (tabela + filtros + formulario)
        # -------------------------
        self.card2 = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        self.card2.grid(row=1, column=0, sticky="nsew", pady=(14, 0))
        self.body.grid_rowconfigure(1, weight=1)

        self.card2.grid_columnconfigure(0, weight=1)
        self.card2.grid_rowconfigure(2, weight=1)

        top2 = ttk.Frame(self.card2, style="Card.TFrame")
        top2.grid(row=0, column=0, sticky="ew")
        top2.grid_columnconfigure(30, weight=1)

        ttk.Button(top2, text="INSERIR CLIENTE MANUAL", style="Warn.TButton", command=self.inserir_cliente_manual)\
            .grid(row=0, column=0, padx=6)

        ttk.Button(top2, text="ZERAR RECEBIMENTO", style="Danger.TButton", command=self.zerar_recebimento)\
            .grid(row=0, column=1, padx=6)

        ttk.Button(top2, text="FINALIZAR PRESTACAO", style="Primary.TButton", command=self.finalizar_prestacao)\
            .grid(row=0, column=2, padx=6)

        self.lbl_total = ttk.Label(
            top2,
            text="TOTAL RECEBIDO: R$ 0,00",
            background="white",
            foreground="#111827",
            font=("Segoe UI", 10, "bold")
        )
        self.lbl_total.grid(row=0, column=30, sticky="e", padx=6)

        ttk.Separator(self.card2).grid(row=1, column=0, sticky="ew", pady=10)

        cols = ["COD", "CLIENTE", "VALOR", "FORMA", "OBS", "DATA REGISTRO"]

        table_wrap = ttk.Frame(self.card2, style="Card.TFrame")
        table_wrap.grid(row=2, column=0, sticky="nsew")
        table_wrap.grid_columnconfigure(0, weight=1)
        table_wrap.grid_rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(table_wrap, columns=cols, show="headings")
        self.tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(table_wrap, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        vsb.grid(row=0, column=1, sticky="ns")

        hsb = ttk.Scrollbar(table_wrap, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=hsb.set)
        hsb.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=150, minwidth=90, anchor="w")

        self.tree.column("COD", width=90, minwidth=80, anchor="center")
        self.tree.column("CLIENTE", width=320, minwidth=220)
        self.tree.column("VALOR", width=120, minwidth=90, anchor="e")
        self.tree.column("FORMA", width=110, minwidth=90, anchor="center")
        self.tree.column("OBS", width=260, minwidth=140)
        self.tree.column("DATA REGISTRO", width=160, minwidth=130, anchor="center")

        for col in cols:
            self.tree.heading(col, command=lambda c=col: self.sort_by_column(c))

        try:
            enable_treeview_sorting(
                self.tree,
                numeric_cols=set(),
                money_cols={"VALOR"},
                date_cols={"DATA REGISTRO"}
            )
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        self.tree.bind("<<TreeviewSelect>>", self._on_select_row)

        # -------------------------
        # Formulário de recebimento
        # -------------------------
        frm = ttk.Frame(self.card2, style="Card.TFrame")
        frm.grid(row=3, column=0, sticky="ew", pady=(12, 0))
        frm.grid_columnconfigure(4, weight=1)

        ttk.Label(frm, text="Cód Cliente", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w")
        self.ent_cod = ttk.Entry(frm, style="Field.TEntry", width=12)
        self.ent_cod.grid(row=1, column=0, sticky="w", padx=6)

        ttk.Label(frm, text="Nome", style="CardLabel.TLabel").grid(row=0, column=1, sticky="w")
        self.ent_nome = ttk.Entry(frm, style="Field.TEntry", width=28)
        self.ent_nome.grid(row=1, column=1, sticky="w", padx=6)

        ttk.Label(frm, text="Valor", style="CardLabel.TLabel").grid(row=0, column=2, sticky="w")
        self.ent_valor = ttk.Entry(frm, style="Field.TEntry", width=12)
        self.ent_valor.grid(row=1, column=2, sticky="w", padx=6)
        self.ent_valor.bind("<Return>", lambda e: self.salvar_recebimento())
        self._bind_money_entry(self.ent_valor)

        ttk.Label(frm, text="Forma", style="CardLabel.TLabel").grid(row=0, column=3, sticky="w")
        self.cb_forma = ttk.Combobox(
            frm,
            state="readonly",
            width=14,
            values=["DINHEIRO", "PIX", "CARTAO", "BOLETO", "OUTRO"]
        )
        self.cb_forma.grid(row=1, column=3, sticky="w", padx=6)
        self.cb_forma.set("DINHEIRO")

        ttk.Label(frm, text="Observação", style="CardLabel.TLabel").grid(row=0, column=4, sticky="w")
        self.ent_obs = ttk.Entry(frm, style="Field.TEntry", width=40)
        self.ent_obs.grid(row=1, column=4, sticky="ew", padx=6)

        ttk.Button(frm, text="SALVAR RECEBIMENTO", style="Primary.TButton", command=self.salvar_recebimento)\
            .grid(row=1, column=5, sticky="e", padx=(12, 0))

        # ✅ TROCA: no lugar do Excel, botão IMPRIMIR PDF
        ttk.Button(frm, text="IMPRIMIR PDF", style="Warn.TButton", command=self.imprimir_pdf)\
            .grid(row=1, column=6, sticky="e", padx=6)

        # Por padrÃ£o: COD/NOME nÃ£o editÃ¡veis
        self._set_cliente_fields_readonly(True)

        # -------------------------
        # Painel Ã¢â‚¬Å“modo ocultoÃ¢â‚¬Â (apÃƒÂ³s finalizar prestaÃƒÂ§ÃƒÂ£o)
        # -------------------------
        self._wrap_collapsed = ttk.Frame(self.body, style="Card.TFrame", padding=14)
        self._wrap_collapsed.grid(row=2, column=0, sticky="ew", pady=(14, 0))
        self._wrap_collapsed.grid_remove()

        self._lbl_collapsed = ttk.Label(
            self._wrap_collapsed,
            text="PRESTAÇÃO FECHADA / SALVA.\nCabeçalhos e tabela foram ocultados.",
            background="white",
            foreground="#111827",
            font=("Segoe UI", 10, "bold"),
            justify="left"
        )
        self._lbl_collapsed.grid(row=0, column=0, sticky="w")

        btns = ttk.Frame(self._wrap_collapsed, style="Card.TFrame")
        btns.grid(row=1, column=0, sticky="ew", pady=(6, 0))
        btns.grid_columnconfigure(10, weight=1)

        ttk.Button(btns, text="IMPRIMIR PDF", style="Warn.TButton", command=self.imprimir_pdf)\
            .grid(row=0, column=0, padx=6, sticky="w")

        ttk.Button(btns, text="MOSTRAR DADOS (CONSULTA)", style="Ghost.TButton", command=self._expand_view)\
            .grid(row=0, column=1, padx=6, sticky="w")

        ttk.Button(btns, text="LIMPAR / NOVA PROGRAMAÇÃO", style="Primary.TButton", command=self._reset_view)\
            .grid(row=0, column=2, padx=6, sticky="w")

        self.refresh_comboboxes()
        self.carregar_tabela_vazia()

    # =========================
    # Modos de visualização (ocultar/mostrar)
    # =========================
    def _collapse_view(self):
        """Oculta cabeçalhos e dados de tabela (mantém imprimir/limpar)."""
        self._is_collapsed_after_close = True
        try:
            self.card.grid_remove()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        try:
            self.card2.grid_remove()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        try:
            self._wrap_collapsed.grid()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _expand_view(self):
        """Mostra novamente cabeçalho e tabela."""
        self._is_collapsed_after_close = False  # modo oculto apos finalizar/salvar
        try:
            self._wrap_collapsed.grid_remove()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        try:
            self.card.grid()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        try:
            self.card2.grid()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        if self._is_prestacao_fechada(self._current_prog):
            self.set_status(f"STATUS: Programacao {self._current_prog} (PRESTACAO FECHADA - somente consulta)")
        else:
            self.set_status(f"STATUS: Programacao {self._current_prog}")

    def _reset_view(self):
        """Limpa seleção e volta para estado inicial."""
        self._expand_view()
        self._current_prog = ""
        self.cb_prog.set("")
        self._nf_current = ""
        self.lbl_motorista_info.config(text="Motorista: -")
        self.lbl_veiculo_info.config(text="Veiculo: -")
        self.lbl_equipe_info.config(text="Equipe: -")
        self.lbl_rota_info.config(text="Rota: -")
        self._rota_atual = ""
        self._safe_set_entry(self.ent_diaria_motorista, "0,00", readonly_back=False)
        self.ent_data_saida.delete(0, "end")
        self.ent_hora_saida.delete(0, "end")
        self.ent_data_chegada.delete(0, "end")
        self.ent_hora_chegada.delete(0, "end")
        self._selected_cliente = None
        self._clear_form_recebimento()
        self.carregar_tabela_vazia()
        try:
            self.cb_filtro_forma.set("TODAS")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        try:
            self.ent_filtro_valor_min.delete(0, "end")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        self.refresh_comboboxes()
        if hasattr(self.app, "refresh_programacao_comboboxes"):
            try:
                self.app.refresh_programacao_comboboxes()
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        self.set_status("STATUS: Selecione uma programacao FINALIZADA e lance os pagantes (prestacao de contas).")

    # -------------------------
    # Helpers de segurança UI (readonly sem quebrar inserts)
    # -------------------------
    def _set_cliente_fields_readonly(self, readonly: bool):
        try:
            self.ent_cod.configure(state=("readonly" if readonly else "normal"))
            self.ent_nome.configure(state=("readonly" if readonly else "normal"))
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _safe_set_entry(self, entry, value: str, readonly_back: bool = None):
        try:
            prev = entry.cget("state")
        except Exception:
            prev = None

        try:
            try:
                entry.configure(state="normal")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)
            entry.delete(0, "end")
            entry.insert(0, value if value is not None else "")
        finally:
            try:
                if readonly_back is None:
                    if prev is not None:
                        entry.configure(state=prev)
                else:
                    entry.configure(state=("readonly" if readonly_back else "normal"))
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

    # -------------------------
    # Resolução de nomes (motorista/equipe)
    # -------------------------
    def _resolve_motorista_nome(self, motorista_raw: str) -> str:
        m = (motorista_raw or "").strip()
        if not m:
            return ""
        try:
            with get_db() as conn:
                cur = conn.cursor()
                for sql, params in [
                    ("SELECT nome FROM motoristas WHERE codigo=? LIMIT 1", (m,)),
                    ("SELECT nome FROM motoristas WHERE cod_motorista=? LIMIT 1", (m,)),
                    ("SELECT nome FROM cadastro_motoristas WHERE codigo=? LIMIT 1", (m,)),
                    ("SELECT nome FROM cadastro_motoristas WHERE cod_motorista=? LIMIT 1", (m,)),
                ]:
                    try:
                        cur.execute(sql, params)
                        r = cur.fetchone()
                        if r and r[0]:
                            return upper(r[0])
                    except Exception:
                        logging.debug("Falha ignorada", exc_info=True)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)
        return upper(m)

    def _resolve_equipe_integrantes(self, equipe_raw: str) -> str:
        return resolve_equipe_nomes(equipe_raw)

    # -------------------------
    # Ordenação (padronizada / robusta)
    # -------------------------
    def sort_by_column(self, col):
        if self._current_sort_column == col:
            self._sort_reverse = not self._sort_reverse
        else:
            self._current_sort_column = col
            self._sort_reverse = False

        reverse = self._sort_reverse

        def _to_float(v):
            try:
                s = str(v or "").strip()
                if not s or s in {"", "-", "None"}:
                    return 0.0
                s = s.replace("R$", "").replace(" ", "")
                s = s.replace(".", "").replace(",", ".")
                return float(s)
            except Exception:
                return 0.0

        def _to_date_key(v):
            s = str(v or "").strip()
            if not s:
                return (0, 0, 0, 0, 0, 0)

            if "-" in s and len(s) >= 10:
                try:
                    y, m, d = s[:10].split("-")
                    hh = mm = ss = 0
                    if len(s) >= 19 and ":" in s[11:19]:
                        hh, mm, ss = s[11:19].split(":")
                    return (int(y), int(m), int(d), int(hh), int(mm), int(ss))
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

            if "/" in s and len(s) >= 10:
                try:
                    d, m, y = s[:10].split("/")
                    hh = mm = ss = 0
                    if len(s) >= 19 and ":" in s[11:19]:
                        hh, mm, ss = s[11:19].split(":")
                    return (int(y), int(m), int(d), int(hh), int(mm), int(ss))
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

            return (0, 0, 0, 0, 0, 0)

        data = [(self.tree.set(child, col), child) for child in self.tree.get_children("")]

        if col == "VALOR":
            data.sort(key=lambda x: _to_float(x[0]), reverse=reverse)
        elif col == "DATA REGISTRO":
            data.sort(key=lambda x: _to_date_key(x[0]), reverse=reverse)
        else:
            data.sort(key=lambda x: str(x[0] or "").upper(), reverse=reverse)

        for idx, (_, child) in enumerate(data):
            self.tree.move(child, "", idx)

        arrow = " Ã¢â€ â€œ" if reverse else " Ã¢â€ â€˜"
        for c in self.tree["columns"]:
            current_text = self.tree.heading(c, "text")
            if current_text.endswith(" â†‘") or current_text.endswith(" â†“"):
                current_text = current_text[:-2]
            self.tree.heading(c, text=current_text)

        current_text = self.tree.heading(col, "text")
        if current_text.endswith(" â†‘") or current_text.endswith(" â†“"):
            current_text = current_text[:-2]
        self.tree.heading(col, text=current_text + arrow)

    # -------------------------
    # Combobox programação (pendentes)
    # -------------------------
    def refresh_comboboxes(self):
        with get_db() as conn:
            cur = conn.cursor()
            try:
                cur.execute("""
                    SELECT codigo_programacao
                    FROM programacoes
                    WHERE (status='ATIVA' OR status='FINALIZADA')
                      AND (prestacao_status IS NULL OR prestacao_status='PENDENTE')
                    ORDER BY id DESC
                    LIMIT 300
                """)
            except Exception:
                cur.execute("""
                    SELECT codigo_programacao
                    FROM programacoes
                    WHERE (status='ATIVA' OR status='FINALIZADA')
                    ORDER BY id DESC
                    LIMIT 300
                """)
            self.cb_prog["values"] = [r[0] for r in cur.fetchall()]

    def on_show(self):
        self.refresh_comboboxes()
        self.set_status("STATUS: Selecione uma programacao FINALIZADA e lance os pagantes (prestacao de contas).")

    # -------------------------
    # Regras: bloqueio quando FECHADA
    # -------------------------
    def _is_prestacao_fechada(self, prog: str) -> bool:
        if not prog:
            return False
        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("SELECT prestacao_status FROM programacoes WHERE codigo_programacao=? LIMIT 1", (prog,))
                r = cur.fetchone()
                st = upper(r[0]) if r and r[0] is not None else ""
                return st == "FECHADA"
        except Exception:
            return False

    def _warn_if_fechada(self) -> bool:
        if self._is_prestacao_fechada(self._current_prog):
            messagebox.showwarning("ATENÃƒâ€¡ÃƒÆ’O", "Esta prestaÃƒÂ§ÃƒÂ£o jÃƒÂ¡ estÃƒÂ¡ FECHADA. NÃƒÂ£o ÃƒÂ© possÃƒÂ­vel alterar recebimentos.")
            return True
        return False

    def _clean_cod_cliente(self, cod):
        s = str(cod or "").strip()
        if s.endswith(".0"):
            base = s[:-2]
            if base.isdigit():
                return base
        return s

    def _format_money_from_digits(self, digits: str) -> str:
        digits = re.sub(r"\D", "", str(digits or ""))
        if not digits:
            return "0,00"
        if len(digits) == 1:
            int_part = "0"
            cents = "0" + digits
        elif len(digits) == 2:
            int_part = "0"
            cents = digits
        else:
            int_part = digits[:-2]
            cents = digits[-2:]

        parts = []
        while len(int_part) > 3:
            parts.insert(0, int_part[-3:])
            int_part = int_part[:-3]
        if int_part:
            parts.insert(0, int_part)
        int_part = ".".join(parts) if parts else "0"
        return f"{int_part},{cents}"

    def _bind_money_entry(self, ent: tk.Entry):
        def _on_focus_in(_e=None):
            try:
                v = str(ent.get() or "").strip()
                if v in {"0", "0,00", "0.00", "R$ 0,00", "R$0,00"}:
                    ent.delete(0, "end")
                else:
                    ent.selection_range(0, "end")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        def _on_key_release(_e=None):
            try:
                v = str(ent.get() or "")
                digits = re.sub(r"\D", "", v)
                if digits:
                    ent.delete(0, "end")
                    ent.insert(0, self._format_money_from_digits(digits))
                    ent.icursor("end")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        def _on_focus_out(_e=None):
            try:
                v = str(ent.get() or "").strip()
                if not v:
                    ent.insert(0, "0,00")
                else:
                    ent.delete(0, "end")
                    ent.insert(0, self._format_money_from_digits(v))
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        ent.bind("<FocusIn>", _on_focus_in)
        ent.bind("<KeyRelease>", _on_key_release)
        ent.bind("<FocusOut>", _on_focus_out)

    def _ir_para_despesas(self):
        if not self._current_prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return
        # Garante amarração entre telas: persiste cabeçalho/diárias antes de avançar.
        if not self.salvar_dados_rota(silent=True):
            return
        try:
            self.app.show_page("Despesas")
            page = self.app.pages.get("Despesas") if hasattr(self.app, "pages") else None
            if page and hasattr(page, "set_programacao"):
                page.set_programacao(self._current_prog)
                try:
                    if hasattr(page, "_load_by_programacao"):
                        page._load_by_programacao()
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    # -------------------------
    # Carregar programaÃ§Ã£o
    # -------------------------
    def carregar_programacao(self):
        prog = upper(self.cb_prog.get())
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação pendente.")
            return

        self._current_prog = prog

        with get_db() as conn:
            cur = conn.cursor()
            try:
                cur.execute("PRAGMA table_info(programacoes)")
                cols_prog = [str(r[1]).lower() for r in cur.fetchall()]
            except Exception:
                cols_prog = []
            col_rota = "local_rota" if "local_rota" in cols_prog else ("tipo_rota" if "tipo_rota" in cols_prog else "''")
            col_diaria = "diaria_motorista_valor" if "diaria_motorista_valor" in cols_prog else "0"
            cur.execute("""
                SELECT motorista, veiculo, equipe, num_nf, data_saida, hora_saida, data_chegada, hora_chegada,
                       {col_rota} as rota, COALESCE({col_diaria}, 0) as diaria_motorista
                FROM programacoes
                WHERE codigo_programacao=?
            """.format(col_rota=col_rota, col_diaria=col_diaria), (prog,))
            row = cur.fetchone()

        if not row:
            messagebox.showwarning("ATENÃ‡ÃƒO", f"ProgramaÃ§Ã£o nÃ£o encontrada: {prog}")
            self._reset_view()
            return

        motorista, veiculo, equipe, nf, data_saida, hora_saida, data_chegada, hora_chegada, rota, diaria_motorista = row

        motorista_nome = self._resolve_motorista_nome(motorista)
        equipe_nomes = self._resolve_equipe_integrantes(equipe)
        self.lbl_motorista_info.config(text=f"Motorista: {motorista_nome}")
        self.lbl_veiculo_info.config(text=f"Veiculo: {upper(veiculo)}")
        self.lbl_equipe_info.config(text=f"Equipe: {equipe_nomes}")
        self._rota_atual = upper(rota or "")
        self.lbl_rota_info.config(text=f"Rota: {self._rota_atual or '-'}")
        self._safe_set_entry(self.ent_diaria_motorista, f"{safe_float(diaria_motorista, 0.0):.2f}".replace(".", ","), readonly_back=False)

        self._nf_current = nf or ""

        data_saida_n, hora_saida_n = normalize_date_time_components(data_saida, hora_saida)
        data_chegada_n, hora_chegada_n = normalize_date_time_components(data_chegada, hora_chegada)

        self.ent_data_saida.delete(0, "end"); self.ent_data_saida.insert(0, data_saida_n)
        self.ent_hora_saida.delete(0, "end"); self.ent_hora_saida.insert(0, hora_saida_n)
        self.ent_data_chegada.delete(0, "end"); self.ent_data_chegada.insert(0, data_chegada_n)
        self.ent_hora_chegada.delete(0, "end"); self.ent_hora_chegada.insert(0, hora_chegada_n)

        self._selected_cliente = None
        self._clear_form_recebimento()

        if self._is_collapsed_after_close:
            self._expand_view()

        self.carregar_clientes_e_recebimentos()

        if self._is_prestacao_fechada(prog):
            self.set_status(f"STATUS: Programacao {self._current_prog} (PRESTACAO FECHADA - somente consulta)")
        else:
            self.set_status(f"STATUS: Programacao carregada: {prog}")

    # -------------------------
    # Validação leve de data/hora
    # -------------------------
    def _validate_date(self, s: str) -> bool:
        s = (s or "").strip()
        if not s:
            return True
        if "-" in s and len(s) >= 10:
            try:
                y, m, d = s[:10].split("-")
                int(y); int(m); int(d)
                return True
            except Exception:
                return False
        if "/" in s and len(s) >= 10:
            try:
                d, m, y = s[:10].split("/")
                int(y); int(m); int(d)
                return True
            except Exception:
                return False
        return False

    def _validate_time(self, s: str) -> bool:
        s = (s or "").strip()
        if not s:
            return True
        try:
            hh, mm = s.split(":")[:2]
            hh = int(hh); mm = int(mm)
            return 0 <= hh <= 23 and 0 <= mm <= 59
        except Exception:
            return False

    def salvar_dados_rota(self, silent: bool = False):
        if not self._current_prog:
            if not silent:
                messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return False
        if self._warn_if_fechada():
            return False

        diaria_motorista = safe_money(self.ent_diaria_motorista.get(), 0.0)
        if diaria_motorista < 0:
            if not silent:
                messagebox.showwarning("ATENÇÃO", "Diária do motorista não pode ser negativa.")
            return False

        data_saida = normalize_date(self.ent_data_saida.get())
        hora_saida = normalize_time(self.ent_hora_saida.get())
        data_chegada = normalize_date(self.ent_data_chegada.get())
        hora_chegada = normalize_time(self.ent_hora_chegada.get())

        if data_saida is None or data_chegada is None:
            if not silent:
                messagebox.showwarning("ATENÇÃO", "Formato de data inválido. Use dd/mm/aaaa ou yyyy-mm-dd.")
            return False
        if hora_saida is None or hora_chegada is None:
            if not silent:
                messagebox.showwarning("ATENÇÃO", "Formato de hora inválido. Use HH:MM (ex.: 07:30).")
            return False

        # atualiza campos com formato normalizado
        self._safe_set_entry(self.ent_data_saida, data_saida, readonly_back=False)
        self._safe_set_entry(self.ent_hora_saida, hora_saida, readonly_back=False)
        self._safe_set_entry(self.ent_data_chegada, data_chegada, readonly_back=False)
        self._safe_set_entry(self.ent_hora_chegada, hora_chegada, readonly_back=False)
        self._safe_set_entry(self.ent_diaria_motorista, f"{diaria_motorista:.2f}".replace(".", ","), readonly_back=False)

        try:
            with get_db() as conn:
                cur = conn.cursor()
                try:
                    cur.execute("PRAGMA table_info(programacoes)")
                    cols_prog = [str(r[1]).lower() for r in cur.fetchall()]
                except Exception:
                    cols_prog = []
                cur.execute("""
                    UPDATE programacoes
                       SET data_saida=?,
                           hora_saida=?,
                           data_chegada=?,
                           hora_chegada=?
                     WHERE codigo_programacao=?
                """, (data_saida, hora_saida, data_chegada, hora_chegada, self._current_prog))
                if "diaria_motorista_valor" in cols_prog:
                    cur.execute(
                        "UPDATE programacoes SET diaria_motorista_valor=? WHERE codigo_programacao=?",
                        (diaria_motorista, self._current_prog)
                    )
                self._sync_diarias_despesas(
                    cur=cur,
                    prog=self._current_prog,
                    rota=self._rota_atual,
                    data_saida=data_saida,
                    hora_saida=hora_saida,
                    data_chegada=data_chegada,
                    hora_chegada=hora_chegada,
                    diaria_motorista=diaria_motorista,
                )

            if not silent:
                messagebox.showinfo("OK", "Dados da rota atualizados!")
            self.set_status("STATUS: Dados do cabeçalho atualizados.")
            return True
        except Exception as e:
            if not silent:
                messagebox.showerror("ERRO", f"Erro ao salvar dados: {str(e)}")
            return False

    def _parse_dt_diaria(self, data_s: str, hora_s: str):
        data_s = (data_s or "").strip()
        hora_s = (hora_s or "").strip()
        if not data_s:
            return None
        try:
            if "-" in data_s:
                y, m, d = data_s[:10].split("-")
            elif "/" in data_s:
                d, m, y = data_s[:10].split("/")
            else:
                return None
            hh, mm = "00", "00"
            if hora_s and ":" in hora_s:
                hh, mm = hora_s.split(":")[:2]
            return datetime(int(y), int(m), int(d), int(hh), int(mm))
        except Exception:
            return None

    def _calc_qtd_diarias_regra(self, data_saida: str, hora_saida: str, data_chegada: str, hora_chegada: str) -> float:
        dt_saida = self._parse_dt_diaria(data_saida, hora_saida)
        dt_chegada = self._parse_dt_diaria(data_chegada, hora_chegada)
        if not dt_saida:
            return 0.0
        if not dt_chegada or dt_chegada <= dt_saida:
            return 1.0
        horas = (dt_chegada - dt_saida).total_seconds() / 3600.0
        if horas <= 24.0:
            return 1.0
        rem = horas - 24.0
        full = int(rem // 24.0)
        half = 0.5 if (rem - (full * 24.0)) > 0 else 0.0
        return 1.0 + full + half

    def _sync_diarias_despesas(self, cur, prog: str, rota: str, data_saida: str, hora_saida: str, data_chegada: str, hora_chegada: str, diaria_motorista: float):
        qtd = self._calc_qtd_diarias_regra(data_saida, hora_saida, data_chegada, hora_chegada)
        diaria_motorista = safe_float(diaria_motorista, 0.0)
        diaria_ajudante = max(diaria_motorista - 10.0, 0.0)
        total_mot = round(qtd * diaria_motorista, 2)
        total_ajud = round(qtd * (diaria_ajudante * 2.0), 2)

        obs_base = (
            f"AUTO_DIARIA|ROTA={upper(rota)}|QTD={qtd:g}|"
            f"DIARIA_MOTORISTA={diaria_motorista:.2f}|DIARIA_AJUDANTE={diaria_ajudante:.2f}"
        )
        cur.execute("""
            DELETE FROM despesas
             WHERE codigo_programacao=?
               AND descricao IN ('DIARIAS MOTORISTA', 'DIARIAS AJUDANTES')
               AND COALESCE(observacao, '') LIKE 'AUTO_DIARIA|%'
        """, (prog,))

        now_s = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        cur.execute("""
            INSERT INTO despesas (codigo_programacao, descricao, valor, categoria, observacao, data_registro)
            VALUES (?, ?, ?, 'DIARIAS', ?, ?)
        """, (prog, "DIARIAS MOTORISTA", total_mot, obs_base, now_s))
        cur.execute("""
            INSERT INTO despesas (codigo_programacao, descricao, valor, categoria, observacao, data_registro)
            VALUES (?, ?, ?, 'DIARIAS', ?, ?)
        """, (prog, "DIARIAS AJUDANTES", total_ajud, obs_base, now_s))

    # -------------------------
    # Carregar clientes + recebimentos (resumo)
    # -------------------------
    def carregar_clientes_e_recebimentos(self):
        prog = self._current_prog
        if not prog:
            return

        filtro_forma = ""
        filtro_valor_min = 0.0

        with get_db() as conn:
            cur = conn.cursor()

            cur.execute("""
                SELECT DISTINCT cod_cliente, nome_cliente
                FROM programacao_itens
                WHERE codigo_programacao=?
                ORDER BY nome_cliente ASC
            """, (prog,))
            clientes = cur.fetchall() or []

            # dados sincronizados do app (controle)
            ctrl_map = {}
            try:
                cur.execute("""
                    SELECT cod_cliente,
                           COALESCE(valor_recebido, 0),
                           COALESCE(forma_recebimento, ''),
                           COALESCE(obs_recebimento, ''),
                           COALESCE(alterado_em, '')
                    FROM programacao_itens_controle
                    WHERE codigo_programacao=?
                """, (prog,))
                for cod, vrec, forma, obs, alterado_em in (cur.fetchall() or []):
                    cod_u = upper(cod)
                    ctrl_map[cod_u] = {
                        "valor": safe_float(vrec, 0.0),
                        "forma": upper(forma),
                        "obs": obs or "",
                        "data": alterado_em or ""
                    }
            except Exception:
                ctrl_map = {}

            query = """
                SELECT cod_cliente, nome_cliente, valor, forma_pagamento, observacao, data_registro
                FROM recebimentos
                WHERE codigo_programacao=?
            """
            params = [prog]

            if filtro_forma and filtro_forma != "TODAS":
                query += " AND forma_pagamento = ?"
                params.append(filtro_forma)

            if filtro_valor_min > 0:
                query += " AND valor >= ?"
                params.append(filtro_valor_min)

            query += " ORDER BY id DESC"
            cur.execute(query, params)
            recs = cur.fetchall() or []

        mapa = {}
        for cod, nome, valor, forma, obs, data_registro in recs:
            cod_u = upper(self._clean_cod_cliente(cod))
            if cod_u not in mapa:
                mapa[cod_u] = {
                    "nome": upper(nome),
                    "valor": 0.0,
                    "forma": upper(forma or ""),
                    "obs": (obs or ""),
                    "ultima_data": (data_registro or "")
                }
            mapa[cod_u]["valor"] += safe_float(valor, 0.0)
            if forma:
                mapa[cod_u]["forma"] = upper(forma)
            if obs:
                mapa[cod_u]["obs"] = obs
            if data_registro:
                mapa[cod_u]["ultima_data"] = data_registro

        self.tree.delete(*self.tree.get_children())

        total = 0.0
        for cod, nome in clientes:
            cod_u = upper(self._clean_cod_cliente(cod))
            nome_u = upper(nome)
            info = mapa.get(cod_u, {"valor": 0.0, "forma": "", "obs": "", "ultima_data": ""})
            ctrl = ctrl_map.get(cod_u)
            if ctrl and ctrl.get("valor", 0.0) > 0:
                info = {
                    "valor": ctrl.get("valor", 0.0),
                    "forma": ctrl.get("forma", ""),
                    "obs": ctrl.get("obs", ""),
                    "ultima_data": ctrl.get("data", "")
                }

            total += safe_float(info["valor"], 0.0)
            self.tree.insert("", "end", values=(
                cod_u,
                nome_u,
                fmt_money(info["valor"]),
                upper(info["forma"]),
                info["obs"],
                info["ultima_data"][:19] if info["ultima_data"] else ""
            ))

        self._update_total(total)
        self.set_status(f"STATUS: {len(clientes)} clientes carregados. Total: {fmt_money(total)}")

    def carregar_tabela_vazia(self):
        self.tree.delete(*self.tree.get_children())
        self._update_total(0.0)

    def _update_total(self, total):
        self.lbl_total.config(text=f"TOTAL RECEBIDO: {fmt_money(total)}")

    # -------------------------
    # SeleÃƒÂ§ÃƒÂ£o / formulÃƒÂ¡rio
    # -------------------------
    def _on_select_row(self, event=None):
        sel = self.tree.selection()
        if not sel:
            return
        vals = self.tree.item(sel[0], "values") or ()
        if len(vals) < 6:
            return

        cod, nome, valor, forma, obs, data_registro = vals
        cod = self._clean_cod_cliente(cod)
        self._selected_cliente = upper(cod)

        self._safe_set_entry(self.ent_cod, cod, readonly_back=True)
        self._safe_set_entry(self.ent_nome, nome, readonly_back=True)

        try:
            vv = str(valor).replace("R$", "").strip()
        except Exception:
            vv = ""
        self.ent_valor.delete(0, "end")
        self.ent_valor.insert(0, vv)

        forma_u = upper(forma)
        try:
            allowed = set(self.cb_forma["values"])
        except Exception:
            allowed = {"DINHEIRO", "PIX", "CARTAO", "BOLETO", "OUTRO"}

        self.cb_forma.set(forma_u if forma_u in allowed else "DINHEIRO")

        self.ent_obs.delete(0, "end")
        self.ent_obs.insert(0, obs or "")

    def _clear_form_recebimento(self):
        self._safe_set_entry(self.ent_cod, "", readonly_back=True)
        self._safe_set_entry(self.ent_nome, "", readonly_back=True)
        self.ent_valor.delete(0, "end")
        self.cb_forma.set("DINHEIRO")
        self.ent_obs.delete(0, "end")

    # -------------------------
    # Salvar recebimento (com bloqueio se FECHADA)
    # -------------------------
    def salvar_recebimento(self):
        prog = self._current_prog
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return
        if self._warn_if_fechada():
            return

        cod = upper(self.ent_cod.get())
        nome = upper(self.ent_nome.get())
        valor = safe_money(self.ent_valor.get(), 0.0)
        forma = upper(self.cb_forma.get())
        obs = upper(self.ent_obs.get())

        if not cod or not nome:
            messagebox.showwarning("ATENÇÃO", "Selecione um cliente na tabela ou insira manualmente.")
            return
        if valor <= 0:
            messagebox.showwarning("ATENÇÃO", "Informe um valor válido (maior que zero).")
            return
        if not forma:
            messagebox.showwarning("ATENÇÃO", "Informe a forma de pagamento.")
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("""
                    INSERT INTO recebimentos
                        (codigo_programacao, cod_cliente, nome_cliente, valor, forma_pagamento, observacao, num_nf, data_registro)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    prog,
                    cod,
                    nome,
                    float(valor),
                    forma,
                    obs,
                    upper(self._nf_current),
                    datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                ))

            self._clear_form_recebimento()
            self.carregar_clientes_e_recebimentos()
            self.set_status(f"STATUS: Recebimento de {fmt_money(valor)} salvo para {nome}.")
        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao salvar recebimento: {str(e)}")

    def zerar_recebimento(self):
        prog = self._current_prog
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return
        if self._warn_if_fechada():
            return

        cod = upper(self.ent_cod.get().strip())
        if not cod:
            messagebox.showwarning("ATENÇÃO", "Selecione um cliente na tabela.")
            return

        if not messagebox.askyesno("Confirmar", f"Zerar recebimentos do cliente {cod} nessa programação?"):
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("DELETE FROM recebimentos WHERE codigo_programacao=? AND cod_cliente=?", (prog, cod))

            self._clear_form_recebimento()
            self.carregar_clientes_e_recebimentos()
            self.set_status(f"STATUS: Recebimentos zerados para cliente {cod}.")
        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao zerar recebimentos: {str(e)}")

    def inserir_cliente_manual(self):
        prog = self._current_prog
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return
        if self._warn_if_fechada():
            return

        cod = upper(simple_input(
            "Cliente Manual", "Digite o CÓDIGO do cliente:",
            master=self.app if hasattr(self, "app") else None,
            allow_empty=False
        ))
        if not cod:
            return

        nome = upper(simple_input(
            "Cliente Manual", "Digite o NOME do cliente:",
            master=self.app if hasattr(self, "app") else None,
            allow_empty=False
        ))
        if not nome:
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("""
                    SELECT COUNT(1)
                    FROM programacao_itens
                    WHERE codigo_programacao=?
                      AND cod_cliente=?
                """, (prog, cod))
                exists = int((cur.fetchone() or [0])[0] or 0)

                if not exists:
                    cur.execute("""
                        INSERT INTO programacao_itens
                            (codigo_programacao, cod_cliente, nome_cliente, qnt_caixas, kg, preco, endereco, vendedor, pedido)
                        VALUES (?, ?, ?, 0, 0, 0, '', '', 'MANUAL')
                    """, (prog, cod, nome))
                else:
                    cur.execute("""
                        UPDATE programacao_itens
                           SET nome_cliente=?
                         WHERE codigo_programacao=?
                           AND cod_cliente=?
                    """, (nome, prog, cod))

            self._safe_set_entry(self.ent_cod, cod, readonly_back=True)
            self._safe_set_entry(self.ent_nome, nome, readonly_back=True)
            self._selected_cliente = {"cod_cliente": cod, "nome_cliente": nome}

            messagebox.showinfo("OK", "Cliente inserido/atualizado na programação (manual). Agora pode lançar o recebimento.")
            self.carregar_clientes_e_recebimentos()

            try:
                self.ent_valor.focus_set()
                self.ent_valor.selection_range(0, "end")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao inserir cliente: {str(e)}")

    # =========================
    # Ã¢Å“â€¦ IMPRESSÃƒÆ’O PDF (A4) Ã¢â‚¬â€ alinhado e com assinaturas
    # =========================
    def _get_dados_para_impressao(self, prog: str):
        """
        Retorna:
          - header dict (motorista/equipe/veiculo/nf/saida/chegada)
          - rows: lista de (cod, nome, valor_total, forma_mais_recente)
          - total_geral
        Apenas clientes pagantes (valor_total > 0).
        """
        header = {
            "prog": prog,
            "motorista_nome": "",
            "equipe_nomes": "",
            "veiculo": "",
            "nf": "",
            "data_saida": "",
            "hora_saida": "",
            "data_chegada": "",
            "hora_chegada": "",
        }

        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT motorista, veiculo, equipe, num_nf, data_saida, hora_saida, data_chegada, hora_chegada
                FROM programacoes
                WHERE codigo_programacao=?
                LIMIT 1
            """, (prog,))
            r = cur.fetchone()

            if r:
                motorista_raw, veiculo, equipe_raw, nf, dsa, hsa, dch, hch = r
                header["motorista_nome"] = self._resolve_motorista_nome(motorista_raw)
                header["equipe_nomes"] = self._resolve_equipe_integrantes(equipe_raw)
                header["veiculo"] = upper(veiculo or "")
                header["nf"] = upper(nf or "")
                dsa_n, hsa_n = normalize_date_time_components(dsa, hsa)
                dch_n, hch_n = normalize_date_time_components(dch, hch)
                header["data_saida"] = dsa_n
                header["hora_saida"] = hsa_n
                header["data_chegada"] = dch_n
                header["hora_chegada"] = hch_n

            # total por cliente + forma mais recente (pega a do último registro)
            # OBS: aqui prioriza “forma do registro mais recente, e soma valores.
            cur.execute("""
                SELECT cod_cliente, nome_cliente, SUM(valor) AS total_valor,
                       (SELECT forma_pagamento
                          FROM recebimentos r2
                         WHERE r2.codigo_programacao = r.codigo_programacao
                           AND upper(r2.cod_cliente) = upper(r.cod_cliente)
                         ORDER BY datetime(r2.data_registro) DESC, r2.id DESC
                         LIMIT 1) AS forma_recente
                FROM recebimentos r
                WHERE codigo_programacao=?
                GROUP BY upper(cod_cliente), upper(nome_cliente)
                HAVING SUM(valor) > 0
                ORDER BY upper(nome_cliente) ASC
            """, (prog,))
            rows = cur.fetchall() or []

        parsed_rows = []
        total_geral = 0.0
        for cod, nome, total_valor, forma_recente in rows:
            v = safe_float(total_valor, 0.0)
            total_geral += v
            parsed_rows.append((upper(cod), upper(nome), float(v), upper(forma_recente or "")))

        return header, parsed_rows, float(total_geral)

    def imprimir_pdf(self):
        prog = self._current_prog
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return

        header, rows, total_geral = self._get_dados_para_impressao(prog)
        if not rows:
            messagebox.showwarning("Impressão", "Não há clientes pagantes (valor > 0) para imprimir.")
            return

        path = filedialog.asksaveasfilename(
            title="Salvar PDF - Recebimentos",
            defaultextension=".pdf",
            filetypes=[("PDF", "*.pdf")],
            initialfile=f"RECEBIMENTOS_{prog}_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf"
        )
        if not path:
            return

        try:
            # ReportLab (já instalado no seu ambiente)
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import A4
            from reportlab.lib.units import mm

            c = canvas.Canvas(path, pagesize=A4)
            width, height = A4

            # Margens
            left = 12 * mm
            right = 12 * mm
            top = 12 * mm
            bottom = 12 * mm

            y = height - top

            # ===== TTULO =====
            c.setFont("Helvetica-Bold", 14)
            c.drawString(left, y, f"RECIBO / RELATÓRIO DE RECEBIMENTOS - PROGRAMAÇÃO {header['prog']}")
            y -= 10 * mm

            # ===== DADOS DO MOTORISTA / ROTA (BLOCO ALINHADO) =====
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "DADOS DO MOTORISTA / ROTA")
            y -= 6 * mm

            c.setFont("Helvetica", 9)

            # Layout em duas colunas (2 linhas)
            col1_x = left
            col2_x = left + (width - left - right) * 0.55

            line_h = 5.2 * mm

            def draw_kv(x, y0, k, v):
                c.setFont("Helvetica-Bold", 9)
                c.drawString(x, y0, f"{k}:")
                c.setFont("Helvetica", 9)
                c.drawString(x + 28 * mm, y0, v or "")

            draw_kv(col1_x, y, "Motorista", header["motorista_nome"])
            draw_kv(col2_x, y, "Veículo", header["veiculo"])
            y -= line_h

            draw_kv(col1_x, y, "Equipe", header["equipe_nomes"])
            draw_kv(col2_x, y, "NF", header["nf"])
            y -= line_h

            draw_kv(col1_x, y, "Saída", f"{header['data_saida']} {header['hora_saida']}".strip())
            draw_kv(col2_x, y, "Chegada", f"{header['data_chegada']} {header['hora_chegada']}".strip())
            y -= 8 * mm

            # Linha separadora
            c.setLineWidth(0.8)
            c.line(left, y, width - right, y)
            y -= 6 * mm

            # ===== TABELA (apenas pagantes) =====
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "RECEBIMENTOS (APENAS CLIENTES PAGANTES)")
            y -= 6 * mm

            # Cabeçalho da tabela
            table_x = left
            table_w = width - left - right

            # Colunas: COD | CLIENTE | FORMA | VALOR
            col_cod = table_w * 0.16
            col_nome = table_w * 0.50
            col_forma = table_w * 0.18
            col_valor = table_w * 0.16

            x_cod = table_x
            x_nome = x_cod + col_cod
            x_forma = x_nome + col_nome
            x_valor = x_forma + col_forma

            row_h = 6.2 * mm

            # função segura p/ quebrar texto
            def clip_text(s, max_chars):
                s = (s or "")
                return s if len(s) <= max_chars else s[:max_chars - 1] + "…"

            # desenha header
            c.setFont("Helvetica-Bold", 9)
            c.rect(table_x, y - row_h + 1, table_w, row_h, stroke=1, fill=0)
            c.drawString(x_cod + 2, y - row_h + 3, "CÓD CLIENTE")
            c.drawString(x_nome + 2, y - row_h + 3, "NOME CLIENTE")
            c.drawString(x_forma + 2, y - row_h + 3, "FORMA PGTO")
            c.drawRightString(x_valor + col_valor - 2, y - row_h + 3, "VALOR (R$)")
            y -= row_h

            c.setFont("Helvetica", 9)

            # desenha linhas
            for cod, nome, valor, forma in rows:
                # quebra de página se necessário
                if y < bottom + 55 * mm:
                    c.showPage()
                    width, height = A4
                    y = height - top
                    c.setFont("Helvetica-Bold", 14)
                    c.drawString(left, y, f"RECIBO / RELATÓRIO DE RECEBIMENTOS - PROGRAMAÇÃO {header['prog']}")
                    y -= 10 * mm

                    c.setFont("Helvetica-Bold", 10)
                    c.drawString(left, y, "RECEBIMENTOS (CONTINUAÇÃO)")
                    y -= 6 * mm

                    c.setFont("Helvetica-Bold", 9)
                    c.rect(table_x, y - row_h + 1, table_w, row_h, stroke=1, fill=0)
                    c.drawString(x_cod + 2, y - row_h + 3, "CÓD CLIENTE")
                    c.drawString(x_nome + 2, y - row_h + 3, "NOME CLIENTE")
                    c.drawString(x_forma + 2, y - row_h + 3, "FORMA PGTO")
                    c.drawRightString(x_valor + col_valor - 2, y - row_h + 3, "VALOR (R$)")
                    y -= row_h
                    c.setFont("Helvetica", 9)

                c.rect(table_x, y - row_h + 1, table_w, row_h, stroke=1, fill=0)
                c.drawString(x_cod + 2, y - row_h + 3, clip_text(cod, 18))
                c.drawString(x_nome + 2, y - row_h + 3, clip_text(nome, 52))
                c.drawString(x_forma + 2, y - row_h + 3, clip_text(forma, 14))
                c.drawRightString(x_valor + col_valor - 2, y - row_h + 3, fmt_money(valor).replace("R$", "").strip())
                y -= row_h

            # total
            y -= 4 * mm
            c.setFont("Helvetica-Bold", 10)
            c.drawRightString(width - right, y, f"TOTAL RECEBIDO: {fmt_money(total_geral)}")
            y -= 10 * mm

            # Linha separadora
            c.setLineWidth(0.8)
            c.line(left, y, width - right, y)
            y -= 10 * mm

            # ===== REA DE ASSINATURAS =====
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "ASSINATURAS / CONFERÊNCIA")
            y -= 10 * mm

            # 2 colunas x 2 linhas (4 setores)
            block_w = (width - left - right - 10 * mm) / 2.0
            block_h = 18 * mm
            gap_x = 10 * mm
            gap_y = 10 * mm

            def assinatura_block(x, y_top, titulo):
                # caixa
                c.setLineWidth(0.8)
                c.rect(x, y_top - block_h, block_w, block_h, stroke=1, fill=0)
                c.setFont("Helvetica-Bold", 9)
                c.drawString(x + 3 * mm, y_top - 5 * mm, titulo)
                # linha assinatura
                c.setFont("Helvetica", 9)
                c.line(x + 3 * mm, y_top - 13 * mm, x + block_w - 3 * mm, y_top - 13 * mm)
                c.drawString(x + 3 * mm, y_top - 16.5 * mm, "Assinatura / Carimbo")

            x1 = left
            x2 = left + block_w + gap_x

            # linha 1
            assinatura_block(x1, y, "SETOR FATURAMENTO")
            assinatura_block(x2, y, "SETOR FINANCEIRO")
            y -= (block_h + gap_y)

            # linha 2
            assinatura_block(x1, y, "SETOR DE CAIXA")
            assinatura_block(x2, y, "SETOR DE CONFERÊNCIA")

            # rodapé
            c.setFont("Helvetica", 8)
            c.drawRightString(width - right, bottom - 2 * mm, f"Gerado em {datetime.now().strftime('%d/%m/%Y %H:%M')}")

            c.save()

            messagebox.showinfo("OK", f"PDF gerado com sucesso!\n\nArquivo:\n{os.path.basename(path)}")
            self.set_status(f"STATUS: PDF impresso/gerado: {os.path.basename(path)}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao gerar PDF: {str(e)}")

    # -------------------------
    # Finalizar prestaÃ§Ã£o (fecha e bloqueia alteraÃ§Ãµes)
    # -------------------------
    def finalizar_prestacao(self):
        prog = self._current_prog
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Carregue uma programação primeiro.")
            return

        if self._is_prestacao_fechada(prog):
            messagebox.showinfo("PrestaÃ§Ã£o", "Esta prestaÃ§Ã£o jÃ¡ estÃ¡ FECHADA.")
            self._collapse_view()
            return

        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("SELECT SUM(valor) FROM recebimentos WHERE codigo_programacao=?", (prog,))
            total_receb = safe_float((cur.fetchone() or [0])[0], 0.0)

        if not messagebox.askyesno(
            "Confirmar",
            f"Finalizar prestação de contas da rota {prog}?\n\n"
            f"Total Recebido: {fmt_money(total_receb)}\n\n"
            f"Ela não aparecerá mais na lista pendente."
        ):
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("""
                    UPDATE programacoes
                    SET prestacao_status='FECHADA', status='FINALIZADA'
                    WHERE codigo_programacao=?
                """, (prog,))

            messagebox.showinfo("OK", f"Prestação finalizada: {prog}\nTotal Recebido: {fmt_money(total_receb)}")

            self._lbl_collapsed.config(
                text=f"PRESTAÇÃO FECHADA / SALVA.\n"
                     f"Programação: {prog}\n"
                     f"Total Recebido: {fmt_money(total_receb)}\n"
                     f"\nCabeçalhos e dados da tabela foram ocultados."
            )
            self._collapse_view()

            self.refresh_comboboxes()
            if hasattr(self.app, "refresh_programacao_comboboxes"):
                try:
                    self.app.refresh_programacao_comboboxes()
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao finalizar prestação: {str(e)}")

# ==========================
# ===== FIM DA PARTE 6C (ATUALIZADA) =====
# ==========================


# ==========================
# ===== INCIO DA PARTE 7 (ATUALIZADA) =====
# ==========================

# =========================================================
# 7.0 CONFIGURAÇÃO DE LOGGING (DespesasPage) - mais seguro
# =========================================================
def setup_despesas_logger():
    """
    Logger com rotação de arquivo para não crescer infinito.
    Não altera regra do sistema, só evita travar com log grande.
    """
    logger = logging.getLogger(__name__ + ".DespesasPage")
    if not logger.handlers:
        try:
            from logging.handlers import RotatingFileHandler
            handler = RotatingFileHandler(
                "despesas_audit.log",
                maxBytes=2_000_000,   # ~2MB
                backupCount=5,
                encoding="utf-8"
            )
        except Exception:
            handler = logging.FileHandler("despesas_audit.log", encoding="utf-8")

        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        logger.propagate = False
    return logger


# =========================================================
# 7.1 DESPESAS PAGE (PARTE 1/3) ✅ layout mais robusto + scroll seguro
# =========================================================
class DespesasPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Despesas")

        self.selected_despesa_id = None
        self.logger = setup_despesas_logger()
        self._current_programacao = None

        # =========================================================
        # ✅ Remove cinza / body branco (sem mexer no PageBase)
        # =========================================================
        try:
            self.body.configure(padding=0)
            self.body.configure(style="Card.TFrame")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        self.body.grid_columnconfigure(0, weight=1)
        self.body.grid_rowconfigure(0, weight=1)

        page_card = ttk.Frame(self.body, style="Card.TFrame", padding=10)
        page_card.grid(row=0, column=0, sticky="nsew")
        page_card.grid_columnconfigure(0, weight=1)

        page_card.grid_rowconfigure(0, weight=0)
        page_card.grid_rowconfigure(1, weight=0)
        page_card.grid_rowconfigure(2, weight=1)
        page_card.grid_rowconfigure(3, weight=0)
        page_card.grid_rowconfigure(4, weight=0)

        # =========================================================
        # AÃƒâ€¡Ãƒâ€¢ES (FILTROS / BOTÃƒâ€¢ES)
        # =========================================================
        actions_frame = ttk.Frame(page_card, style="Card.TFrame")
        actions_frame.grid(row=0, column=0, sticky="ew", pady=(0, 8))
        actions_frame.grid_columnconfigure(6, weight=1)

        ttk.Button(
            actions_frame,
            text="ATUALIZAR",
            style="Ghost.TButton",
            command=self._refresh_all,
            width=10
        ).grid(row=0, column=2, padx=6)

        # (bot?es principais ficam no rodap?)

        self.lbl_stats = ttk.Label(
            actions_frame,
            text="Despesas: 0 | Total: R$ 0,00",
            font=("Segoe UI", 10, "bold"),
            background="white",
            foreground="#2c3e50"
        )
        self.lbl_stats.grid(row=0, column=6, sticky="e", padx=5)

        # =========================================================
        # TOPO (DADOS DA PROGRAMAÃ‡ÃƒO)
        # =========================================================
        top_frame = ttk.Frame(page_card, style="Card.TFrame")
        top_frame.grid(row=1, column=0, sticky="ew", pady=(0, 8))
        for i in range(0, 4):
            top_frame.grid_columnconfigure(i, weight=0)
        top_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(
            top_frame,
            text="PROGRAMAÃƒâ€¡ÃƒÆ’O",
            style="CardTitle.TLabel",
            font=("Segoe UI", 12, "bold")
        ).grid(row=0, column=0, sticky="w", padx=5)

        ttk.Label(top_frame, text="Código da Programação:", style="CardLabel.TLabel")            .grid(row=1, column=0, sticky="w", padx=5, pady=(6, 0))

        self.cb_prog = ttk.Combobox(top_frame, state="readonly", width=30)
        self.cb_prog.grid(row=1, column=1, sticky="w", padx=5, pady=(6, 0))
        self.cb_prog.bind("<<ComboboxSelected>>", lambda e: self._load_by_programacao())

        self.lbl_motorista = ttk.Label(
            top_frame,
            text="Motorista: ? | Veículo: ? | Equipe: ?",
            font=("Segoe UI", 10),
            background="white",
            wraplength=520,
            justify="left"
        )
        self.lbl_motorista.grid(row=2, column=0, columnspan=4, sticky="w", padx=5, pady=(6, 0))

        # =========================================================
        # MEIO (TABELA + DADOS)
        # =========================================================
        middle_frame = ttk.Frame(page_card, style="Card.TFrame")
        middle_frame.grid(row=2, column=0, sticky="nsew")
        middle_frame.grid_columnconfigure(0, weight=2)
        middle_frame.grid_columnconfigure(1, weight=3)
        middle_frame.grid_rowconfigure(0, weight=1)

        left_frame = ttk.Frame(middle_frame, style="Card.TFrame")
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 8))
        left_frame.grid_columnconfigure(0, weight=1)
        left_frame.grid_rowconfigure(0, weight=1)

        # =========================================================
        # TABELA (DESPESAS)
        # =========================================================
        table_frame = ttk.Frame(left_frame, style="Card.TFrame")
        table_frame.grid(row=0, column=0, sticky="nsew")
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(1, weight=1)

        header_frame = ttk.Frame(table_frame, style="Card.TFrame")
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 6))
        header_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(
            header_frame,
            text="DESPESAS REGISTRADAS",
            style="CardTitle.TLabel",
            font=("Segoe UI", 12, "bold")
        ).grid(row=0, column=0, sticky="w")

        # MantÃ©m o botÃ£o (atalho rÃ¡pido)
        ttk.Button(
            header_frame,
            text="ADICIONAR DESPESA",
            style="Primary.TButton",
            command=self._open_registrar_rapido
        ).grid(row=0, column=1, padx=10)
        columns = ["ID", "DESCRIÇÃO", "VALOR", "DATA", "CATEGORIA", "OBSERVAÇÃO"]
        self.tree_desp = ttk.Treeview(table_frame, columns=columns, show="headings")

        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree_desp.yview)
        hsb = ttk.Scrollbar(table_frame, orient="horizontal", command=self.tree_desp.xview)
        self.tree_desp.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        self.tree_desp.grid(row=1, column=0, sticky="nsew")
        vsb.grid(row=1, column=1, sticky="ns")
        hsb.grid(row=2, column=0, sticky="ew", columnspan=2)
        self.tree_desp.tag_configure("odd", background="#f6f7f9")
        col_widths = {
            "ID": 55,
            "DESCRIÃƒâ€¡ÃƒÆ’O": 300,
            "VALOR": 95,
            "DATA": 95,
            "CATEGORIA": 120,
            "OBSERVAÃƒâ€¡ÃƒÆ’O": 200
        }

        for col in columns:
            self.tree_desp.heading(col, text=col, command=lambda c=col: self._sort_despesas_by_column(c))
            self.tree_desp.column(
                col,
                width=col_widths.get(col, 100),
                minwidth=60,
                anchor="center" if col in ["ID", "VALOR", "DATA"] else "w"
            )

        self.tree_desp.bind("<<TreeviewSelect>>", self._on_select_despesa)
        self.tree_desp.bind("<Double-1>", lambda e: self._editar_linha_selecionada())

        # =========================================================
        # DIREITA (NOTEBOOK)
        # =========================================================
        right_frame = ttk.Frame(middle_frame, style="Card.TFrame")
        right_frame.grid(row=0, column=1, sticky="nsew")
        right_frame.grid_rowconfigure(0, weight=1)
        right_frame.grid_columnconfigure(0, weight=1)

        notebook = ttk.Notebook(right_frame)
        notebook.grid(row=0, column=0, sticky="nsew")

        # =========================================================
        # ---- ABA 1: NOTA FISCAL
        # =========================================================
        tab_nf = ttk.Frame(notebook, padding=10)
        notebook.add(tab_nf, text="Nota Fiscal")
        tab_nf.grid_columnconfigure(1, weight=1)

        calc_frame = ttk.Frame(tab_nf)
        calc_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
        ttk.Button(calc_frame, text="Calcular Saldo Automático", style="Ghost.TButton",
                   command=self._calcular_saldo_auto).pack(fill="x")

        row_nf = 1
        self.ent_nf_numero = self._create_field(tab_nf, "Nº NOTA FISCAL:", row_nf, 20); row_nf += 1
        self.ent_nf_kg = self._create_field(tab_nf, "KG NOTA FISCAL:", row_nf, 20); row_nf += 1
        self.ent_nf_caixas = self._create_field(tab_nf, "CAIXAS:", row_nf, 20); row_nf += 1
        self.ent_nf_kg_carregado = self._create_field(tab_nf, "KG CARREGADO:", row_nf, 20); row_nf += 1
        self.ent_nf_kg_vendido = self._create_field(tab_nf, "KG VENDIDO:", row_nf, 20); row_nf += 1
        self.ent_nf_saldo = self._create_field(tab_nf, "SALDO (KG):", row_nf, 20)

        ttk.Button(tab_nf, text="Sincronizar com App", style="Warn.TButton",
                   command=self._sincronizar_com_app)\
            .grid(row=row_nf + 1, column=0, columnspan=2, sticky="ew", pady=(15, 0))

        # =========================================================
        # ---- ABA 2: DADOS DA ROTA
        # =========================================================
        tab_rota = ttk.Frame(notebook, padding=10)
        notebook.add(tab_rota, text="Dados da Rota")
        tab_rota.grid_columnconfigure(1, weight=1)

        calc_km_frame = ttk.Frame(tab_rota)
        calc_km_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))
        ttk.Button(calc_km_frame, text="Calcular KM/Média", style="Ghost.TButton",
                   command=self._calcular_km_media).pack(fill="x")

        row_km = 1
        self.ent_km_inicial = self._create_field(tab_rota, "KM INICIAL:", row_km, 20); row_km += 1
        self.ent_km_final = self._create_field(tab_rota, "KM FINAL:", row_km, 20); row_km += 1
        self.ent_litros = self._create_field(tab_rota, "LITROS:", row_km, 20); row_km += 1
        self.ent_km_rodado = self._create_field(tab_rota, "KM RODADO:", row_km, 20); row_km += 1
        self.ent_media = self._create_field(tab_rota, "MÉDIA (KM/L):", row_km, 20); row_km += 1
        self.ent_custo_km = self._create_field(tab_rota, "CUSTO P/KM:", row_km, 20)

        # =========================================================
        # ---- ABA 3: CONTAGEM DE CÉDULAS
        # =========================================================
        tab_cedulas = ttk.Frame(notebook, padding=6)
        notebook.add(tab_cedulas, text="Contagem Cédulas")
        tab_cedulas.grid_columnconfigure(0, weight=1)
        tab_cedulas.grid_columnconfigure(1, weight=1)
        tab_cedulas.grid_columnconfigure(2, weight=1)

        calc_ced_frame = ttk.Frame(tab_cedulas)
        calc_ced_frame.grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 6))

        ttk.Label(calc_ced_frame, text="Valor Total:", style="CardLabel.TLabel").pack(side="left", padx=(0, 5))
        self.ent_total_dinheiro = ttk.Entry(calc_ced_frame, style="Field.TEntry", width=15)
        self.ent_total_dinheiro.pack(side="left", padx=5)
        self._bind_money_entry(self.ent_total_dinheiro)
        self._bind_focus_scroll(self.ent_total_dinheiro)
        ttk.Button(calc_ced_frame, text="Distribuir", style="Ghost.TButton",
                   command=self._distribuir_cedulas, width=10).pack(side="left", padx=5)

        header_ced = ttk.Frame(tab_cedulas)
        header_ced.grid(row=1, column=0, columnspan=3, sticky="ew", pady=(6, 3))

        ttk.Label(header_ced, text="QTD", width=8, style="CardLabel.TLabel", anchor="center", font=("Segoe UI", 8)).grid(row=0, column=0, sticky="ew")
        ttk.Label(header_ced, text="CÉDULA", width=15, style="CardLabel.TLabel", anchor="center").grid(row=0, column=1)
        ttk.Label(header_ced, text="TOTAL", width=15, style="CardLabel.TLabel", anchor="center", font=("Segoe UI", 8)).grid(row=0, column=2, sticky="ew")

        self.ced_entries = {}
        self.ced_totals = {}
        ced_list = [200, 100, 50, 20, 10, 5, 2]

        for i, ced in enumerate(ced_list, start=2):
            ent = ttk.Entry(tab_cedulas, width=12, style="Field.TEntry", justify="center")
            ent.grid(row=i, column=0, sticky="ew", pady=1, padx=4)
            ent.bind("<KeyRelease>", lambda e: self._calc_valor_dinheiro())
            self._bind_focus_scroll(ent)

            lbl_ced = ttk.Label(
                tab_cedulas,
                text=f"R$ {ced:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."),
                style="CardLabel.TLabel",
                anchor="center"
            )
            lbl_ced.grid(row=i, column=1, sticky="ew", pady=1, padx=4)

            lbl_total = ttk.Label(tab_cedulas, text="R$ 0,00",
                                  font=("Segoe UI", 8, "bold"), anchor="center")
            lbl_total.grid(row=i, column=2, sticky="ew", pady=1, padx=4)

            self.ced_entries[ced] = ent
            self.ced_totals[ced] = lbl_total

        ttk.Separator(tab_cedulas, orient="horizontal")\
            .grid(row=9, column=0, columnspan=3, sticky="ew", pady=6)

        ttk.Label(tab_cedulas, text="TOTAL DINHEIRO:", font=("Segoe UI", 9, "bold"))\
            .grid(row=10, column=0, columnspan=2, sticky="e", pady=3)

        self.lbl_valor_dinheiro = ttk.Label(tab_cedulas, text="R$ 0,00", font=("Segoe UI", 11, "bold"))
        self.lbl_valor_dinheiro.grid(row=10, column=2, sticky="w", pady=3, padx=4)

        # força atualizar scroll no primeiro render
        # =========================================================
        # ? RESUMO + BOT?ES (como voc? j? tinha)
        # =========================================================
        # =========================================================
        # RESUMO + BOTOES
        # =========================================================
        # =========================================================
        # RESUMO + BOTOES
        # =========================================================
        resumo_frame = ttk.Frame(left_frame, style="Card.TFrame", padding=6)
        resumo_frame.grid(row=1, column=0, sticky="ew", pady=(6, 0))

        ttk.Label(resumo_frame, text="RESUMO FINANCEIRO (CAIXA)",
                  style="CardTitle.TLabel", font=("Segoe UI", 11, "bold"))            .grid(row=0, column=0, sticky="w", columnspan=3, pady=(0, 6))

        for i in range(3):
            resumo_frame.grid_columnconfigure(i, weight=0)

        entrada_frame = ttk.LabelFrame(resumo_frame, text=" ENTRADAS ", padding=6)
        entrada_frame.grid(row=1, column=0, sticky="nw", padx=(0, 6))
        entrada_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(entrada_frame, text="Recebimentos Total:", font=("Segoe UI", 9))            .grid(row=0, column=0, sticky="w", pady=2)
        self.lbl_receb_total = ttk.Label(entrada_frame, text="R$ 0,00", font=("Segoe UI", 10, "bold"))
        self.lbl_receb_total.grid(row=0, column=1, sticky="w", pady=2)

        ttk.Label(entrada_frame, text="Adiantamento p/ Rota:", font=("Segoe UI", 9))            .grid(row=1, column=0, sticky="w", pady=2)
        adiant_frame = ttk.Frame(entrada_frame)
        adiant_frame.grid(row=1, column=1, sticky="w", pady=2)

        self.ent_adiantamento = ttk.Entry(adiant_frame, style="Field.TEntry", width=10)
        self.ent_adiantamento.pack(side="left", padx=(0, 4))
        self.ent_adiantamento.bind("<KeyRelease>", lambda e: self._update_resumo_financeiro())
        self._bind_money_entry(self.ent_adiantamento)

        ttk.Label(entrada_frame, text="Total Entradas:", font=("Segoe UI", 8, "bold"))            .grid(row=2, column=0, sticky="w", pady=(6, 2))
        self.lbl_total_entradas = ttk.Label(entrada_frame, text="R$ 0,00",
                                            font=("Segoe UI", 11, "bold"), foreground="#2E7D32")
        self.lbl_total_entradas.grid(row=2, column=1, sticky="w", pady=(6, 2))

        saida_frame = ttk.LabelFrame(resumo_frame, text=" SAIDAS ", padding=6)
        saida_frame.grid(row=1, column=1, sticky="nw", padx=(0, 6))
        saida_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(saida_frame, text="Despesas Total:", font=("Segoe UI", 9))            .grid(row=0, column=0, sticky="w", pady=2)
        self.lbl_desp_total = ttk.Label(saida_frame, text="R$ 0,00", font=("Segoe UI", 10, "bold"))
        self.lbl_desp_total.grid(row=0, column=1, sticky="w", pady=2)

        ttk.Label(saida_frame, text="Contagem Cedulas:", font=("Segoe UI", 9))            .grid(row=1, column=0, sticky="w", pady=2)
        self.lbl_cedulas_total = ttk.Label(saida_frame, text="R$ 0,00", font=("Segoe UI", 10, "bold"))
        self.lbl_cedulas_total.grid(row=1, column=1, sticky="w", pady=2)

        ttk.Label(saida_frame, text="Total Saidas:", font=("Segoe UI", 8, "bold"))            .grid(row=2, column=0, sticky="w", pady=(6, 2))
        self.lbl_total_saidas = ttk.Label(saida_frame, text="R$ 0,00",
                                          font=("Segoe UI", 11, "bold"), foreground="#C62828")
        self.lbl_total_saidas.grid(row=2, column=1, sticky="w", pady=(6, 2))

        resultado_frame = ttk.LabelFrame(resumo_frame, text=" RESULTADOS ", padding=6)
        resultado_frame.grid(row=1, column=2, sticky="nw")
        resultado_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(resultado_frame, text="Valor p/ Caixa:", font=("Segoe UI", 9))            .grid(row=0, column=0, sticky="w", pady=2)
        self.lbl_valor_final_caixa = ttk.Label(resultado_frame, text="R$ 0,00", font=("Segoe UI", 10, "bold"))
        self.lbl_valor_final_caixa.grid(row=0, column=1, sticky="w", pady=2)

        ttk.Label(resultado_frame, text="Diferenca (Caixa - Ced):", font=("Segoe UI", 9))            .grid(row=1, column=0, sticky="w", pady=2)
        self.lbl_diferenca = ttk.Label(resultado_frame, text="R$ 0,00", font=("Segoe UI", 10, "bold"))
        self.lbl_diferenca.grid(row=1, column=1, sticky="w", pady=2)

        ttk.Label(resultado_frame, text="Resultado Liquido:", font=("Segoe UI", 8, "bold"))            .grid(row=2, column=0, sticky="w", pady=(6, 2))
        self.lbl_resultado_liquido = ttk.Label(resultado_frame, text="R$ 0,00", font=("Segoe UI", 12, "bold"))
        self.lbl_resultado_liquido.grid(row=2, column=1, sticky="w", pady=(6, 2))

        diarias_frame = ttk.LabelFrame(resumo_frame, text=" DIARIAS ", padding=6)
        diarias_frame.grid(row=2, column=0, columnspan=3, sticky="w", pady=(6, 0))
        diarias_frame.grid_columnconfigure(5, weight=1)

        ttk.Label(diarias_frame, text="Diaria Ajudante (R$):", font=("Segoe UI", 9))            .grid(row=0, column=0, sticky="w", pady=2)
        self.ent_diaria_ajudante = ttk.Entry(diarias_frame, style="Field.TEntry", width=10)
        self.ent_diaria_ajudante.grid(row=0, column=1, sticky="w", padx=(6, 10), pady=2)
        self.ent_diaria_ajudante.insert(0, "0,00")
        self._bind_money_entry(self.ent_diaria_ajudante)
        self.ent_diaria_ajudante.bind("<KeyRelease>", lambda e: self._update_diarias())

        self.lbl_diaria_motorista = ttk.Label(diarias_frame, text="Diaria Motorista: R$ 0,00", font=("Segoe UI", 8, "bold"))
        self.lbl_diaria_motorista.grid(row=0, column=2, sticky="w", pady=2)

        self.lbl_total_diarias = ttk.Label(diarias_frame, text="Qtd Diarias: 0", font=("Segoe UI", 9))
        self.lbl_total_diarias.grid(row=0, column=3, sticky="w", padx=(12, 0), pady=2)

        self.lbl_total_pagto = ttk.Label(diarias_frame, text="Total Pagamento (Motorista + 2 Ajudantes): R$ 0,00", font=("Segoe UI", 8, "bold"))
        self.lbl_total_pagto.grid(row=0, column=4, sticky="w", padx=(12, 0), pady=2)

        botoes_frame = ttk.Frame(page_card, style="Card.TFrame")
        botoes_frame.grid(row=4, column=0, sticky="ew")

        for i in range(6):
            botoes_frame.grid_columnconfigure(i, weight=1)

        botoes = [
            ("VOLTAR", "Ghost.TButton", self._voltar_recebimentos),
            ("ADICIONAR DESPESA", "Warn.TButton", self._open_registrar_rapido),
            ("IMPRIMIR PDF", "Ghost.TButton", self.imprimir_resumo),
            ("SALVAR", "Primary.TButton", self.salvar_tudo),
            ("EDITAR", "Warn.TButton", self._editar_linha_selecionada),
            ("FINALIZAR", "Danger.TButton", self.finalizar_prestacao_despesas),
        ]

        for i, (texto, estilo, comando) in enumerate(botoes):
            btn = ttk.Button(botoes_frame, text=texto, style=estilo, command=comando)
            btn.grid(row=0, column=i, sticky="ew", padx=2, ipady=8)

        # âœ… carrega dados
        self.refresh_comboboxes()
        self._refresh_all()

# ==========================
# ===== FIM DA PARTE 7 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INICIO DA PARTE 7B (ATUALIZADA) =====
# ==========================

    # =========================================================
    # 7.2 UTILITRIOS / LOAD / FILTROS / CLCULOS
    # =========================================================
    def _scroll_to_widget(self, widget):
        try:
            canvas = getattr(self, "_nb_canvas", None)
            if not canvas:
                return
            self.update_idletasks()
            bbox = canvas.bbox("all")
            if not bbox:
                return
            view_top = canvas.canvasy(0)
            view_bottom = view_top + canvas.winfo_height()
            y = widget.winfo_rooty() - canvas.winfo_rooty() + view_top
            h = widget.winfo_height()
            total_h = (bbox[3] - bbox[1]) or 1
            if y < view_top + 20:
                canvas.yview_moveto(max(0, (y - 20) / total_h))
            elif (y + h) > (view_bottom - 20):
                canvas.yview_moveto(max(0, (y - 20) / total_h))
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _bind_focus_scroll(self, widget):
        try:
            widget.bind("<FocusIn>", lambda e: self._scroll_to_widget(widget), add=True)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _bind_focus_scroll_tree(self, parent):
        try:
            for child in parent.winfo_children():
                try:
                    child.bind("<FocusIn>", lambda e, w=child: self._scroll_to_widget(w), add=True)
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)
                self._bind_focus_scroll_tree(child)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _create_field(self, parent, label, row, width=20):
        ttk.Label(parent, text=label, style="CardLabel.TLabel").grid(row=row, column=0, sticky="w", pady=2)
        ent = ttk.Entry(parent, style="Field.TEntry", width=width)
        ent.grid(row=row, column=1, sticky="ew", pady=2, padx=(10, 0))
        self._bind_focus_scroll(ent)
        return ent

    def _parse_dt(self, data_str: str, hora_str: str):
        data_str = (data_str or "").strip()
        hora_str = (hora_str or "").strip()
        if not data_str:
            return None
        # aceita yyyy-mm-dd ou dd/mm/yyyy
        try:
            if "-" in data_str and len(data_str) >= 10:
                y, m, d = data_str[:10].split("-")
            elif "/" in data_str and len(data_str) >= 10:
                d, m, y = data_str[:10].split("/")
            else:
                return None
            hh, mm = "00", "00"
            if hora_str and ":" in hora_str:
                hh, mm = hora_str.split(":")[:2]
            return datetime(int(y), int(m), int(d), int(hh), int(mm))
        except Exception:
            return None

    def _calc_qtd_diarias(self):
        dt_saida = self._parse_dt(self._data_saida, self._hora_saida)
        dt_chegada = self._parse_dt(self._data_chegada, self._hora_chegada)
        if not dt_saida:
            return 0.0
        if not dt_chegada or dt_chegada <= dt_saida:
            return 1.0
        horas = (dt_chegada - dt_saida).total_seconds() / 3600.0
        if horas <= 24.0:
            return 1.0
        rem = horas - 24.0
        full = int(rem // 24.0)
        half = 0.5 if (rem - (full * 24.0)) > 0 else 0.0
        return 1.0 + full + half

    def _update_diarias(self):
        try:
            val_ajud = self._parse_money_local(self.ent_diaria_ajudante.get())
        except Exception:
            val_ajud = 0.0
        val_mot = val_ajud + 10.0 if val_ajud > 0 else 0.0
        qtd = self._calc_qtd_diarias()

        self.lbl_diaria_motorista.config(text=f"Diaria Motorista: {self._fmt_money(val_mot)}")
        self.lbl_total_diarias.config(text=f"Qtd Diarias: {qtd:g}")

        total = (val_mot + (val_ajud * 2)) * qtd
        self.lbl_total_pagto.config(text=f"Total Pagamento (Motorista + 2 Ajudantes): {self._fmt_money(total)}")

    # ---- helpers seguros (não mudam regra, só evitam bug)
    def _parse_money(self, v):
        return safe_money(v, 0.0)

    def _fmt_money(self, v):
        try:
            valor = float(v or 0.0)
            return f"R$ {valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
        except Exception:
            return "R$ 0,00"

    def _load_despesas(self, prog):
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT id, descricao, valor, data_registro,
                       COALESCE(categoria, 'OUTROS') as categoria,
                       COALESCE(observacao, '') as observacao
                FROM despesas
                WHERE codigo_programacao=?
                ORDER BY data_registro DESC
            """, (prog,))
            rows = cur.fetchall()

        for i in self.tree_desp.get_children():
            self.tree_desp.delete(i)

        total_despesas = 0.0
        for idx, (rid, desc, val, data_reg, categoria, observacao) in enumerate(rows):
            data_formatada = data_reg[:10] if data_reg else ""
            tag = "odd" if idx % 2 else ""
            self.tree_desp.insert("", "end", values=(
                rid,
                desc or "",
                self._fmt_money(val),
                data_formatada,
                categoria or "OUTROS",
                (observacao or "")[:50]
            ), tags=(tag,) if tag else ())
            total_despesas += safe_float(val, 0.0)

        self._ajustar_largura_colunas()
        self.lbl_stats.config(text=f"Despesas: {len(rows)} | Total: {self._fmt_money(total_despesas)}")
        self.set_status(f"STATUS: {len(rows)} despesas carregadas")

    def _ajustar_largura_colunas(self):
        for col in self.tree_desp["columns"]:
            if col == "ID":
                self.tree_desp.column(col, width=55, minwidth=55)
            elif col == "VALOR":
                self.tree_desp.column(col, width=95, minwidth=80)
            elif col == "DATA":
                self.tree_desp.column(col, width=95, minwidth=80)
            elif col == "CATEGORIA":
                self.tree_desp.column(col, width=120, minwidth=100)
            elif col in {"OBSERVAO", "OBSERVAO"}:
                self.tree_desp.column(col, width=200, minwidth=140)
            elif col in {"DESCRIO", "DESCRIO"}:
                self.tree_desp.column(col, width=300, minwidth=180)

    def _filtrar_despesas(self):
        if not hasattr(self, "ent_busca_despesa"):
            return
        busca = upper(self.ent_busca_despesa.get().strip())
        if not self._current_programacao:
            return

        if not busca:
            self._load_despesas(self._current_programacao)
            return

        # Usa UPPER no SQL para não depender do padrão de gravação no banco
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT id, descricao, valor, data_registro,
                       COALESCE(categoria, 'OUTROS') as categoria,
                       COALESCE(observacao, '') as observacao
                FROM despesas
                WHERE codigo_programacao=?
                  AND (
                        UPPER(descricao) LIKE ?
                     OR UPPER(COALESCE(categoria,'')) LIKE ?
                     OR UPPER(COALESCE(observacao,'')) LIKE ?
                  )
                ORDER BY data_registro DESC
            """, (self._current_programacao, f"%{busca}%", f"%{busca}%", f"%{busca}%"))
            rows = cur.fetchall()

        for i in self.tree_desp.get_children():
            self.tree_desp.delete(i)

        for idx, (rid, desc, val, data_reg, categoria, observacao) in enumerate(rows):
            data_formatada = data_reg[:10] if data_reg else ""
            tag = "odd" if idx % 2 else ""
            self.tree_desp.insert("", "end", values=(
                rid,
                desc or "",
                self._fmt_money(val),
                data_formatada,
                categoria or "OUTROS",
                (observacao or "")[:50]
            ), tags=(tag,) if tag else ())

        self.set_status(f"STATUS: {len(rows)} despesas encontradas para '{busca}'")

    def _refresh_all(self):
        # evita refazer trabalho excessivo se nada selecionado
        self.refresh_comboboxes()
        self._load_by_programacao()
        self.set_status("STATUS: Todos os dados atualizados")

    def _voltar_recebimentos(self):
        try:
            self.app.show_page("Recebimentos")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def set_programacao(self, prog: str):
        prog = upper(str(prog or "").strip())
        if not prog:
            return
        try:
            if hasattr(self, "refresh_comboboxes"):
                self.refresh_comboboxes()
            try:
                vals = list(self.cb_prog["values"])
            except Exception:
                vals = []
            if prog not in vals:
                vals = [prog] + vals
                self.cb_prog["values"] = vals
            self.cb_prog.set(prog)
            self._load_by_programacao()
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _load_by_programacao(self):
        selecionado = self.cb_prog.get()
        if not selecionado:
            for i in self.tree_desp.get_children():
                self.tree_desp.delete(i)
            self.lbl_motorista.config(text="Motorista: Ã¢â‚¬â€ | VeÃƒÂ­culo: Ã¢â‚¬â€ | Equipe: Ã¢â‚¬â€")
            self.lbl_stats.config(text="Despesas: 0 | Total: R$ 0,00")
            self._reset_campos()
            self._update_resumo_financeiro()
            return

        prog = selecionado.split(" ")[0]
        self._current_programacao = prog

        self._load_despesas(prog)
        self._load_programacao_extras(prog)
        self._calc_valor_dinheiro()
        self._update_resumo_financeiro()
        self.logger.info(f"Programação carregada: {prog}")

    def _reset_campos(self):
        # NF
        for attr in ("ent_nf_numero", "ent_nf_kg", "ent_nf_caixas",
                     "ent_nf_kg_carregado", "ent_nf_kg_vendido", "ent_nf_saldo"):
            field = getattr(self, attr, None)
            if field:
                field.delete(0, "end")

        # Rota / KM
        for attr in ("ent_km_inicial", "ent_km_final", "ent_litros",
                     "ent_km_rodado", "ent_media", "ent_custo_km"):
            field = getattr(self, attr, None)
            if field:
                field.delete(0, "end")

        # Cédulas
        for ced in self.ced_entries.values():
            ced.delete(0, "end")
            ced.insert(0, "0")

        # Adiantamento
        self.ent_adiantamento.delete(0, "end")
        self.ent_adiantamento.insert(0, "0")

        # Total dinheiro
        self.ent_total_dinheiro.delete(0, "end")
        self.ent_total_dinheiro.insert(0, "0")

        self.lbl_valor_dinheiro.config(text="R$ 0,00")

        for lbl in self.ced_totals.values():
            lbl.config(text="R$ 0,00")

    def _load_programacao_extras(self, prog):
        row = None
        cols_all = []
        col_adiant = None
        has_data_saida = False
        has_hora_saida = False
        has_data_chegada = False
        has_hora_chegada = False

        with get_db() as conn:
            cur = conn.cursor()

            # coluna de adiantamento com fallback seguro
            try:
                cur.execute("PRAGMA table_info(programacoes)")
                cols_all = [c[1] for c in cur.fetchall()]
            except Exception:
                cols_all = []

            col_adiant = "adiantamento" if "adiantamento" in cols_all else ("adiantamento_rota" if "adiantamento_rota" in cols_all else None)

            has_data_saida = "data_saida" in cols_all
            has_hora_saida = "hora_saida" in cols_all
            has_data_chegada = "data_chegada" in cols_all
            has_hora_chegada = "hora_chegada" in cols_all

            select_cols = [
                "motorista",
                "veiculo",
                "equipe",
                "nf_numero", "nf_kg", "nf_caixas", "nf_kg_carregado", "nf_kg_vendido", "nf_saldo",
                "km_inicial", "km_final", "litros", "km_rodado", "media_km_l", "custo_km",
                "ced_200_qtd", "ced_100_qtd", "ced_50_qtd", "ced_20_qtd", "ced_10_qtd", "ced_5_qtd", "ced_2_qtd",
                "valor_dinheiro",
            ]
            if col_adiant:
                select_cols.append(col_adiant)
            if has_data_saida:
                select_cols.append("data_saida")
            if has_hora_saida:
                select_cols.append("hora_saida")
            if has_data_chegada:
                select_cols.append("data_chegada")
            if has_hora_chegada:
                select_cols.append("hora_chegada")

            try:
                cur.execute(f"""
                    SELECT {', '.join(select_cols)}
                    FROM programacoes
                    WHERE codigo_programacao=?
                """, (prog,))
                row = cur.fetchone()
            except Exception as e:
                self.logger.error(f"Erro ao carregar extras: {e}")
                row = None

        if not row:
            self.lbl_motorista.config(text="Motorista: - | Veiculo: - | Equipe: -")
            return

        idx = 0
        motorista = row[idx]; idx += 1
        veiculo = row[idx]; idx += 1
        equipe = row[idx]; idx += 1
        nf_numero = row[idx]; idx += 1
        nf_kg = row[idx]; idx += 1
        nf_caixas = row[idx]; idx += 1
        nf_kg_carregado = row[idx]; idx += 1
        nf_kg_vendido = row[idx]; idx += 1
        nf_saldo = row[idx]; idx += 1
        km_inicial = row[idx]; idx += 1
        km_final = row[idx]; idx += 1
        litros = row[idx]; idx += 1
        km_rodado = row[idx]; idx += 1
        media_km_l = row[idx]; idx += 1
        custo_km = row[idx]; idx += 1
        q200 = row[idx]; idx += 1
        q100 = row[idx]; idx += 1
        q50 = row[idx]; idx += 1
        q20 = row[idx]; idx += 1
        q10 = row[idx]; idx += 1
        q5 = row[idx]; idx += 1
        q2 = row[idx]; idx += 1
        valor_dinheiro = row[idx]; idx += 1

        if col_adiant:
            adiant_val = row[idx]; idx += 1
        else:
            adiant_val = 0

        self._data_saida = ""
        self._hora_saida = ""
        self._data_chegada = ""
        self._hora_chegada = ""
        if has_data_saida:
            self._data_saida = row[idx] or ""; idx += 1
        if has_hora_saida:
            self._hora_saida = row[idx] or ""; idx += 1
        if has_data_chegada:
            self._data_chegada = row[idx] or ""; idx += 1
        if has_hora_chegada:
            self._hora_chegada = row[idx] or ""; idx += 1

        self._data_saida, self._hora_saida = normalize_date_time_components(self._data_saida, self._hora_saida)
        self._data_chegada, self._hora_chegada = normalize_date_time_components(self._data_chegada, self._hora_chegada)

        equipe_nomes = resolve_equipe_nomes(equipe)
        self.lbl_motorista.config(
            text=f"Motorista: {motorista or '-'} | Veículo: {veiculo or '-'} | Equipe: {equipe_nomes or '-'}"
        )

        self.ent_adiantamento.delete(0, "end")
        self.ent_adiantamento.insert(0, f"{safe_float(adiant_val, 0.0):.2f}".replace(".", ","))

    def _set_ent(self, ent, val):
        ent.delete(0, "end")
        ent.insert(0, str(val if val is not None else ""))

    def _calc_valor_dinheiro(self):
        total = 0.0
        for ced, ent in self.ced_entries.items():
            try:
                qtd = int(str(ent.get() or "0").strip())
            except Exception:
                qtd = 0
            linha_total = qtd * float(ced)
            total += linha_total
            self.ced_totals[ced].config(text=self._fmt_money(linha_total))

        self.lbl_valor_dinheiro.config(text=self._fmt_money(total))
        self._update_resumo_financeiro()

    def _update_resumo_financeiro(self):
        prog = self._current_programacao
        if not prog:
            self._reset_resumo()
            return

        with get_db() as conn:
            cur = conn.cursor()

            cur.execute("SELECT SUM(valor) FROM despesas WHERE codigo_programacao=?", (prog,))
            row = cur.fetchone()
            total_desp = float(row[0]) if row and row[0] else 0.0

            total_receb = 0.0
            try:
                cur.execute("SELECT SUM(valor) FROM recebimentos WHERE codigo_programacao=?", (prog,))
                row = cur.fetchone()
                total_receb = float(row[0]) if row and row[0] else 0.0
            except Exception:
                total_receb = 0.0

        ced_total = 0.0
        for ced, ent in self.ced_entries.items():
            try:
                qtd = int(str(ent.get() or "0").strip())
            except Exception:
                qtd = 0
            ced_total += qtd * float(ced)

        try:
            adiant = self._parse_money(self.ent_adiantamento.get())
        except Exception:
            adiant = 0.0

        total_entradas = total_receb + adiant
        total_saidas = total_desp + ced_total
        valor_final_caixa = total_entradas - total_desp
        diferenca = valor_final_caixa - ced_total
        resultado_liquido = total_entradas - total_saidas

        self.lbl_receb_total.config(text=self._fmt_money(total_receb))
        self.lbl_desp_total.config(text=self._fmt_money(total_desp))
        self.lbl_cedulas_total.config(text=self._fmt_money(ced_total))
        self.lbl_total_entradas.config(text=self._fmt_money(total_entradas))
        self.lbl_total_saidas.config(text=self._fmt_money(total_saidas))
        self.lbl_valor_final_caixa.config(text=self._fmt_money(valor_final_caixa))
        self.lbl_diferenca.config(text=self._fmt_money(diferenca))
        self.lbl_resultado_liquido.config(text=self._fmt_money(resultado_liquido))

        self.lbl_resultado_liquido.config(foreground="#2E7D32" if resultado_liquido >= 0 else "#C62828")

    def _reset_resumo(self):
        self.lbl_receb_total.config(text="R$ 0,00")
        self.lbl_desp_total.config(text="R$ 0,00")
        self.lbl_cedulas_total.config(text="R$ 0,00")
        self.lbl_total_entradas.config(text="R$ 0,00")
        self.lbl_total_saidas.config(text="R$ 0,00")
        self.lbl_valor_final_caixa.config(text="R$ 0,00")
        self.lbl_diferenca.config(text="R$ 0,00")
        self.lbl_resultado_liquido.config(text="R$ 0,00")

    # =========================================================
    # 7.3 EVENTOS / FILTROS / ORDENAÇÃO
    # =========================================================
    def _on_select_despesa(self, event=None):
        sel = self.tree_desp.selection()
        if not sel:
            self.selected_despesa_id = None
            return
        vals = self.tree_desp.item(sel[0], "values")
        self.selected_despesa_id = vals[0] if vals else None

    def _aplicar_filtro_mes(self):
        return

    def _sort_despesas_by_column(self, col):
        # estado simples (mantém comportamento previsível)
        if not hasattr(self, "_sort_state"):
            self._sort_state = {"col": None, "reverse": False}

        if self._sort_state["col"] == col:
            self._sort_state["reverse"] = not self._sort_state["reverse"]
        else:
            self._sort_state["col"] = col
            self._sort_state["reverse"] = False

        reverse = self._sort_state["reverse"]
        data = [(self.tree_desp.set(child, col), child) for child in self.tree_desp.get_children("")]

        if col == "VALOR":
            data.sort(key=lambda x: self._parse_money(x[0]), reverse=reverse)
        elif col == "DATA":
            data.sort(key=lambda x: str(x[0] or ""), reverse=reverse)
            data.sort(key=lambda x: safe_int(x[0], 0), reverse=reverse)
        else:
            data.sort(key=lambda x: str(x[0] or "").upper(), reverse=reverse)

        for idx, (_, child) in enumerate(data):
            self.tree_desp.move(child, "", idx)

        # seta setinha no cabeçalho (igual seu padrão em outras telas)
        arrow = " Ã¢â€ â€œ" if reverse else " Ã¢â€ â€˜"
        for c in self.tree_desp["columns"]:
            txt = self.tree_desp.heading(c)["text"]
            if txt.endswith(" Ã¢â€ â€˜") or txt.endswith(" Ã¢â€ â€œ"):
                txt = txt[:-2]
            self.tree_desp.heading(c, text=txt)

        txt = self.tree_desp.heading(col)["text"]
        if txt.endswith(" Ã¢â€ â€˜") or txt.endswith(" Ã¢â€ â€œ"):
            txt = txt[:-2]
        self.tree_desp.heading(col, text=txt + arrow)

    def _limpar_busca_despesas(self):
        if not hasattr(self, "ent_busca_despesa"):
            return
        self.ent_busca_despesa.delete(0, "end")
        if self._current_programacao:
            self._load_despesas(self._current_programacao)
        self.set_status("STATUS: Busca limpa")

    # =========================================================
    # 7.4 CÃƒÂLCULOS AUTOMÃƒÂTICOS / SINCRONIZAÃƒâ€¡ÃƒÆ’O SIMULADA
    # =========================================================
    def _calcular_saldo_auto(self):
        try:
            carregado = safe_float(self.ent_nf_kg_carregado.get(), 0.0)
            vendido = safe_float(self.ent_nf_kg_vendido.get(), 0.0)
            saldo = carregado - vendido

            try:
                self.ent_nf_saldo.delete(0, "end")
                self.ent_nf_saldo.insert(0, f"{saldo:.2f}")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            self.set_status(f"STATUS: Saldo calculado: {saldo:.2f} kg")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao calcular saldo: {str(e)}")

    def _calcular_km_media(self):
        try:
            km_inicial = safe_float(self.ent_km_inicial.get(), 0.0)
            km_final = safe_float(self.ent_km_final.get(), 0.0)
            litros = safe_float(self.ent_litros.get(), 0.0)

            km_rodado = km_final - km_inicial
            if km_rodado < 0:
                km_rodado = 0.0

            media = (km_rodado / litros) if litros > 0 else 0.0

            # mantém seu cálculo, só evita valores estranhos
            custo_km = ((litros * 5.5) / km_rodado) if km_rodado > 0 else 0.0

            self.ent_km_rodado.delete(0, "end")
            self.ent_km_rodado.insert(0, f"{km_rodado:.1f}")

            self.ent_media.delete(0, "end")
            self.ent_media.insert(0, f"{media:.1f}")

            self.ent_custo_km.delete(0, "end")
            self.ent_custo_km.insert(0, f"{custo_km:.2f}")

            self.set_status(f"STATUS: KM rodado: {km_rodado:.1f} km | Média: {media:.1f} km/l")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao calcular KM/média: {str(e)}")

    def _distribuir_cedulas(self):
        try:
            valor_total = self._parse_money(self.ent_total_dinheiro.get())
            if valor_total <= 0:
                messagebox.showwarning("Atenção", "Digite um valor total válido.")
                return

            cedulas = [200, 100, 50, 20, 10, 5, 2]
            restante = float(valor_total)

            for ced in cedulas:
                self.ced_entries[ced].delete(0, "end")
                self.ced_entries[ced].insert(0, "0")

            for ced in cedulas:
                if restante >= ced:
                    quantidade = int(restante // ced)
                    self.ced_entries[ced].delete(0, "end")
                    self.ced_entries[ced].insert(0, str(quantidade))
                    restante -= quantidade * ced

            # arredondamento: se sobrar qualquer centavo, ajusta na menor cédula
            if restante > 0:
                atual = safe_int(self.ced_entries[2].get(), 0)
                self.ced_entries[2].delete(0, "end")
                self.ced_entries[2].insert(0, str(atual + 1))

            self._calc_valor_dinheiro()
            self.set_status(f"STATUS: Valor {self._fmt_money(valor_total)} distribuído automaticamente")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao distribuir cédulas: {str(e)}")

    def _sincronizar_com_app(self):
        if not self._current_programacao:
            messagebox.showwarning("Sincronização", "Selecione a programação primeiro.")
            return

        prog = self._current_programacao
        motor_hint = self._fetch_motorista_codigo_hint(prog)
        creds = self._prompt_sync_credentials(motor_hint)
        if not creds:
            return
        codigo, senha = creds

        try:
            token = self._api_login(codigo, senha)
            resposta = _call_api("GET", f"rotas/{prog}", token=token)
            rota = resposta.get("rota")
            if not rota:
                raise SyncError("A API não retornou os dados da rota.")
            clientes = resposta.get("clientes") or []

            with get_db() as conn:
                cur = conn.cursor()
                self._apply_api_programacao(cur, prog, rota)
                self._apply_api_clientes(cur, prog, clientes)
                conn.commit()

            self._populate_route_entries(rota)
            self._load_by_programacao()
            self._calcular_km_media()
            self._calcular_saldo_auto()

            self.logger.info("Sincronização com App Mobile concluída para %s", prog)
            messagebox.showinfo("Sincronização", "Dados sincronizados com sucesso.")
        except SyncError as exc:
            self.logger.error("Falha ao sincronizar com o App: %s", exc)
            messagebox.showerror("Sincronização", f"Falha ao sincronizar: {exc}")
        except Exception as exc:
            logging.exception("Erro inesperado na sincronização", exc_info=exc)
            messagebox.showerror("Sincronização", f"Erro inesperado: {exc}")

    def _prompt_sync_credentials(self, default_code: str):
        title = "Sincronização App Mobile"
        codigo = simpledialog.askstring(
            title,
            "Código do motorista utilizado no App Mobile:",
            initialvalue=(default_code or ""),
            parent=self,
        )
        if codigo is None:
            return None
        codigo = codigo.strip()
        if not codigo:
            messagebox.showwarning("Sincronização", "Código do motorista é obrigatório.")
            return None

        senha = simpledialog.askstring(
            title,
            f"Senha do motorista {codigo}:",
            show="*",
            parent=self,
        )
        if senha is None:
            return None
        senha = senha.strip()
        if not senha:
            messagebox.showwarning("Sincronização", "Senha do motorista é obrigatória.")
            return None

        return codigo, senha

    def _fetch_motorista_codigo_hint(self, prog: str) -> str:
        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute(
                    "SELECT motorista_id, motorista FROM programacoes WHERE codigo_programacao=? LIMIT 1",
                    (prog,),
                )
                row = cur.fetchone()
                if not row:
                    return ""
                motorista_id = row["motorista_id"]
                if motorista_id:
                    cur.execute("SELECT codigo FROM motoristas WHERE id=? LIMIT 1", (motorista_id,))
                    mrow = cur.fetchone()
                    if mrow and mrow["codigo"]:
                        return mrow["codigo"]
                return (row["motorista"] or "").strip()
        except Exception:
            return ""

    def _api_login(self, codigo: str, senha: str) -> str:
        if not API_BASE_URL:
            raise SyncError("ROTA_SERVER_URL não configurada.")
        resposta = _call_api("POST", "auth/motorista/login", payload={"codigo": codigo, "senha": senha})
        token = resposta.get("token")
        if not token:
            raise SyncError("Não foi possível obter token da API de sincronização.")
        return token

    def _apply_api_programacao(self, cur, prog: str, rota: dict):
        campos = [
            "nf_numero",
            "nf_kg",
            "nf_caixas",
            "nf_kg_carregado",
            "nf_kg_vendido",
            "nf_saldo",
            "km_inicial",
            "km_final",
            "litros",
            "km_rodado",
            "media_km_l",
            "custo_km",
        ]
        updates = []
        valores = []
        for campo in campos:
            if campo in rota:
                updates.append(f"{campo}=?")
                valores.append(rota.get(campo))
        if not updates:
            return
        cur.execute(
            f"UPDATE programacoes SET {', '.join(updates)} WHERE codigo_programacao=?",
            (*valores, prog),
        )

    def _apply_api_clientes(self, cur, prog: str, clientes):
        if not clientes:
            return
        ctrl_cols = [
            "mortalidade_aves",
            "media_aplicada",
            "peso_previsto",
            "valor_recebido",
            "forma_recebimento",
            "obs_recebimento",
            "status_pedido",
            "alteracao_tipo",
            "alteracao_detalhe",
            "pedido",
            "caixas_atual",
            "preco_atual",
            "alterado_em",
            "alterado_por",
        ]
        cols_sql = ", ".join(ctrl_cols)
        placeholders = ", ".join("?" for _ in ctrl_cols)
        update_sql = ", ".join(f"{col}=excluded.{col}" for col in ctrl_cols)
        sql = f"""
            INSERT INTO programacao_itens_controle
                (codigo_programacao, cod_cliente, {cols_sql}, updated_at)
            VALUES (?, ?, {placeholders}, datetime('now'))
            ON CONFLICT(codigo_programacao, cod_cliente)
            DO UPDATE SET
                {update_sql},
                updated_at=datetime('now')
        """
        for cliente in clientes:
            cod_cliente = (cliente.get("cod_cliente") or "").strip()
            if not cod_cliente:
                continue
            valores = [cliente.get(col) for col in ctrl_cols]
            cur.execute(sql, (prog, cod_cliente, *valores))

    def _populate_route_entries(self, rota: dict):
        campos = [
            ("nf_numero", self.ent_nf_numero),
            ("nf_kg", self.ent_nf_kg),
            ("nf_caixas", self.ent_nf_caixas),
            ("nf_kg_carregado", self.ent_nf_kg_carregado),
            ("nf_kg_vendido", self.ent_nf_kg_vendido),
            ("nf_saldo", self.ent_nf_saldo),
            ("km_inicial", self.ent_km_inicial),
            ("km_final", self.ent_km_final),
            ("litros", self.ent_litros),
            ("km_rodado", self.ent_km_rodado),
            ("media_km_l", self.ent_media),
            ("custo_km", self.ent_custo_km),
        ]
        for key, entry in campos:
            if not entry:
                continue
            self._set_ent(entry, rota.get(key))

    # =========================================================
    # 7.5 PageBase (refresh / on_show / status)
    # =========================================================
    def refresh_comboboxes(self):
        with get_db() as conn:
            cur = conn.cursor()
            try:
                cur.execute("""
                    SELECT codigo_programacao, data_criacao
                    FROM programacoes
                    WHERE status='ATIVA' OR status='FINALIZADA'
                    ORDER BY id DESC
                    LIMIT 300
                """)
            except Exception:
                cur.execute("SELECT codigo_programacao, data_criacao FROM programacoes ORDER BY id DESC LIMIT 300")

            programas = []
            for row in cur.fetchall():
                codigo = row[0]
                data = row[1][:10] if row[1] else "Sem data"
                programas.append(f"{codigo} ({data})")

            self.cb_prog["values"] = programas

    def on_show(self):
        self.refresh_comboboxes()
        self._refresh_all()
        self.set_status("STATUS: Despesas da rota e controle completo (NF / KM / Dinheiro).")
        self.logger.info("Página Despesas carregada")

    def set_status(self, text):
        try:
            PageBase.set_status(self, text)
        except Exception:
            try:
                self.lbl_status.config(text=text)
            except Exception:
                print(f"STATUS: {text}")

# ==========================
# ===== FIM DA PARTE 7B (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INICIO DA PARTE 7C (ATUALIZADA) =====
# ==========================

    # =========================================================
    # 7.6 CRUD DESPESAS (REGISTRAR / EDITAR / EXCLUIR)
    # =========================================================

    # --------- REGRAS DE SEGURANÇA (não altera sistema; só bloqueia quando necessário)
    def _get_prestacao_status(self, prog: str) -> str:
        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("SELECT COALESCE(prestacao_status,'') FROM programacoes WHERE codigo_programacao=? LIMIT 1", (prog,))
                row = cur.fetchone()
            return upper(row[0] if row else "")
        except Exception:
            return ""

    def _can_edit_current_prog(self) -> bool:
        prog = self._current_programacao
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione a Programação primeiro.")
            return False

        status = self._get_prestacao_status(prog)
        if status == "FECHADA":
            messagebox.showwarning(
                "BLOQUEADO",
                f"Esta programação ({prog}) está com a prestação FECHADA.\n\n"
                "Por segurança, não é permitido registrar/editar/excluir despesas."
            )
            return False
        return True

    def finalizar_prestacao_despesas(self):
        prog = self._current_programacao
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione a Programação primeiro.")
            return

        status = self._get_prestacao_status(prog)
        if status == "FECHADA":
            messagebox.showinfo("PrestaÃ§Ã£o", "Esta prestaÃ§Ã£o jÃ¡ estÃ¡ FECHADA.")
            return

        if not messagebox.askyesno(
            "Confirmar",
            f"Finalizar prestação de contas da rota {prog}?\n\n"
            "A programaÃ§Ã£o serÃ¡ finalizada."
        ):
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("""
                    UPDATE programacoes
                    SET prestacao_status='FECHADA', status='FINALIZADA'
                    WHERE codigo_programacao=?
                """, (prog,))

            messagebox.showinfo("OK", f"Prestação finalizada: {prog}")
            self.refresh_comboboxes()
            if hasattr(self.app, "refresh_programacao_comboboxes"):
                try:
                    self.app.refresh_programacao_comboboxes()
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)
            self.set_status(f"STATUS: Prestação finalizada para {prog}")
            self._refresh_all()
        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao finalizar prestação: {str(e)}")

    def _parse_money_local(self, s):
        # garante parse de 'R$ 1.234,56' / '1234,56' / '1234.56'
        return safe_money(s, 0.0)

    def _format_money_from_digits(self, digits: str) -> str:
        digits = re.sub(r"\D", "", str(digits or ""))
        if not digits:
            return "0,00"
        if len(digits) == 1:
            int_part = "0"
            cents = "0" + digits
        elif len(digits) == 2:
            int_part = "0"
            cents = digits
        else:
            int_part = digits[:-2]
            cents = digits[-2:]

        parts = []
        while len(int_part) > 3:
            parts.insert(0, int_part[-3:])
            int_part = int_part[:-3]
        if int_part:
            parts.insert(0, int_part)
        int_part = ".".join(parts) if parts else "0"
        return f"{int_part},{cents}"

    def _bind_money_entry(self, ent: tk.Entry):
        def _on_focus_in(_e=None):
            try:
                v = str(ent.get() or "").strip()
                if v in {"0", "0,00", "0.00", "R$ 0,00", "R$0,00"}:
                    ent.delete(0, "end")
                else:
                    ent.selection_range(0, "end")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        def _on_key_release(_e=None):
            try:
                v = str(ent.get() or "")
                digits = re.sub(r"\D", "", v)
                if digits:
                    ent.delete(0, "end")
                    ent.insert(0, self._format_money_from_digits(digits))
                    ent.icursor("end")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        def _on_focus_out(_e=None):
            try:
                v = str(ent.get() or "").strip()
                if not v:
                    ent.insert(0, "0,00")
                else:
                    ent.delete(0, "end")
                    ent.insert(0, self._format_money_from_digits(v))
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

        ent.bind("<FocusIn>", _on_focus_in)
        ent.bind("<KeyRelease>", _on_key_release)
        ent.bind("<FocusOut>", _on_focus_out)

    def _get_despesa_info(self, did):
        # retorna (id, codigo_programacao, descricao, valor, categoria)
        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("""
                    SELECT id, codigo_programacao, descricao, valor, COALESCE(categoria,'GERAL')
                    FROM despesas
                    WHERE id=?
                    LIMIT 1
                """, (did,))
                return cur.fetchone()
        except Exception:
            return None

    def _open_registrar_rapido(self):
        if not self._can_edit_current_prog():
            return

        prog = self._current_programacao

        win = tk.Toplevel(self)
        win.title("Registrar Despesa (Rápido)")
        win.geometry("520x360")
        win.grab_set()
        win.resizable(False, False)

        frm = ttk.Frame(win, padding=20)
        frm.pack(fill="both", expand=True)
        frm.grid_columnconfigure(1, weight=1)

        ttk.Label(frm, text="NOVA DESPESA", font=("Segoe UI", 14, "bold"))\
            .grid(row=0, column=0, columnspan=2, pady=(0, 16), sticky="w")

        ttk.Label(frm, text="Descrição:", font=("Segoe UI", 10, "bold"))\
            .grid(row=1, column=0, sticky="w", pady=5)
        ent_desc = ttk.Entry(frm, style="Field.TEntry")
        ent_desc.grid(row=1, column=1, sticky="ew", pady=5, padx=(10, 0))

        ttk.Label(frm, text="Valor (R$):", font=("Segoe UI", 10, "bold"))\
            .grid(row=2, column=0, sticky="w", pady=5)
        ent_val = ttk.Entry(frm, style="Field.TEntry")
        ent_val.grid(row=2, column=1, sticky="ew", pady=5, padx=(10, 0))
        ent_val.insert(0, "0,00")
        self._bind_money_entry(ent_val)

        ttk.Label(frm, text="Categoria:", font=("Segoe UI", 10, "bold"))\
            .grid(row=3, column=0, sticky="w", pady=5)
        cb_categoria = ttk.Combobox(
            frm, state="readonly", width=22,
            values=["DIARIAS", "COMBUSTIVEL", "SERVICOS NO VEICULOS", "DIARIA EXTRA", "ESTRADA", "BANHO", "OUTROS"]
        )
        cb_categoria.set("OUTROS")
        cb_categoria.grid(row=3, column=1, sticky="w", pady=5, padx=(10, 0))

        ttk.Label(frm, text="Observação:", font=("Segoe UI", 10, "bold"))\
            .grid(row=4, column=0, sticky="w", pady=5)
        ent_obs = tk.Text(frm, height=4, width=30, font=("Segoe UI", 9))
        ent_obs.grid(row=4, column=1, sticky="ew", pady=5, padx=(10, 0))

        # Enter salva / Esc fecha
        win.bind("<Escape>", lambda e: win.destroy())

        def salvar():
            if not self._can_edit_current_prog():
                return

            desc = upper(ent_desc.get().strip())
            val = self._parse_money_local(ent_val.get().strip())
            categoria = upper(cb_categoria.get())
            obs = upper(ent_obs.get("1.0", "end-1c").strip())

            if not desc:
                messagebox.showwarning("ATENÇÃO", "Informe a descrição.")
                return
            if val <= 0:
                messagebox.showwarning("ATENÇÃO", "O valor deve ser maior que zero.")
                return
            if not categoria:
                categoria = "OUTROS"

            try:
                with get_db() as conn:
                    cur = conn.cursor()
                    cur.execute("""
                        INSERT INTO despesas (codigo_programacao, descricao, valor, categoria, observacao, data_registro)
                        VALUES (?, ?, ?, ?, ?, datetime('now'))
                    """, (prog, desc, float(val), categoria, obs))

                self.logger.info(f"Despesa registrada: {prog} - {desc} - R${val:.2f} - {categoria}")
                win.destroy()
                self._refresh_all()

            except Exception as e:
                self.logger.error(f"Erro ao salvar despesa: {str(e)}")
                messagebox.showerror("ERRO", f"Erro ao salvar despesa: {str(e)}")

        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(18, 0))
        btn_frame.grid_columnconfigure(0, weight=1)
        btn_frame.grid_columnconfigure(1, weight=1)

        ttk.Button(btn_frame, text="SALVAR", style="Primary.TButton", command=salvar)\
            .grid(row=0, column=0, sticky="ew", padx=(0, 6))
        ttk.Button(btn_frame, text="CANCELAR", style="Ghost.TButton", command=win.destroy)\
            .grid(row=0, column=1, sticky="ew", padx=(6, 0))

        win.bind("<Return>", lambda e: salvar())
        ent_desc.focus_set()

    def _editar_linha_selecionada(self):
        if not self._can_edit_current_prog():
            return

        prog = self._current_programacao

        if not self.selected_despesa_id:
            messagebox.showwarning("ATENÇÃO", "Selecione uma linha na tabela.")
            return

        sel = self.tree_desp.selection()
        if not sel:
            return

        vals = self.tree_desp.item(sel[0], "values")
        if len(vals) < 6:
            messagebox.showerror("ERRO", "Dados incompletos na linha selecionada.")
            return

        did, desc, val_str, data_reg, categoria, observacao = vals

        # âœ… valida que essa despesa pertence Ã  programaÃ§Ã£o atual
        info = self._get_despesa_info(did)
        if not info:
            messagebox.showerror("ERRO", "Não encontrei essa despesa no banco.")
            return
        _, codigo_prog_db, _, _, _ = info
        if upper(codigo_prog_db) != upper(prog):
            messagebox.showwarning(
                "ATENÃƒâ€¡ÃƒÆ’O",
                "Por seguranÃ§a, nÃ£o Ã© permitido editar uma despesa que nÃ£o pertence Ã  programaÃ§Ã£o atual."
            )
            return

        win = tk.Toplevel(self)
        win.title(f"Editar Despesa - ID {did}")
        win.geometry("520x380")
        win.grab_set()
        win.resizable(False, False)

        frm = ttk.Frame(win, padding=20)
        frm.pack(fill="both", expand=True)
        frm.grid_columnconfigure(1, weight=1)

        ttk.Label(frm, text="EDITAR DESPESA", font=("Segoe UI", 14, "bold"))\
            .grid(row=0, column=0, columnspan=2, pady=(0, 16), sticky="w")

        row = 1

        ttk.Label(frm, text="Descrição:", font=("Segoe UI", 10, "bold"))\
            .grid(row=row, column=0, sticky="w", pady=5)
        ent_desc = ttk.Entry(frm, style="Field.TEntry")
        ent_desc.grid(row=row, column=1, sticky="ew", pady=5, padx=(10, 0))
        ent_desc.insert(0, desc or "")
        row += 1

        ttk.Label(frm, text="Valor (R$):", font=("Segoe UI", 10, "bold"))\
            .grid(row=row, column=0, sticky="w", pady=5)
        ent_val = ttk.Entry(frm, style="Field.TEntry")
        ent_val.grid(row=row, column=1, sticky="ew", pady=5, padx=(10, 0))
        ent_val.insert(0, str(val_str).replace("R$", "").strip())
        self._bind_money_entry(ent_val)
        row += 1

        ttk.Label(frm, text="Categoria:", font=("Segoe UI", 10, "bold"))\
            .grid(row=row, column=0, sticky="w", pady=5)
        cb_categoria = ttk.Combobox(
            frm, state="readonly", width=22,
            values=["DIARIAS", "COMBUSTIVEL", "SERVICOS NO VEICULOS", "DIARIA EXTRA", "ESTRADA", "BANHO", "OUTROS"]
        )
        cb_categoria.set(upper(categoria) if categoria else "OUTROS")
        cb_categoria.grid(row=row, column=1, sticky="w", pady=5, padx=(10, 0))
        row += 1

        ttk.Label(frm, text="Observação:", font=("Segoe UI", 10, "bold"))\
            .grid(row=row, column=0, sticky="w", pady=5)
        ent_obs = tk.Text(frm, height=4, width=30, font=("Segoe UI", 9))
        ent_obs.grid(row=row, column=1, sticky="ew", pady=5, padx=(10, 0))
        ent_obs.insert("1.0", observacao or "")
        row += 1

        ttk.Label(frm, text="Data Registro:", font=("Segoe UI", 10, "bold"))\
            .grid(row=row, column=0, sticky="w", pady=5)
        lbl_data = ttk.Label(frm, text=data_reg or "", font=("Segoe UI", 9))
        lbl_data.grid(row=row, column=1, sticky="w", pady=5, padx=(10, 0))
        row += 1

        win.bind("<Escape>", lambda e: win.destroy())

        def salvar():
            if not self._can_edit_current_prog():
                return

            ndesc = upper(ent_desc.get().strip())
            nval = self._parse_money_local(ent_val.get().strip())
            ncategoria = upper(cb_categoria.get())
            nobs = upper(ent_obs.get("1.0", "end-1c").strip())

            if not ndesc:
                messagebox.showwarning("ATENÇÃO", "Informe a descrição.")
                return
            if nval <= 0:
                messagebox.showwarning("ATENÇÃO", "O valor deve ser maior que zero.")
                return
            if not ncategoria:
                ncategoria = "OUTROS"

            # âœ… valida novamente (seguranÃ§a)
            info2 = self._get_despesa_info(did)
            if not info2 or upper(info2[1]) != upper(prog):
                messagebox.showwarning("ATENÇÃO", "Despesa não pertence à programação atual (bloqueado).")
                return

            try:
                with get_db() as conn:
                    cur = conn.cursor()
                    cur.execute("""
                        UPDATE despesas
                        SET descricao=?, valor=?, categoria=?, observacao=?
                        WHERE id=?
                    """, (ndesc, float(nval), ncategoria, nobs, did))

                self.logger.info(f"Despesa atualizada: ID {did} - {ndesc} - R${nval:.2f}")
                win.destroy()
                self._load_by_programacao()

            except Exception as e:
                self.logger.error(f"Erro ao atualizar despesa: {str(e)}")
                messagebox.showerror("ERRO", f"Erro ao atualizar despesa: {str(e)}")

        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=(18, 0))
        btn_frame.grid_columnconfigure(0, weight=1)
        btn_frame.grid_columnconfigure(1, weight=1)

        ttk.Button(btn_frame, text="SALVAR", style="Primary.TButton", command=salvar)\
            .grid(row=0, column=0, sticky="ew", padx=(0, 6))
        ttk.Button(btn_frame, text="CANCELAR", style="Ghost.TButton", command=win.destroy)\
            .grid(row=0, column=1, sticky="ew", padx=(6, 0))

        win.bind("<Return>", lambda e: salvar())
        ent_desc.focus_set()

    def _excluir_linha_selecionada(self):
        if not self._can_edit_current_prog():
            return

        prog = self._current_programacao
        if not self.selected_despesa_id:
            messagebox.showwarning("ATENÇÃO", "Selecione uma linha na tabela.")
            return

        did = self.selected_despesa_id

        # ✅ pega dados reais do banco para confirmar e validar pertencimento
        info = self._get_despesa_info(did)
        if not info:
            messagebox.showerror("ERRO", "Não encontrei essa despesa no banco.")
            return

        _, codigo_prog_db, desc_db, val_db, cat_db = info
        if upper(codigo_prog_db) != upper(prog):
            messagebox.showwarning(
                "ATENÃƒâ€¡ÃƒÆ’O",
                "Por seguranÃ§a, nÃ£o Ã© permitido excluir uma despesa que nÃ£o pertence Ã  programaÃ§Ã£o atual."
            )
            return

        val_fmt = self._fmt_money(val_db) if hasattr(self, "_fmt_money") else f"R$ {float(val_db or 0):.2f}"
        resposta = messagebox.askyesno(
            "CONFIRMAR EXCLUSÃO",
            "Deseja realmente excluir esta despesa?\n\n"
            f"ID: {did}\n"
            f"Descrição: {desc_db}\n"
            f"Valor: {val_fmt}\n"
            f"Categoria: {cat_db}\n\n"
            "Esta ação não pode ser desfeita."
        )
        if not resposta:
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("DELETE FROM despesas WHERE id=? AND codigo_programacao=?", (did, prog))

            self.logger.warning(f"Despesa excluída: {prog} - ID {did} - {desc_db} - {val_fmt}")
            self.selected_despesa_id = None
            self._refresh_all()
            self.set_status(f"STATUS: Despesa ID {did} excluída com sucesso")

        except Exception as e:
            self.logger.error(f"Erro ao excluir despesa: {str(e)}")
            messagebox.showerror("ERRO", f"Erro ao excluir despesa: {str(e)}")

    # =========================================================
    # 7.7 RELATÓRIO EM TELA + IMPRESSÃO SIMULADA
    # =========================================================
    def imprimir_resumo(self):
        try:
            prog = self._current_programacao
            if not prog:
                messagebox.showwarning("ATENCAO", "Selecione a Programacao primeiro.")
                return

            path_pdf = filedialog.asksaveasfilename(
                title="Salvar PDF - Despesas",
                defaultextension=".pdf",
                filetypes=[("PDF", "*.pdf")],
                initialfile=f"DESPESAS_{prog}_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf"
            )
            if not path_pdf:
                return

            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import A4
            from reportlab.lib.units import mm

            # ---- coleta dados ----
            motorista = veiculo = equipe = ""
            equipe_txt = ""
            nf = local_rota = local_carreg = ""
            data_saida = hora_saida = data_chegada = hora_chegada = ""
            nf_kg = nf_caixas = nf_kg_carregado = nf_kg_vendido = nf_saldo = 0.0
            km_inicial = km_final = litros = km_rodado = media_km_l = custo_km = 0.0
            ced_qtd = {200: 0, 100: 0, 50: 0, 20: 0, 10: 0, 5: 0, 2: 0}
            valor_dinheiro = 0.0
            adiantamento = 0.0
            despesas = []

            with get_db() as conn:
                cur = conn.cursor()

                def has_col(col):
                    try:
                        return db_has_column(cur, "programacoes", col)
                    except Exception:
                        return False

                nf_col = "num_nf" if has_col("num_nf") else ("nf_numero" if has_col("nf_numero") else "'' as num_nf")
                local_rota_col = "local_rota" if has_col("local_rota") else ("tipo_rota" if has_col("tipo_rota") else "'' as local_rota")
                local_carreg_col = "local_carregamento" if has_col("local_carregamento") else ("granja_carregada" if has_col("granja_carregada") else "'' as local_carregamento")

                if has_col("adiantamento"):
                    adiant_col = "adiantamento"
                elif has_col("adiantamento_rota"):
                    adiant_col = "adiantamento_rota as adiantamento"
                else:
                    adiant_col = "0 as adiantamento"

                cur.execute(f"""
                    SELECT
                        motorista,
                        veiculo,
                        equipe,
                        {nf_col} as num_nf,
                        {local_rota_col} as local_rota,
                        {local_carreg_col} as local_carreg,
                        COALESCE(data_saida,''), COALESCE(hora_saida,''),
                        COALESCE(data_chegada,''), COALESCE(hora_chegada,''),
                        COALESCE(nf_kg,0), COALESCE(nf_caixas,0), COALESCE(nf_kg_carregado,0),
                        COALESCE(nf_kg_vendido,0), COALESCE(nf_saldo,0),
                        COALESCE(km_inicial,0), COALESCE(km_final,0), COALESCE(litros,0),
                        COALESCE(km_rodado,0), COALESCE(media_km_l,0), COALESCE(custo_km,0),
                        COALESCE(ced_200_qtd,0), COALESCE(ced_100_qtd,0), COALESCE(ced_50_qtd,0),
                        COALESCE(ced_20_qtd,0), COALESCE(ced_10_qtd,0), COALESCE(ced_5_qtd,0), COALESCE(ced_2_qtd,0),
                        COALESCE(valor_dinheiro,0),
                        {adiant_col}
                    FROM programacoes
                    WHERE codigo_programacao=?
                """, (prog,))
                row = cur.fetchone() or []

                if row:
                    motorista, veiculo, equipe = row[0] or "", row[1] or "", row[2] or ""
                    nf, local_rota, local_carreg = row[3] or "", row[4] or "", row[5] or ""
                    data_saida, hora_saida = row[6] or "", row[7] or ""
                    data_chegada, hora_chegada = row[8] or "", row[9] or ""
                    nf_kg, nf_caixas, nf_kg_carregado = safe_float(row[10], 0.0), safe_int(row[11], 0), safe_float(row[12], 0.0)
                    nf_kg_vendido, nf_saldo = safe_float(row[13], 0.0), safe_float(row[14], 0.0)
                    km_inicial, km_final = safe_float(row[15], 0.0), safe_float(row[16], 0.0)
                    litros, km_rodado = safe_float(row[17], 0.0), safe_float(row[18], 0.0)
                    media_km_l, custo_km = safe_float(row[19], 0.0), safe_float(row[20], 0.0)
                    ced_qtd[200], ced_qtd[100], ced_qtd[50] = safe_int(row[21], 0), safe_int(row[22], 0), safe_int(row[23], 0)
                    ced_qtd[20], ced_qtd[10], ced_qtd[5], ced_qtd[2] = safe_int(row[24], 0), safe_int(row[25], 0), safe_int(row[26], 0), safe_int(row[27], 0)
                    valor_dinheiro = safe_float(row[28], 0.0)
                    adiantamento = safe_float(row[29], 0.0)

                    equipe_txt = resolve_equipe_nomes(equipe)

                    data_saida, hora_saida = normalize_date_time_components(data_saida, hora_saida)
                    data_chegada, hora_chegada = normalize_date_time_components(data_chegada, hora_chegada)

                cur.execute("""
                    SELECT descricao, valor, COALESCE(categoria,'OUTROS'), COALESCE(observacao,''), data_registro
                    FROM despesas
                    WHERE codigo_programacao=?
                    ORDER BY data_registro DESC
                """, (prog,))
                despesas = cur.fetchall() or []

                cur.execute("SELECT SUM(valor) FROM recebimentos WHERE codigo_programacao=?", (prog,))
                total_receb = safe_float((cur.fetchone() or [0])[0], 0.0)

                cur.execute("SELECT SUM(valor) FROM despesas WHERE codigo_programacao=?", (prog,))
                total_desp = safe_float((cur.fetchone() or [0])[0], 0.0)

            # totais
            ced_total = sum(float(ced) * safe_int(qtd, 0) for ced, qtd in ced_qtd.items())
            total_entradas = total_receb + adiantamento
            total_saidas = total_desp + ced_total
            valor_final_caixa = total_entradas - total_desp
            diferenca = valor_final_caixa - ced_total
            resultado = total_entradas - total_saidas

            # ---- PDF ----
            c = canvas.Canvas(path_pdf, pagesize=A4)
            width, height = A4
            left, right, top, bottom = 12 * mm, 12 * mm, 12 * mm, 12 * mm
            y = height - top

            def new_page(title=None):
                nonlocal y
                c.showPage()
                y = height - top
                if title:
                    c.setFont("Helvetica-Bold", 12)
                    c.drawString(left, y, title)
                    y -= 8 * mm

            def ensure_space(mm_needed):
                nonlocal y
                if y < bottom + (mm_needed * mm):
                    new_page(f"RELATORIO DE DESPESAS - PROGRAMACAO {prog}")

            def draw_kv(x, y0, k, v, offset=26*mm):
                c.setFont("Helvetica-Bold", 9)
                c.drawString(x, y0, f"{k}:")
                c.setFont("Helvetica", 9)
                c.drawString(x + offset, y0, v or "")

            c.setFont("Helvetica-Bold", 14)
            c.drawString(left, y, f"RELATORIO DE DESPESAS - PROGRAMACAO {prog}")
            y -= 10 * mm

            # Dados da rota
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "DADOS DA ROTA")
            y -= 6 * mm

            c.setFont("Helvetica", 9)
            col1_x = left
            col2_x = left + (width - left - right) * 0.55
            line_h = 5.2 * mm

            draw_kv(col1_x, y, "Motorista", motorista)
            draw_kv(col2_x, y, "Veiculo", veiculo)
            y -= line_h
            draw_kv(col1_x, y, "Equipe", equipe_txt)
            draw_kv(col2_x, y, "NF", nf)
            y -= line_h
            draw_kv(col1_x, y, "Local da Rota", local_rota)
            draw_kv(col2_x, y, "Local Carregamento", local_carreg)
            y -= line_h
            draw_kv(col1_x, y, "Saida", f"{data_saida} {hora_saida}".strip())
            draw_kv(col2_x, y, "Chegada", f"{data_chegada} {hora_chegada}".strip())
            y -= 8 * mm

            # Carregamentos / NF
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "CARREGAMENTO / NOTA FISCAL")
            y -= 6 * mm

            draw_kv(col1_x, y, "NF KG", f"{nf_kg:.2f}".replace(".", ","))
            draw_kv(col2_x, y, "NF Caixas", str(nf_caixas))
            y -= line_h
            draw_kv(col1_x, y, "KG Carregado", f"{nf_kg_carregado:.2f}".replace(".", ","))
            draw_kv(col2_x, y, "KG Vendido", f"{nf_kg_vendido:.2f}".replace(".", ","))
            y -= line_h
            draw_kv(col1_x, y, "Saldo (KG)", f"{nf_saldo:.2f}".replace(".", ","))
            y -= 8 * mm

            # Dados de rota (KM)
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "DADOS DE ROTA (KM)")
            y -= 6 * mm

            draw_kv(col1_x, y, "KM Inicial", f"{km_inicial:.2f}".replace(".", ","))
            draw_kv(col2_x, y, "KM Final", f"{km_final:.2f}".replace(".", ","))
            y -= line_h
            draw_kv(col1_x, y, "Litros", f"{litros:.2f}".replace(".", ","))
            draw_kv(col2_x, y, "KM Rodado", f"{km_rodado:.2f}".replace(".", ","))
            y -= line_h
            draw_kv(col1_x, y, "Media", f"{media_km_l:.2f}".replace(".", ","))
            draw_kv(col2_x, y, "Custo KM", f"{custo_km:.2f}".replace(".", ","))
            y -= 8 * mm

            # Contagem de cedulas
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "CONTAGEM DE CEDULAS")
            y -= 6 * mm

            c.setFont("Helvetica-Bold", 9)
            c.drawString(left, y, "CEDULA")
            c.drawString(left + 25*mm, y, "QTD")
            c.drawString(left + 45*mm, y, "TOTAL")
            y -= 5 * mm
            c.setFont("Helvetica", 9)
            for ced in [200, 100, 50, 20, 10, 5, 2]:
                total_ced = ced_qtd[ced] * ced
                c.drawString(left, y, f"R$ {ced:.2f}".replace(".", ","))
                c.drawString(left + 25*mm, y, str(ced_qtd[ced]))
                c.drawString(left + 45*mm, y, f"R$ {total_ced:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."))
                y -= 5 * mm

            y -= 2 * mm
            c.setFont("Helvetica-Bold", 9)
            c.drawString(left, y, f"TOTAL DINHEIRO: {self._fmt_money(valor_dinheiro or ced_total)}")
            y -= 8 * mm

            # Despesas
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "DESPESAS")
            y -= 6 * mm

            table_x = left
            table_w = width - left - right
            col_desc = table_w * 0.38
            col_cat = table_w * 0.18
            col_val = table_w * 0.14
            col_obs = table_w * 0.30

            x_desc = table_x
            x_cat = x_desc + col_desc
            x_val = x_cat + col_cat
            x_obs = x_val + col_val

            row_h = 6.5 * mm

            c.setFont("Helvetica-Bold", 9)
            c.rect(table_x, y - row_h + 1, table_w, row_h, stroke=1, fill=0)
            c.drawString(x_desc + 2, y - row_h + 3, "DESCRICAO")
            c.drawString(x_cat + 2, y - row_h + 3, "CATEGORIA")
            c.drawRightString(x_val + col_val - 2, y - row_h + 3, "VALOR")
            c.drawString(x_obs + 2, y - row_h + 3, "OBS")
            y -= row_h

            c.setFont("Helvetica", 9)
            for desc, val, cat, obs, data_reg in despesas:
                ensure_space(15)
                c.rect(table_x, y - row_h + 1, table_w, row_h, stroke=1, fill=0)
                c.drawString(x_desc + 2, y - row_h + 3, str(desc or "")[:40])
                c.drawString(x_cat + 2, y - row_h + 3, str(cat or "")[:14])
                c.drawRightString(x_val + col_val - 2, y - row_h + 3, f"{float(val or 0):,.2f}".replace(",", "X").replace(".", ",").replace("X", "."))
                c.drawString(x_obs + 2, y - row_h + 3, str(obs or "")[:35])
                y -= row_h

            y -= 6 * mm

            # Resumo financeiro
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "RESUMO FINANCEIRO (CAIXA)")
            y -= 6 * mm

            c.setFont("Helvetica", 9)
            draw_kv(col1_x, y, "Recebimentos", self._fmt_money(total_receb))
            draw_kv(col2_x, y, "Adiantamento", self._fmt_money(adiantamento))
            y -= line_h
            draw_kv(col1_x, y, "Despesas", self._fmt_money(total_desp))
            draw_kv(col2_x, y, "Cedulas", self._fmt_money(ced_total))
            y -= line_h
            draw_kv(col1_x, y, "Total Entradas", self._fmt_money(total_entradas))
            draw_kv(col2_x, y, "Total Saidas", self._fmt_money(total_saidas))
            y -= line_h
            draw_kv(col1_x, y, "Caixa", self._fmt_money(valor_final_caixa))
            draw_kv(col2_x, y, "Diferenca", self._fmt_money(diferenca))
            y -= line_h
            draw_kv(col1_x, y, "Resultado", self._fmt_money(resultado))
            y -= 10 * mm

            # Assinaturas
            c.setFont("Helvetica-Bold", 10)
            c.drawString(left, y, "ASSINATURAS / CONFERENCIA")
            y -= 10 * mm

            block_w = (width - left - right - 10 * mm) / 2.0
            block_h = 18 * mm
            gap_x = 10 * mm
            gap_y = 10 * mm

            def assinatura_block(x, y_top, titulo):
                c.setLineWidth(0.8)
                c.rect(x, y_top - block_h, block_w, block_h, stroke=1, fill=0)
                c.setFont("Helvetica-Bold", 9)
                c.drawString(x + 3 * mm, y_top - 5 * mm, titulo)
                c.setFont("Helvetica", 9)
                c.line(x + 3 * mm, y_top - 13 * mm, x + block_w - 3 * mm, y_top - 13 * mm)
                c.drawString(x + 3 * mm, y_top - 16.5 * mm, "Assinatura / Carimbo")

            x1 = left
            x2 = left + block_w + gap_x

            assinatura_block(x1, y, "SETOR FATURAMENTO")
            assinatura_block(x2, y, "SETOR FINANCEIRO")
            y -= (block_h + gap_y)
            assinatura_block(x1, y, "SETOR DE CAIXA")
            assinatura_block(x2, y, "SETOR DE CONFERENCIA")

            c.setFont("Helvetica", 8)
            c.drawRightString(width - right, bottom - 2 * mm, f"Gerado em {datetime.now().strftime('%d/%m/%Y %H:%M')}")

            c.save()
            messagebox.showinfo("OK", f"PDF gerado com sucesso!\n\nArquivo:\n{os.path.basename(path_pdf)}")
            self.set_status(f"STATUS: PDF impresso/gerado: {os.path.basename(path_pdf)}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao gerar PDF: {str(e)}")

    def _imprimir_tela(self, window):
        messagebox.showinfo(
            "IMPRESSÃO",
            "FunÃ§Ã£o de impressÃ£o serÃ¡ implementada na prÃ³xima versÃ£o.\n\n"
            "Por enquanto, você pode:\n"
            "1. Tirar um print screen desta tela\n"
            "2. Usar o botão 'Exportar Excel' para gerar arquivo\n"
            "3. Salvar como PDF usando Ctrl+P"
        )
        try:
            self.logger.info("Solicitada impressão de relatório (DespesasPage)")
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    # =========================================================
    # 7.8 SALVAR TUDO (NF / KM / CÉDULAS / ADIANTAMENTO)
    # =========================================================
    def salvar_tudo(self):
        if not self._can_edit_current_prog():
            return

        prog = self._current_programacao

        nf_numero = self.ent_nf_numero.get().strip()
        nf_kg = safe_float(self.ent_nf_kg.get(), 0.0)
        nf_caixas = safe_int(self.ent_nf_caixas.get(), 0)
        nf_kg_carregado = safe_float(self.ent_nf_kg_carregado.get(), 0.0)
        nf_kg_vendido = safe_float(self.ent_nf_kg_vendido.get(), 0.0)
        nf_saldo = safe_float(self.ent_nf_saldo.get(), 0.0)

        km_inicial = safe_float(self.ent_km_inicial.get(), 0.0)
        km_final = safe_float(self.ent_km_final.get(), 0.0)
        litros = safe_float(self.ent_litros.get(), 0.0)
        km_rodado = safe_float(self.ent_km_rodado.get(), 0.0)
        media_km_l = safe_float(self.ent_media.get(), 0.0)
        custo_km = safe_float(self.ent_custo_km.get(), 0.0)

        cedulas_data = {f"ced_{ced}_qtd": safe_int(ent.get(), 0) for ced, ent in self.ced_entries.items()}

        valor_dinheiro = 0.0
        for ced, ent in self.ced_entries.items():
            valor_dinheiro += safe_int(ent.get(), 0) * float(ced)

        # ✅ aceita "10,00" ou "R$ 10,00"
        adiantamento_val = self._parse_money_local(self.ent_adiantamento.get())

        try:
            with get_db() as conn:
                cur = conn.cursor()

                cur.execute("PRAGMA table_info(programacoes)")
                columns = [col[1] for col in cur.fetchall()]

                if "adiantamento" in columns:
                    cur.execute("""
                        UPDATE programacoes SET
                            nf_numero=?, nf_kg=?, nf_caixas=?, nf_kg_carregado=?, nf_kg_vendido=?, nf_saldo=?,
                            km_inicial=?, km_final=?, litros=?, km_rodado=?, media_km_l=?, custo_km=?,
                            ced_200_qtd=?, ced_100_qtd=?, ced_50_qtd=?, ced_20_qtd=?, ced_10_qtd=?, ced_5_qtd=?, ced_2_qtd=?,
                            valor_dinheiro=?,
                            adiantamento=?
                        WHERE codigo_programacao=?
                    """, (
                        nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                        km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                        cedulas_data.get("ced_200_qtd", 0), cedulas_data.get("ced_100_qtd", 0),
                        cedulas_data.get("ced_50_qtd", 0), cedulas_data.get("ced_20_qtd", 0),
                        cedulas_data.get("ced_10_qtd", 0), cedulas_data.get("ced_5_qtd", 0),
                        cedulas_data.get("ced_2_qtd", 0),
                        valor_dinheiro,
                        adiantamento_val,
                        prog
                    ))
                elif "adiantamento_rota" in columns:
                    cur.execute("""
                        UPDATE programacoes SET
                            nf_numero=?, nf_kg=?, nf_caixas=?, nf_kg_carregado=?, nf_kg_vendido=?, nf_saldo=?,
                            km_inicial=?, km_final=?, litros=?, km_rodado=?, media_km_l=?, custo_km=?,
                            ced_200_qtd=?, ced_100_qtd=?, ced_50_qtd=?, ced_20_qtd=?, ced_10_qtd=?, ced_5_qtd=?, ced_2_qtd=?,
                            valor_dinheiro=?,
                            adiantamento_rota=?
                        WHERE codigo_programacao=?
                    """, (
                        nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                        km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                        cedulas_data.get("ced_200_qtd", 0), cedulas_data.get("ced_100_qtd", 0),
                        cedulas_data.get("ced_50_qtd", 0), cedulas_data.get("ced_20_qtd", 0),
                        cedulas_data.get("ced_10_qtd", 0), cedulas_data.get("ced_5_qtd", 0),
                        cedulas_data.get("ced_2_qtd", 0),
                        valor_dinheiro,
                        adiantamento_val,
                        prog
                    ))
                else:
                    cur.execute("""
                        UPDATE programacoes SET
                            nf_numero=?, nf_kg=?, nf_caixas=?, nf_kg_carregado=?, nf_kg_vendido=?, nf_saldo=?,
                            km_inicial=?, km_final=?, litros=?, km_rodado=?, media_km_l=?, custo_km=?,
                            ced_200_qtd=?, ced_100_qtd=?, ced_50_qtd=?, ced_20_qtd=?, ced_10_qtd=?, ced_5_qtd=?, ced_2_qtd=?,
                            valor_dinheiro=?
                        WHERE codigo_programacao=?
                    """, (
                        nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                        km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                        cedulas_data.get("ced_200_qtd", 0), cedulas_data.get("ced_100_qtd", 0),
                        cedulas_data.get("ced_50_qtd", 0), cedulas_data.get("ced_20_qtd", 0),
                        cedulas_data.get("ced_10_qtd", 0), cedulas_data.get("ced_5_qtd", 0),
                        cedulas_data.get("ced_2_qtd", 0),
                        valor_dinheiro,
                        prog
                    ))

            self.logger.info(f"Dados salvos para programação {prog}")
            messagebox.showinfo("SUCESSO", "Todos os dados foram salvos com sucesso!")
            self.set_status(f"STATUS: Dados salvos para {prog}")

        except Exception as e:
            self.logger.error(f"Erro ao salvar dados: {str(e)}")
            messagebox.showerror("ERRO", f"Erro ao salvar dados: {str(e)}")

    # =========================================================
    # 7.9 EXPORTAR EXCEL (RELATÓRIO COMPLETO)
    # =========================================================
    def exportar_excel(self):
        # exportar pode ser permitido mesmo com FECHADA (é leitura). Então NÃO bloqueio.
        prog = self._current_programacao
        if not (require_pandas() and require_openpyxl()):
            return
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione a Programação primeiro.")
            return

        path = filedialog.asksaveasfilename(
            title="Exportar Relatório Excel",
            defaultextension=".xlsx",
            filetypes=[("Excel", "*.xlsx")],
            initialfile=f"RELATORIO_DESPESAS_{prog}_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx"
        )
        if not path:
            return


        try:
            with get_db() as conn:
                try:
                    df_prog = pd.read_sql_query("""
                        SELECT codigo_programacao, motorista, veiculo, data_criacao,
                               nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                               km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                               valor_dinheiro,
                               adiantamento
                        FROM programacoes
                        WHERE codigo_programacao=?
                    """, conn, params=(prog,))
                except Exception:
                    df_prog = pd.read_sql_query("""
                        SELECT codigo_programacao, motorista, veiculo, data_criacao,
                               nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                               km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                               valor_dinheiro,
                               adiantamento_rota
                        FROM programacoes
                        WHERE codigo_programacao=?
                    """, conn, params=(prog,))

                if df_prog.empty:
                    df_prog = pd.read_sql_query("""
                        SELECT codigo_programacao, motorista, veiculo, data_criacao,
                               nf_numero, nf_kg, nf_caixas, nf_kg_carregado, nf_kg_vendido, nf_saldo,
                               km_inicial, km_final, litros, km_rodado, media_km_l, custo_km,
                               valor_dinheiro
                        FROM programacoes
                        WHERE codigo_programacao=?
                    """, conn, params=(prog,))

                if "data_criacao" in df_prog.columns:
                    df_prog["data_criacao"] = normalize_datetime_column(df_prog["data_criacao"])

                df_despesas = pd.read_sql_query("""
                    SELECT id, descricao, valor, categoria, observacao, data_registro
                    FROM despesas
                    WHERE codigo_programacao=?
                    ORDER BY data_registro DESC
                """, conn, params=(prog,))
                if "data_registro" in df_despesas.columns:
                    df_despesas["data_registro"] = normalize_datetime_column(df_despesas["data_registro"])

                try:
                    df_receb = pd.read_sql_query("""
                        SELECT cod_cliente, nome_cliente, valor, forma_pagamento, observacao, num_nf, data_registro
                        FROM recebimentos
                        WHERE codigo_programacao=?
                        ORDER BY data_registro DESC
                    """, conn, params=(prog,))
                except Exception:
                    df_receb = pd.DataFrame(columns=[
                        "cod_cliente", "nome_cliente", "valor", "forma_pagamento", "observacao", "num_nf", "data_registro"
                    ])
                if "data_registro" in df_receb.columns:
                    df_receb["data_registro"] = normalize_datetime_column(df_receb["data_registro"])

            cedulas_data = []
            for ced in [200, 100, 50, 20, 10, 5, 2]:
                qtd = safe_int(self.ced_entries[ced].get(), 0)
                cedulas_data.append({"CEDULA": ced, "QUANTIDADE": qtd, "TOTAL": qtd * ced})
            df_cedulas = pd.DataFrame(cedulas_data)

            total_desp = float(df_despesas["valor"].sum()) if not df_despesas.empty else 0.0
            total_receb = float(df_receb["valor"].sum()) if not df_receb.empty else 0.0
            total_ced = float(df_cedulas["TOTAL"].sum()) if not df_cedulas.empty else 0.0

            adiant = self._parse_money_local(self.ent_adiantamento.get())
            total_entradas = total_receb + adiant
            total_saidas = total_desp + total_ced
            resultado_liquido = total_entradas - total_saidas

            df_resumo = pd.DataFrame([
                ["PROGRAMAÇÃO", prog],
                ["TOTAL RECEBIMENTOS", total_receb],
                ["TOTAL ADIANTAMENTO", adiant],
                ["TOTAL ENTRADAS", total_entradas],
                ["TOTAL DESPESAS", total_desp],
                ["TOTAL CÉDULAS", total_ced],
                ["TOTAL SADAS", total_saidas],
                ["RESULTADO LQUIDO", resultado_liquido],
                ["DATA EXPORTAÇÃO", datetime.now().strftime("%d/%m/%Y %H:%M")]
            ], columns=["ITEM", "VALOR"])

            with pd.ExcelWriter(path, engine="openpyxl") as writer:
                df_resumo.to_excel(writer, sheet_name="RESUMO", index=False)
                df_prog.to_excel(writer, sheet_name="PROGRAMAÇÃO", index=False)

                if not df_despesas.empty:
                    df_despesas.to_excel(writer, sheet_name="DESPESAS", index=False)
                else:
                    pd.DataFrame([["SEM DESPESAS REGISTRADAS"]]).to_excel(writer, sheet_name="DESPESAS", index=False, header=False)

                if not df_receb.empty:
                    df_receb.to_excel(writer, sheet_name="RECEBIMENTOS", index=False)
                else:
                    pd.DataFrame([["SEM RECEBIMENTOS REGISTRADOS"]]).to_excel(writer, sheet_name="RECEBIMENTOS", index=False, header=False)

                df_cedulas.to_excel(writer, sheet_name="CEDULAS", index=False)

            try:
                self.logger.info(f"Exportação Excel concluída: {path}")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            messagebox.showinfo(
                "OK",
                "ExportaÃ§Ã£o concluÃ­da!\n\n"
                f"Arquivo: {os.path.basename(path)}\n"
                f"Despesas: {len(df_despesas)}\n"
                f"Recebimentos: {len(df_receb)}\n"
                f"Resultado Líquido: {self._fmt_money(resultado_liquido) if hasattr(self, '_fmt_money') else resultado_liquido}"
            )

        except Exception as e:
            try:
                self.logger.error(f"Erro ao exportar Excel: {str(e)}")
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)
            messagebox.showerror("ERRO", f"Erro ao exportar Excel: {str(e)}")

# ==========================
# ===== FIM DA PARTE 7C (ATUALIZADA) =====
# ==========================

# =========================
# ===== FIM DA PARTE 7 =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 8 (ATUALIZADA) =====
# ==========================

class RelatoriosPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Relatórios")

        card = ttk.Frame(self.body, style="Card.TFrame", padding=12)
        card.grid(row=0, column=0, sticky="ew")
        card.grid_columnconfigure(7, weight=1)

        ttk.Label(card, text="Programação", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w")
        self.cb_prog = ttk.Combobox(card, state="readonly")
        self.cb_prog.grid(row=1, column=0, sticky="ew", padx=6)

        ttk.Button(card, text="GERAR RESUMO", style="Primary.TButton", command=self.gerar_resumo).grid(
            row=1, column=1, padx=6
        )
        ttk.Button(card, text="EXPORTAR EXCEL", style="Warn.TButton", command=self.exportar_excel).grid(
            row=1, column=2, padx=6
        )
        ttk.Button(card, text="GERAR PDF", style="Primary.TButton", command=self.gerar_pdf).grid(
            row=1, column=3, padx=6
        )
        ttk.Button(card, text="ATUALIZAR", style="Ghost.TButton", command=self.refresh_comboboxes).grid(
            row=1, column=4, padx=6
        )

        ttk.Button(card, text="FINALIZAR ROTA", style="Danger.TButton", command=self.finalizar_rota).grid(
            row=1, column=5, padx=6
        )
        ttk.Button(card, text="REABRIR ROTA", style="Warn.TButton", command=self.reabrir_rota).grid(
            row=1, column=6, padx=6
        )

        self.txt = tk.Text(self.body, height=18)
        self.txt.grid(row=1, column=0, sticky="nsew", pady=(14, 0))

        self.refresh_comboboxes()

    # ----------------------------
    # Helpers de regra/segurança
    # ----------------------------
    def _get_prog_status_info(self, prog: str):
        """
        Retorna dict com status/prestacao_status quando existir.
        Compatível com bases antigas (sem coluna prestacao_status).
        """
        info = {"status": "", "prestacao_status": ""}
        with get_db() as conn:
            cur = conn.cursor()
            cur.execute("PRAGMA table_info(programacoes)")
            cols = [c[1] for c in cur.fetchall()]
            has_prest = "prestacao_status" in cols

            if has_prest:
                cur.execute("""
                    SELECT COALESCE(status,''), COALESCE(prestacao_status,'')
                    FROM programacoes
                    WHERE codigo_programacao=?
                    LIMIT 1
                """, (prog,))
                row = cur.fetchone()
                if row:
                    info["status"] = upper(row[0])
                    info["prestacao_status"] = upper(row[1])
            else:
                cur.execute("""
                    SELECT COALESCE(status,'')
                    FROM programacoes
                    WHERE codigo_programacao=?
                    LIMIT 1
                """, (prog,))
                row = cur.fetchone()
                if row:
                    info["status"] = upper(row[0])
                    info["prestacao_status"] = ""
        return info

    def _is_prestacao_fechada(self, prog: str) -> bool:
        info = self._get_prog_status_info(prog)
        return info.get("prestacao_status", "") == "FECHADA"

    def refresh_comboboxes(self):
        with get_db() as conn:
            cur = conn.cursor()
            try:
                cur.execute("""
                    SELECT codigo_programacao
                    FROM programacoes
                    ORDER BY
                        CASE WHEN status='ATIVA' THEN 0 ELSE 1 END,
                        id DESC
                    LIMIT 400
                """)
            except Exception:
                cur.execute("SELECT codigo_programacao FROM programacoes ORDER BY id DESC LIMIT 400")

            self.cb_prog["values"] = [r[0] for r in cur.fetchall()]

    def on_show(self):
        self.refresh_comboboxes()
        self.set_status("STATUS: Relatórios e exportação.")

    def gerar_resumo(self):
        prog = upper(self.cb_prog.get())
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação.")
            return

        with get_db() as conn:
            cur = conn.cursor()

            # tenta pegar status e prestacao_status se existir
            cur.execute("PRAGMA table_info(programacoes)")
            cols = [c[1] for c in cur.fetchall()]
            has_status = "status" in cols
            has_prest = "prestacao_status" in cols

            select_cols = ["motorista", "veiculo", "equipe", "kg_estimado", "data_criacao"]
            if has_status:
                select_cols.append("status")
            if has_prest:
                select_cols.append("prestacao_status")

            cur.execute(f"""
                SELECT {", ".join(select_cols)}
                FROM programacoes
                WHERE codigo_programacao=?
            """, (prog,))
            prog_row = cur.fetchone()

            cur.execute("SELECT SUM(valor) FROM recebimentos WHERE codigo_programacao=?", (prog,))
            total_rec = safe_float(cur.fetchone()[0], 0.0)

            cur.execute("SELECT SUM(valor) FROM despesas WHERE codigo_programacao=?", (prog,))
            total_desp = safe_float(cur.fetchone()[0], 0.0)

            cur.execute("SELECT COUNT(*) FROM programacao_itens WHERE codigo_programacao=?", (prog,))
            total_entregas = cur.fetchone()[0] or 0

        lucro = total_rec - total_desp

        self.txt.delete("1.0", "end")
        self.txt.insert("end", f"RELATÃƒâ€œRIO Ã¢â‚¬â€ PROGRAMAÃƒâ€¡ÃƒÆ’O {prog}\n")
        self.txt.insert("end", "-" * 60 + "\n\n")

        if prog_row:
            # desempacota dinamicamente
            idx = 0
            motorista = prog_row[idx]; idx += 1
            veiculo = prog_row[idx]; idx += 1
            equipe = prog_row[idx]; idx += 1
            kg_estimado = prog_row[idx]; idx += 1
            data_criacao = prog_row[idx]; idx += 1

            status = "Ã¢â‚¬â€"
            prest = "Ã¢â‚¬â€"

            if len(prog_row) > idx and ("status" in cols):
                status = prog_row[idx] or ""
                idx += 1
            if len(prog_row) > idx and ("prestacao_status" in cols):
                prest = prog_row[idx] or ""
                idx += 1

            self.txt.insert("end", f"Status: {status}\n")
            if "prestacao_status" in cols:
                self.txt.insert("end", f"Prestação: {prest}\n")
            data_criacao_n = normalize_date(data_criacao)
            data_criacao_show = data_criacao_n if data_criacao_n is not None else (data_criacao or "")
            self.txt.insert("end", f"Data criação: {data_criacao_show}\n")
            self.txt.insert("end", f"Motorista: {motorista}\n")
            self.txt.insert("end", f"Veículo: {veiculo}\n")
            self.txt.insert("end", f"Equipe: {resolve_equipe_nomes(equipe)}\n")
            self.txt.insert("end", f"KG estimado: {kg_estimado}\n")
            self.txt.insert("end", f"Entregas: {total_entregas}\n\n")

        self.txt.insert("end", f"Total Recebimentos: R$ {total_rec:,.2f}\n")
        self.txt.insert("end", f"Total Despesas:     R$ {total_desp:,.2f}\n")
        self.txt.insert("end", f"Resultado (Lucro):  R$ {lucro:,.2f}\n")

        # dica de bloqueio quando prestação fechada
        if self._is_prestacao_fechada(prog):
            self.txt.insert("end", "\n⚠ Prestação FECHADA: alterações financeiras estão bloqueadas (despesas/adiantamento/etc.).\n")

        self.set_status("STATUS: Resumo gerado.")

    def exportar_excel(self):
        prog = upper(self.cb_prog.get())
        if not (require_pandas() and require_openpyxl()):
            return
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação.")
            return

        path = filedialog.asksaveasfilename(
            title="Exportar Excel",
            defaultextension=".xlsx",
            filetypes=[("Excel", "*.xlsx")],
            initialfile=f"RELATORIO_{prog}.xlsx"
        )
        if not path:
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()

                cur.execute("SELECT * FROM programacao_itens WHERE codigo_programacao=?", (prog,))
                itens = cur.fetchall()
                cols_itens = [d[0] for d in cur.description]

                cur.execute("SELECT * FROM recebimentos WHERE codigo_programacao=?", (prog,))
                rec = cur.fetchall()
                cols_rec = [d[0] for d in cur.description]

                cur.execute("SELECT * FROM despesas WHERE codigo_programacao=?", (prog,))
                desp = cur.fetchall()
                cols_desp = [d[0] for d in cur.description]

            with pd.ExcelWriter(path, engine="openpyxl") as writer:
                df_itens = pd.DataFrame(itens, columns=cols_itens)
                df_rec = pd.DataFrame(rec, columns=cols_rec)
                df_desp = pd.DataFrame(desp, columns=cols_desp)

                if "data_registro" in df_rec.columns:
                    df_rec["data_registro"] = normalize_datetime_column(df_rec["data_registro"])
                if "data_registro" in df_desp.columns:
                    df_desp["data_registro"] = normalize_datetime_column(df_desp["data_registro"])

                # normaliza datas no ITENS, se existirem
                if "data_venda" in df_itens.columns:
                    df_itens["data_venda"] = normalize_date_column(df_itens["data_venda"])
                if "data_saida" in df_itens.columns:
                    df_itens["data_saida"] = normalize_date_column(df_itens["data_saida"])
                if "data_chegada" in df_itens.columns:
                    df_itens["data_chegada"] = normalize_date_column(df_itens["data_chegada"])
                if "saida_dt" in df_itens.columns:
                    df_itens["saida_dt"] = normalize_datetime_column(df_itens["saida_dt"])
                if "chegada_dt" in df_itens.columns:
                    df_itens["chegada_dt"] = normalize_datetime_column(df_itens["chegada_dt"])

                df_itens.to_excel(writer, index=False, sheet_name="ITENS")
                df_rec.to_excel(writer, index=False, sheet_name="RECEBIMENTOS")
                df_desp.to_excel(writer, index=False, sheet_name="DESPESAS")

            messagebox.showinfo("OK", "Excel exportado com sucesso!")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao exportar Excel: {str(e)}")

    def gerar_pdf(self):
        prog = upper(self.cb_prog.get())
        if not require_reportlab():
            return
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação.")
            return

        path = filedialog.asksaveasfilename(
            title="Salvar PDF do Relatório",
            defaultextension=".pdf",
            filetypes=[("PDF", "*.pdf")],
            initialfile=f"RELATORIO_{prog}.pdf"
        )
        if not path:
            return

        self.gerar_resumo()
        txt = self.txt.get("1.0", "end").strip().splitlines()

        try:
            c = canvas.Canvas(path, pagesize=A4)
            w, h = A4
            y = h - 60

            c.setFont("Helvetica-Bold", 14)
            c.drawString(40, y, f"RELATÃ“RIO â€ {prog}")
            y -= 24

            c.setFont("Helvetica", 10)
            for line in txt:
                c.drawString(40, y, line[:110])
                y -= 14
                if y < 60:
                    c.showPage()
                    y = h - 60
                    c.setFont("Helvetica", 10)

            c.save()
            messagebox.showinfo("OK", "PDF gerado com sucesso!")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao gerar PDF: {str(e)}")

    def finalizar_rota(self):
        prog = upper(self.cb_prog.get())
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação.")
            return

        info = self._get_prog_status_info(prog)
        st = info.get("status", "")
        prest = info.get("prestacao_status", "")

        # âœ… Se prestaÃ§Ã£o fechada, nÃ£o faz sentido "finalizar" (jÃ¡ deveria estar travada)
        if prest == "FECHADA":
            messagebox.showwarning(
                "BLOQUEADO",
                f"A rota {prog} está com a prestação FECHADA.\n\n"
                "Ela já está travada para alterações. (Você pode apenas gerar relatórios/exportar.)"
            )
            return

        # âœ… Evita clicar 2x
        if st == "FINALIZADA":
            messagebox.showinfo("Info", f"A rota {prog} já está FINALIZADA.")
            return

        if not messagebox.askyesno(
            "CONFIRMAR",
            f"Deseja FINALIZAR a rota {prog}?\n\n"
            "Ela deixará de aparecer nas Rotas Ativas."
        ):
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("UPDATE programacoes SET status='FINALIZADA' WHERE codigo_programacao=?", (prog,))

            messagebox.showinfo("OK", f"Rota FINALIZADA: {prog}")

            self.refresh_comboboxes()
            if hasattr(self.app, "refresh_programacao_comboboxes"):
                self.app.refresh_programacao_comboboxes()

            self.set_status(f"STATUS: Rota finalizada: {prog}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao finalizar rota: {str(e)}")

    def reabrir_rota(self):
        prog = upper(self.cb_prog.get())
        if not prog:
            messagebox.showwarning("ATENÇÃO", "Selecione uma programação.")
            return

        info = self._get_prog_status_info(prog)
        st = info.get("status", "")
        prest = info.get("prestacao_status", "")

        # ✅ Regra principal: prestação FECHADA => não reabrir rota (senão volta a mexer em despesas/adiantamento)
        if prest == "FECHADA":
            messagebox.showwarning(
                "BLOQUEADO",
                f"Não é permitido REABRIR a rota {prog} pois a prestação está FECHADA.\n\n"
                "Se precisar reabrir, primeiro reabra a prestação (criar função específica) ou ajuste no administrativo."
            )
            return

        if st == "ATIVA":
            messagebox.showinfo("Info", f"A rota {prog} já está ATIVA.")
            return

        if not messagebox.askyesno(
            "CONFIRMAR",
            f"Deseja REABRIR a rota {prog}?\n\n"
            "Ela voltará a aparecer nas Rotas Ativas."
        ):
            return

        try:
            with get_db() as conn:
                cur = conn.cursor()
                cur.execute("UPDATE programacoes SET status='ATIVA' WHERE codigo_programacao=?", (prog,))

            messagebox.showinfo("OK", f"Rota REABERTA: {prog}")

            self.refresh_comboboxes()
            if hasattr(self.app, "refresh_programacao_comboboxes"):
                self.app.refresh_programacao_comboboxes()

            self.set_status(f"STATUS: Rota reaberta: {prog}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao reabrir rota: {str(e)}")

# ==========================
# ===== FIM DA PARTE 8 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 9 (ATUALIZADA) =====
# ==========================

class BackupExportarPage(PageBase):
    def __init__(self, parent, app):
        super().__init__(parent, app, "Backup / Exportar")

        self.app = app

        card = ttk.Frame(self.body, style="Card.TFrame", padding=18)
        card.grid(row=0, column=0, sticky="ew")
        card.grid_columnconfigure(0, weight=1)

        ttk.Label(card, text="Ferramentas", style="CardTitle.TLabel").grid(row=0, column=0, sticky="w", pady=(0, 10))

        ttk.Button(card, text="FAZER BACKUP DO BANCO", style="Primary.TButton", command=self.backup_db)\
            .grid(row=1, column=0, sticky="ew", pady=6)
        ttk.Button(card, text="RESTAURAR BANCO (IMPORTAR .DB)", style="Warn.TButton", command=self.restore_db)\
            .grid(row=2, column=0, sticky="ew", pady=6)
        ttk.Button(card, text="EXPORTAR VENDAS IMPORTADAS (EXCEL)", style="Ghost.TButton", command=self.exportar_vendas)\
            .grid(row=3, column=0, sticky="ew", pady=6)

        self.lbl = ttk.Label(card, text="Dica: Faça backup diariamente.", background="white", foreground="#444")
        self.lbl.grid(row=4, column=0, sticky="w", pady=(12, 0))

    def on_show(self):
        self.set_status("STATUS: Backup e exportações.")

    # ----------------------------
    # Helpers de segurança
    # ----------------------------
    def _is_sqlite_db_file(self, path: str) -> bool:
        """Valida assinatura do arquivo SQLite (primeiros 16 bytes)."""
        try:
            with open(path, "rb") as f:
                header = f.read(16)
            return header == b"SQLite format 3\x00"
        except Exception:
            return False

    def _make_safe_copy(self, src: str, dst: str):
        """Cópia binária simples (mantém compatibilidade)."""
        with open(src, "rb") as fsrc, open(dst, "wb") as fdst:
            shutil.copyfileobj(fsrc, fdst)

    def _cleanup_sqlite_wal(self, db_path: str):
        for suffix in ("-wal", "-shm"):
            p = f"{db_path}{suffix}"
            if os.path.exists(p):
                try:
                    os.remove(p)
                except Exception:
                    logging.debug("Falha ignorada", exc_info=True)

    def _backup_current_db_automatic(self) -> str:
        """Cria um backup automático no mesmo diretório do DB (antes do restore)."""
        if not os.path.exists(DB_PATH):
            return ""
        try:
            base_dir = os.path.dirname(DB_PATH) or "."
            auto_name = f"auto_backup_before_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
            auto_path = os.path.join(base_dir, auto_name)
            self._make_safe_copy(DB_PATH, auto_path)
            return auto_path
        except Exception:
            return ""

    def backup_db(self):
        if not os.path.exists(DB_PATH):
            messagebox.showerror("ERRO", "Banco não encontrado.")
            return

        path = filedialog.asksaveasfilename(
            title="Salvar backup do banco",
            defaultextension=".db",
            filetypes=[("DB", "*.db")],
            initialfile=f"backup_rota_granja_{datetime.now().strftime('%Y%m%d_%H%M')}.db"
        )
        if not path:
            return

        try:
            # ✅ melhor prática: usar SQLite backup API quando possível
            try:
                import sqlite3
                src = sqlite3.connect(DB_PATH)
                dst = sqlite3.connect(path)
                with dst:
                    src.backup(dst)
                dst.close()
                src.close()
            except Exception:
                # fallback: cópia binária (mantém funcionamento se der algo no backup API)
                self._make_safe_copy(DB_PATH, path)

            messagebox.showinfo("OK", "Backup criado com sucesso!")
            self.set_status(f"STATUS: Backup criado: {os.path.basename(path)}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao criar backup: {str(e)}")

    def restore_db(self):
        path = filedialog.askopenfilename(
            title="Selecionar banco (.db)",
            filetypes=[("DB", "*.db")]
        )
        if not path:
            return

        # âœ… valida se Ã© sqlite de verdade
        if not self._is_sqlite_db_file(path):
            messagebox.showerror(
                "ERRO",
                "O arquivo selecionado não parece ser um banco SQLite válido.\n\n"
                "Selecione um .db gerado pelo sistema (backup)."
            )
            return

        # confirmação mais clara (alto risco)
        if not messagebox.askyesno(
            "CONFIRMAR RESTAURAÃ‡ÃƒO",
            "Isso vai SUBSTITUIR seu banco atual.\n\n"
            "Recomendado: fechar telas e não estar com operações em andamento.\n\n"
            "Deseja continuar?"
        ):
            return

        try:
            # ✅ cria backup automático do DB atual
            auto_backup = self._backup_current_db_automatic()

            # Ã¢Å“â€¦ tenta fechar conexÃƒÂµes Ã¢â‚¬Å“conhecidasÃ¢â‚¬Â (melhor esforÃƒÂ§o, sem quebrar)
            try:
                # se existir algum método no app para reabrir/fechar conexões, chamamos
                if hasattr(self.app, "close_db_connections"):
                    self.app.close_db_connections()
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            # limpa WAL/SHM antigos (melhor esforço)
            try:
                self._cleanup_sqlite_wal(DB_PATH)
            except Exception:
                logging.debug("Falha ignorada", exc_info=True)

            # âœ… restaura por cÃ³pia binÃ¡ria (simples e compatÃ­vel)
            # Observação: se houver conexão aberta, pode falhar no Windows.
            self._make_safe_copy(path, DB_PATH)

            msg = "Banco restaurado! Reinicie o sistema."
            if auto_backup:
                msg += f"\n\nBackup automático do banco anterior:\n{os.path.basename(auto_backup)}"

            messagebox.showinfo("OK", msg)
            self.set_status("STATUS: Banco restaurado. Reinicie o sistema.")

        except PermissionError:
            messagebox.showerror(
                "ERRO",
                "Não foi possível substituir o banco (arquivo em uso).\n\n"
                "Feche o sistema e tente novamente, ou reinicie o computador."
            )
        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao restaurar banco: {str(e)}")

    def exportar_vendas(self):
        if not (require_pandas() and require_openpyxl()):
            return
        path = filedialog.asksaveasfilename(
            title="Exportar vendas importadas",
            defaultextension=".xlsx",
            filetypes=[("Excel", "*.xlsx")],
            initialfile=f"VENDAS_IMPORTADAS_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx"
        )
        if not path:
            return

        try:
            with get_db() as conn:
                df = pd.read_sql_query("SELECT * FROM vendas_importadas ORDER BY id DESC", conn)

            if df.empty:
                messagebox.showwarning("ATENÇÃO", "Não há vendas importadas para exportar.")
                return

            try:
                if "data_venda" in df.columns:
                    df["data_venda"] = normalize_date_column(df["data_venda"])
                df.to_excel(path, index=False)
            except Exception as e:
                messagebox.showerror(
                    "ERRO",
                    "Falha ao exportar para Excel.\n\n"
                    "Verifique se o pacote 'openpyxl' está instalado.\n\n"
                    f"Detalhes: {str(e)}"
                )
                return

            messagebox.showinfo("OK", "Exportação feita com sucesso!")
            self.set_status(f"STATUS: Vendas exportadas: {os.path.basename(path)}")

        except Exception as e:
            messagebox.showerror("ERRO", f"Erro ao exportar vendas: {str(e)}")

# ==========================
# ===== FIM DA PARTE 9 (ATUALIZADA) =====
# ==========================

# ==========================
# ===== INCIO DA PARTE 10 (ATUALIZADA) =====
# ==========================

class LoginWindow(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("ROTA GRANJA - Sistema")
        self.geometry("440x280")  # +20px p/ não apertar botões
        self.resizable(False, False)

        # ---- Aplica estilo
        try:
            apply_style(self)
        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

        # ---- Centraliza
        self.update_idletasks()
        w, h = 440, 280
        x = (self.winfo_screenwidth() // 2) - (w // 2)
        y = (self.winfo_screenheight() // 2) - (h // 2)
        self.geometry(f"{w}x{h}+{x}+{y}")

        # ---- Fallback de estilo (evita botão "sumir" por estilo invisível)
        self._ensure_button_styles()

        # ---- Controle de tentativas (segurança leve sem quebrar fluxo)
        self._attempts = 0
        self._blocked_until = 0  # epoch seconds
        self._max_attempts = 5
        self._block_seconds = 15

        card = ttk.Frame(self, style="Card.TFrame", padding=18)
        card.pack(fill="both", expand=True, padx=12, pady=12)

        # ✅ garante espaço do grid dentro do card
        card.grid_columnconfigure(0, weight=1)

        ttk.Label(
            card, text="ACESSO AO SISTEMA", style="CardTitle.TLabel"
        ).grid(row=0, column=0, sticky="w", pady=(0, 6))

        frm = ttk.Frame(card, style="Card.TFrame")
        frm.grid(row=1, column=0, sticky="ew")
        frm.grid_columnconfigure(1, weight=1)

        ttk.Label(frm, text="Nome:", style="CardLabel.TLabel").grid(row=0, column=0, sticky="w", pady=5)
        self.ent_codigo = ttk.Entry(frm, style="Field.TEntry")
        self.ent_codigo.grid(row=0, column=1, sticky="ew", pady=5)

        ttk.Label(frm, text="Senha:", style="CardLabel.TLabel").grid(row=1, column=0, sticky="w", pady=5)
        self.ent_senha = ttk.Entry(frm, style="Field.TEntry", show="*")
        self.ent_senha.grid(row=1, column=1, sticky="ew", pady=5)

        # Mostrar/ocultar senha
        self._show_pass = tk.BooleanVar(value=False)

        def _toggle_pass():
            self.ent_senha.config(show="" if self._show_pass.get() else "*")

        chk = ttk.Checkbutton(frm, text="Mostrar senha", variable=self._show_pass, command=_toggle_pass)
        chk.grid(row=2, column=1, sticky="w", pady=(2, 0))

        self.lbl_status = ttk.Label(card, text="", background="white", foreground="#555")
        self.lbl_status.grid(row=2, column=0, sticky="w", pady=(6, 0))

        btns = ttk.Frame(card, style="Card.TFrame")
        btns.grid(row=3, column=0, sticky="ew", pady=(6, 0))
        btns.grid_columnconfigure(0, weight=1)
        btns.grid_columnconfigure(1, weight=1)

        # ✅ padding e sticky garantem que apareçam e tenham tamanho
        self.btn_entrar = ttk.Button(btns, text="ENTRAR", style="Primary.TButton", command=self.try_login)
        self.btn_entrar.grid(row=0, column=0, sticky="ew", padx=(0, 6), ipady=6)

        self.btn_sair = ttk.Button(btns, text="SAIR", style="Danger.TButton", command=self.destroy)
        self.btn_sair.grid(row=0, column=1, sticky="ew", padx=(6, 0), ipady=6)

        self.ent_codigo.focus_set()
        self.bind("<Return>", lambda e: self.try_login())
        self.bind("<Escape>", lambda e: self.destroy())

        self.user = None  # será preenchido quando logar

    def _ensure_button_styles(self):
        """
        Se o tema não criou Primary.TButton / Danger.TButton, cria um fallback
        para evitar o efeito de "botão invisível".
        Não altera seu tema se já existir.
        """
        try:
            st = ttk.Style(self)
            existing = set(st.theme_names())  # só pra não dar erro em alguns temas
            _ = existing  # quiet

            # Alguns temas não suportam lookup; então testamos com lookup e fallback
            def _style_exists(name: str) -> bool:
                try:
                    # se retornar algo sem dar exception, consideramos "existe"
                    st.lookup(name, "foreground")
                    return True
                except Exception:
                    return False

            # Fallback simples (sem brigar com o apply_style)
            if not _style_exists("Primary.TButton"):
                st.configure("Primary.TButton", padding=10)

            if not _style_exists("Danger.TButton"):
                st.configure("Danger.TButton", padding=10)

        except Exception:
            logging.debug("Falha ignorada", exc_info=True)

    def _is_blocked(self) -> bool:
        try:
            import time
            return time.time() < self._blocked_until
        except Exception:
            return False

    def _block_now(self):
        try:
            import time
            self._blocked_until = time.time() + self._block_seconds
        except Exception:
            self._blocked_until = 0

    def try_login(self):
        if self._is_blocked():
            self.lbl_status.config(text=f"Muitas tentativas. Aguarde {self._block_seconds}s e tente novamente.")
            return

        codigo = upper(self.ent_codigo.get().strip())
        senha = self.ent_senha.get().strip()

        if not codigo or not senha:
            messagebox.showwarning("ATENÇÃO", "Informe código e senha.")
            return

        # âœ… login real: usa sua funÃ§Ã£o existente (mantÃ©m o sistema)
        try:
            user = autenticar_usuario(codigo, senha)
        except Exception as e:
            messagebox.showerror("ERRO", f"Falha ao autenticar: {str(e)}")
            return

        if not user:
            self._attempts += 1
            if self._attempts >= self._max_attempts:
                self._block_now()
                self._attempts = 0
                self.lbl_status.config(text="Muitas tentativas. Login bloqueado temporariamente.")
            else:
                self.lbl_status.config(
                    text=f"Código ou senha inválidos. Tentativas: {self._attempts}/{self._max_attempts}"
                )
            return

        self.user = user
        self.destroy()


def abrir_login():
    win = LoginWindow()
    win.mainloop()

    if not getattr(win, "user", None):
        return  # usuário saiu / cancelou

    app = App(user=win.user)

    if not hasattr(app, "close_db_connections"):
        def _close_db_connections_best_effort():
            return
        app.close_db_connections = _close_db_connections_best_effort

    app.mainloop()


if __name__ == "__main__":
    db_init()  # garante migrações
    abrir_login()

# ==========================
# ===== FIM DA PARTE 10 (ATUALIZADA) =====
# ==========================
